/* C code for program MAX_trajectoryScan, generated by snc from ../MAX_trajectoryScan.st */
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>

#include "seq_snc.h"
# line 19 "../MAX_trajectoryScan.st"
#include <stdlib.h>
# line 20 "../MAX_trajectoryScan.st"
#include <string.h>
# line 21 "../MAX_trajectoryScan.st"
#include <ctype.h>
# line 22 "../MAX_trajectoryScan.st"
#include <stdio.h>
# line 23 "../MAX_trajectoryScan.st"
#include <math.h>
# line 24 "../MAX_trajectoryScan.st"
#include <time.h>
# line 25 "../MAX_trajectoryScan.st"
#include <epicsString.h>
# line 26 "../MAX_trajectoryScan.st"
#include <epicsStdio.h>
# line 27 "../MAX_trajectoryScan.st"
#include <asynOctetSyncIO.h>
# line 173 "../MAX_trajectoryScan.h"
static const EF_ID moveModeMon = 1;
# line 351 "../MAX_trajectoryScan.h"
static const EF_ID buildMon = 2;
# line 352 "../MAX_trajectoryScan.h"
static const EF_ID executeMon = 3;
# line 353 "../MAX_trajectoryScan.h"
static const EF_ID execStateMon = 4;
# line 354 "../MAX_trajectoryScan.h"
static const EF_ID abortMon = 5;
# line 355 "../MAX_trajectoryScan.h"
static const EF_ID readbackMon = 6;
# line 356 "../MAX_trajectoryScan.h"
static const EF_ID nelementsMon = 7;
# line 357 "../MAX_trajectoryScan.h"
static const EF_ID motorMDVSMon = 8;
# line 96 "../MAX_trajectoryScan.st"
extern int MAXV_send_mess(int cardNumber, char const *message, char *name);
# line 102 "../MAX_trajectoryScan.st"
extern int MAXV_recv_mess(int cardNumber, char *message, int amount);
# line 104 "../MAX_trajectoryScan.st"
extern int MAXV_send_recv_mess(int cardNumber, char const *command, char *name, char *message, int amount);
# line 105 "../MAX_trajectoryScan.st"
extern int MAXV_getPositions(int card, epicsInt32 *positions, int nPositions);
# line 113 "../MAX_trajectoryScan.st"
char axis_name[] = "XYZTUVRS";
# line 133 "../MAX_trajectoryScan.st"
double aDist;
# line 134 "../MAX_trajectoryScan.st"
double dDist;
# line 163 "../MAX_trajectoryScan.st"
epicsTimeStamp eStartTime;
# line 166 "../MAX_trajectoryScan.st"
static int writeOnly(SS_ID ssId, struct UserVar *pVar, char *command);
# line 167 "../MAX_trajectoryScan.st"
static int writeRead(SS_ID ssId, struct UserVar *pVar, char *command, char *reply);
# line 168 "../MAX_trajectoryScan.st"
static int getMotorPositions(SS_ID ssId, struct UserVar *pVar, double *pos, epicsInt32 *raw, double *dtime);
# line 169 "../MAX_trajectoryScan.st"
static int getMotorMoving(SS_ID ssId, struct UserVar *pVar, int movingMask);
# line 170 "../MAX_trajectoryScan.st"
static int getEpicsMotorMoving(SS_ID ssId, struct UserVar *pVar);
# line 171 "../MAX_trajectoryScan.st"
static int waitEpicsMotors(SS_ID ssId, struct UserVar *pVar);
# line 172 "../MAX_trajectoryScan.st"
static int buildTrajectory(SS_ID ssId, struct UserVar *pVar, double *realTimeTrajectory,
# line 173 "../MAX_trajectoryScan.st"
double *motorTrajectory, int epicsMotorDir, int moveMode, int npoints, double motorOffset,
# line 174 "../MAX_trajectoryScan.st"
double motorResolution, double motorVmin, int *position, int *velocity, int *acceleration,
# line 175 "../MAX_trajectoryScan.st"
double *accelDist, double *decelDist);
# line 176 "../MAX_trajectoryScan.st"
static int loadTrajectory(SS_ID ssId, struct UserVar *pVar, int simMode);
# line 177 "../MAX_trajectoryScan.st"
static int getStarted(SS_ID ssId, struct UserVar *pVar);
# line 178 "../MAX_trajectoryScan.st"
static int userToRaw(double user, double off, int dir, double res);
# line 179 "../MAX_trajectoryScan.st"
static double rawToUser(int raw, double off, int dir, double res);

/* Variable declarations */
struct seqg_vars {
# line 41 "../MAX_trajectoryScan.h"
	int debugLevel;
# line 43 "../MAX_trajectoryScan.h"
	int numAxes;
# line 45 "../MAX_trajectoryScan.h"
	int nelements;
# line 47 "../MAX_trajectoryScan.h"
	int npulses;
# line 49 "../MAX_trajectoryScan.h"
	int startPulses;
# line 51 "../MAX_trajectoryScan.h"
	int endPulses;
# line 53 "../MAX_trajectoryScan.h"
	int nactual;
# line 54 "../MAX_trajectoryScan.h"
	int moveMode;
# line 56 "../MAX_trajectoryScan.h"
	double time_PV;
# line 58 "../MAX_trajectoryScan.h"
	double timeScale;
# line 60 "../MAX_trajectoryScan.h"
	int timeMode;
# line 62 "../MAX_trajectoryScan.h"
	double accel;
# line 64 "../MAX_trajectoryScan.h"
	int build;
# line 66 "../MAX_trajectoryScan.h"
	int buildState;
# line 67 "../MAX_trajectoryScan.h"
	int buildStatus;
# line 68 "../MAX_trajectoryScan.h"
	string buildMessage;
# line 69 "../MAX_trajectoryScan.h"
	int simMode;
# line 71 "../MAX_trajectoryScan.h"
	int execute;
# line 73 "../MAX_trajectoryScan.h"
	int execState;
# line 75 "../MAX_trajectoryScan.h"
	int execStatus;
# line 76 "../MAX_trajectoryScan.h"
	string execMessage;
# line 77 "../MAX_trajectoryScan.h"
	int abort;
# line 79 "../MAX_trajectoryScan.h"
	int readback;
# line 81 "../MAX_trajectoryScan.h"
	int readState;
# line 82 "../MAX_trajectoryScan.h"
	int readStatus;
# line 83 "../MAX_trajectoryScan.h"
	string readMessage;
# line 84 "../MAX_trajectoryScan.h"
	double timeTrajectory[1000];
# line 87 "../MAX_trajectoryScan.h"
	string trajectoryFile;
# line 93 "../MAX_trajectoryScan.h"
	double elapsedTime;
# line 96 "../MAX_trajectoryScan.h"
	int outBitNum;
# line 100 "../MAX_trajectoryScan.h"
	int inBitNum;
# line 104 "../MAX_trajectoryScan.h"
	double overrideFactor;
# line 108 "../MAX_trajectoryScan.h"
	int updateFreq;
# line 112 "../MAX_trajectoryScan.h"
	double realTimeTrajectory[1000];
# line 116 "../MAX_trajectoryScan.h"
	int motorCurrentRaw[8];
# line 117 "../MAX_trajectoryScan.h"
	int motorCurrentVRaw[8];
# line 118 "../MAX_trajectoryScan.h"
	int motorCurrentARaw[8];
# line 121 "../MAX_trajectoryScan.h"
	double epicsMotorMres[8];
# line 126 "../MAX_trajectoryScan.h"
	int epicsMotorCard[8];
# line 131 "../MAX_trajectoryScan.h"
	double epicsMotorHLM[8];
# line 134 "../MAX_trajectoryScan.h"
	double epicsMotorLLM[8];
# line 138 "../MAX_trajectoryScan.h"
	double motorMinSpeed[8];
# line 149 "../MAX_trajectoryScan.h"
	double motorMaxSpeed[8];
# line 160 "../MAX_trajectoryScan.h"
	double motorStart[8];
# line 171 "../MAX_trajectoryScan.h"
	int addAccelDecel;
# line 174 "../MAX_trajectoryScan.h"
	int moveModePrev;
# line 178 "../MAX_trajectoryScan.h"
	int moveAxis[8];
# line 190 "../MAX_trajectoryScan.h"
	double motorTrajectory[8][1000];
# line 202 "../MAX_trajectoryScan.h"
	double motorReadbacks[8][1000];
# line 213 "../MAX_trajectoryScan.h"
	double motorError[8][1000];
# line 224 "../MAX_trajectoryScan.h"
	double motorCurrent[8];
# line 235 "../MAX_trajectoryScan.h"
	double motorMDVS[8];
# line 247 "../MAX_trajectoryScan.h"
	double motorMDVA[8];
# line 258 "../MAX_trajectoryScan.h"
	int motorMDVE[8];
# line 269 "../MAX_trajectoryScan.h"
	double motorMVA[8];
# line 280 "../MAX_trajectoryScan.h"
	int motorMVE[8];
# line 291 "../MAX_trajectoryScan.h"
	double motorMAA[8];
# line 302 "../MAX_trajectoryScan.h"
	int motorMAE[8];
# line 315 "../MAX_trajectoryScan.h"
	double epicsMotorPos[8];
# line 319 "../MAX_trajectoryScan.h"
	int epicsMotorDir[8];
# line 323 "../MAX_trajectoryScan.h"
	double epicsMotorOff[8];
# line 327 "../MAX_trajectoryScan.h"
	double epicsMotorDone[8];
# line 331 "../MAX_trajectoryScan.h"
	double epicsMotorVELO[8];
# line 335 "../MAX_trajectoryScan.h"
	double epicsMotorVMAX[8];
# line 339 "../MAX_trajectoryScan.h"
	double epicsMotorVMIN[8];
# line 343 "../MAX_trajectoryScan.h"
	double epicsMotorACCL[8];
# line 347 "../MAX_trajectoryScan.h"
	string epicsMotorOUT[8];
# line 89 "../MAX_trajectoryScan.st"
	int cardNumber;
# line 114 "../MAX_trajectoryScan.st"
	char stringOut[100];
# line 115 "../MAX_trajectoryScan.st"
	char sbuf[100];
# line 116 "../MAX_trajectoryScan.st"
	char stringIn[100];
# line 117 "../MAX_trajectoryScan.st"
	char *asynPort;
# line 118 "../MAX_trajectoryScan.st"
	char *pasynUser;
# line 119 "../MAX_trajectoryScan.st"
	int status;
# line 120 "../MAX_trajectoryScan.st"
	int i;
# line 121 "../MAX_trajectoryScan.st"
	int j;
# line 122 "../MAX_trajectoryScan.st"
	int k;
# line 123 "../MAX_trajectoryScan.st"
	int n;
# line 124 "../MAX_trajectoryScan.st"
	double delay;
# line 125 "../MAX_trajectoryScan.st"
	int anyMoving;
# line 126 "../MAX_trajectoryScan.st"
	int ncomplete;
# line 127 "../MAX_trajectoryScan.st"
	int nextra;
# line 128 "../MAX_trajectoryScan.st"
	int npoints;
# line 129 "../MAX_trajectoryScan.st"
	double dtime;
# line 130 "../MAX_trajectoryScan.st"
	double dpos;
# line 131 "../MAX_trajectoryScan.st"
	double accelDist[8];
# line 132 "../MAX_trajectoryScan.st"
	double decelDist[8];
# line 135 "../MAX_trajectoryScan.st"
	double posActual;
# line 136 "../MAX_trajectoryScan.st"
	double posTheory;
# line 137 "../MAX_trajectoryScan.st"
	double expectedTime;
# line 138 "../MAX_trajectoryScan.st"
	double initialPos[8];
# line 139 "../MAX_trajectoryScan.st"
	char macroBuf[100];
# line 140 "../MAX_trajectoryScan.st"
	char motorName[100];
# line 141 "../MAX_trajectoryScan.st"
	char *p;
# line 142 "../MAX_trajectoryScan.st"
	char *tok_save;
# line 143 "../MAX_trajectoryScan.st"
	int currPulse;
# line 144 "../MAX_trajectoryScan.st"
	double frac;
# line 145 "../MAX_trajectoryScan.st"
	double deltaV;
# line 146 "../MAX_trajectoryScan.st"
	double v;
# line 147 "../MAX_trajectoryScan.st"
	double vO;
# line 148 "../MAX_trajectoryScan.st"
	int vOverride;
# line 149 "../MAX_trajectoryScan.st"
	double lastPollTime;
# line 150 "../MAX_trajectoryScan.st"
	int lastRealTimePoint;
# line 151 "../MAX_trajectoryScan.st"
	int doPoll;
# line 152 "../MAX_trajectoryScan.st"
	int initStatus;
# line 153 "../MAX_trajectoryScan.st"
	int limitViolation;
# line 157 "../MAX_trajectoryScan.st"
	int motorCurrentIndex[8];
# line 158 "../MAX_trajectoryScan.st"
	int epicsMotorDoneIndex[8];
# line 162 "../MAX_trajectoryScan.st"
	unsigned long startTime;
# line 181 "../MAX_trajectoryScan.st"
	int position[8][1002];
# line 182 "../MAX_trajectoryScan.st"
	int velocity[8][1002];
# line 183 "../MAX_trajectoryScan.st"
	int acceleration[8][1002];
# line 185 "../MAX_trajectoryScan.st"
	double realTimeTrajectoryAccelDecel[1002];
# line 186 "../MAX_trajectoryScan.st"
	double *rttraj;
# line 188 "../MAX_trajectoryScan.st"
	int motorStartRaw[8];
# line 189 "../MAX_trajectoryScan.st"
	double motorEnd[8];
# line 190 "../MAX_trajectoryScan.st"
	double dbuf[1000];
# line 193 "../MAX_trajectoryScan.st"
	int movingMask;
# line 194 "../MAX_trajectoryScan.st"
	int waitingForTrigger;
# line 197 "../MAX_trajectoryScan.st"
	double vmax;
# line 198 "../MAX_trajectoryScan.st"
	double amax;
# line 200 "../MAX_trajectoryScan.st"
	int card;
# line 201 "../MAX_trajectoryScan.st"
	int signal;
};


/* Function declarations */

#define seqg_var (*(struct seqg_vars *const *)seqg_env)

/* Program init func */
static void seqg_init(PROG_ID seqg_env)
{
}

/****** Code for state "init" in state set "maxTrajectoryScan" ******/

/* Event function for state "init" in state set "maxTrajectoryScan" */
static seqBool seqg_event_maxTrajectoryScan_0_init(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "init" in state set "maxTrajectoryScan" */
static void seqg_action_maxTrajectoryScan_0_init(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 208 "../MAX_trajectoryScan.st"
			seqg_var->cardNumber = -2;
# line 209 "../MAX_trajectoryScan.st"
			seqg_var->initStatus = 0;
# line 211 "../MAX_trajectoryScan.st"
			if (seqg_var->numAxes > 8)
# line 211 "../MAX_trajectoryScan.st"
				seqg_var->numAxes = 8;
# line 212 "../MAX_trajectoryScan.st"
			for (seqg_var->i = 0; seqg_var->i < seqg_var->numAxes; seqg_var->i++)
			{
# line 213 "../MAX_trajectoryScan.st"
				sprintf(seqg_var->macroBuf, "M%d", seqg_var->i + 1);
# line 215 "../MAX_trajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.VAL", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 216 "../MAX_trajectoryScan.st"
				seq_pvAssign(seqg_env, 187/*epicsMotorPos*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 217 "../MAX_trajectoryScan.st"
				seq_pvMonitor(seqg_env, 187/*epicsMotorPos*/ + (CH_ID)(seqg_var->i));
# line 219 "../MAX_trajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.DIR", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 220 "../MAX_trajectoryScan.st"
				seq_pvAssign(seqg_env, 195/*epicsMotorDir*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 221 "../MAX_trajectoryScan.st"
				seq_pvMonitor(seqg_env, 195/*epicsMotorDir*/ + (CH_ID)(seqg_var->i));
# line 223 "../MAX_trajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.OFF", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 224 "../MAX_trajectoryScan.st"
				seq_pvAssign(seqg_env, 203/*epicsMotorOff*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 225 "../MAX_trajectoryScan.st"
				seq_pvMonitor(seqg_env, 203/*epicsMotorOff*/ + (CH_ID)(seqg_var->i));
# line 227 "../MAX_trajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.DMOV", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 228 "../MAX_trajectoryScan.st"
				seq_pvAssign(seqg_env, 211/*epicsMotorDone*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 229 "../MAX_trajectoryScan.st"
				seq_pvMonitor(seqg_env, 211/*epicsMotorDone*/ + (CH_ID)(seqg_var->i));
# line 231 "../MAX_trajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.MRES", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 232 "../MAX_trajectoryScan.st"
				seq_pvAssign(seqg_env, 34/*epicsMotorMres*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 233 "../MAX_trajectoryScan.st"
				seq_pvMonitor(seqg_env, 34/*epicsMotorMres*/ + (CH_ID)(seqg_var->i));
# line 235 "../MAX_trajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.CARD", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 236 "../MAX_trajectoryScan.st"
				seq_pvAssign(seqg_env, 42/*epicsMotorCard*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 237 "../MAX_trajectoryScan.st"
				seq_pvMonitor(seqg_env, 42/*epicsMotorCard*/ + (CH_ID)(seqg_var->i));
# line 239 "../MAX_trajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.HLM", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 240 "../MAX_trajectoryScan.st"
				seq_pvAssign(seqg_env, 50/*epicsMotorHLM*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 241 "../MAX_trajectoryScan.st"
				seq_pvMonitor(seqg_env, 50/*epicsMotorHLM*/ + (CH_ID)(seqg_var->i));
# line 243 "../MAX_trajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.LLM", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 244 "../MAX_trajectoryScan.st"
				seq_pvAssign(seqg_env, 58/*epicsMotorLLM*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 245 "../MAX_trajectoryScan.st"
				seq_pvMonitor(seqg_env, 58/*epicsMotorLLM*/ + (CH_ID)(seqg_var->i));
# line 247 "../MAX_trajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.VELO", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 248 "../MAX_trajectoryScan.st"
				seq_pvAssign(seqg_env, 219/*epicsMotorVELO*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 249 "../MAX_trajectoryScan.st"
				seq_pvMonitor(seqg_env, 219/*epicsMotorVELO*/ + (CH_ID)(seqg_var->i));
# line 251 "../MAX_trajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.VMAX", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 252 "../MAX_trajectoryScan.st"
				seq_pvAssign(seqg_env, 227/*epicsMotorVMAX*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 253 "../MAX_trajectoryScan.st"
				seq_pvMonitor(seqg_env, 227/*epicsMotorVMAX*/ + (CH_ID)(seqg_var->i));
# line 255 "../MAX_trajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.VBAS", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 256 "../MAX_trajectoryScan.st"
				seq_pvAssign(seqg_env, 235/*epicsMotorVMIN*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 257 "../MAX_trajectoryScan.st"
				seq_pvMonitor(seqg_env, 235/*epicsMotorVMIN*/ + (CH_ID)(seqg_var->i));
# line 259 "../MAX_trajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.ACCL", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 260 "../MAX_trajectoryScan.st"
				seq_pvAssign(seqg_env, 243/*epicsMotorACCL*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 261 "../MAX_trajectoryScan.st"
				seq_pvMonitor(seqg_env, 243/*epicsMotorACCL*/ + (CH_ID)(seqg_var->i));
# line 263 "../MAX_trajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.OUT", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 264 "../MAX_trajectoryScan.st"
				seq_pvAssign(seqg_env, 251/*epicsMotorOUT*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 265 "../MAX_trajectoryScan.st"
				seq_pvGetTmo(seqg_env, 251/*epicsMotorOUT*/ + (CH_ID)(seqg_var->i), DEFAULT, DEFAULT_TIMEOUT);
# line 267 "../MAX_trajectoryScan.st"
				sscanf(seqg_var->epicsMotorOUT[seqg_var->i], "#C%d S%d", &seqg_var->card, &seqg_var->signal);
# line 268 "../MAX_trajectoryScan.st"
				if (seqg_var->signal != seqg_var->i)
				{
# line 269 "../MAX_trajectoryScan.st"
					printf("MAX_trajectoryScan: motor %d has signal %d (must be same)\n", seqg_var->i, seqg_var->signal);
# line 270 "../MAX_trajectoryScan.st"
					seqg_var->initStatus = 2;
				}
# line 273 "../MAX_trajectoryScan.st"
				if (seqg_var->cardNumber == -2)
				{
# line 274 "../MAX_trajectoryScan.st"
					seqg_var->cardNumber = seqg_var->epicsMotorCard[seqg_var->i];
				}
				else
				{
# line 276 "../MAX_trajectoryScan.st"
					if (seqg_var->cardNumber != seqg_var->epicsMotorCard[seqg_var->i])
					{
# line 277 "../MAX_trajectoryScan.st"
						printf("MAX_trajectoryScan: motors not on same card: %d %d\n", seqg_var->cardNumber, seqg_var->epicsMotorCard[seqg_var->i]);
# line 278 "../MAX_trajectoryScan.st"
						seqg_var->initStatus = 2;
					}
				}
			}
# line 290 "../MAX_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 291 "../MAX_trajectoryScan.st"
				seqg_var->motorCurrentIndex[seqg_var->j] = seq_pvIndex(seqg_env, 123/*motorCurrent*/ + (CH_ID)(seqg_var->j));
# line 292 "../MAX_trajectoryScan.st"
				seqg_var->epicsMotorDoneIndex[seqg_var->j] = seq_pvIndex(seqg_env, 211/*epicsMotorDone*/ + (CH_ID)(seqg_var->j));
			}
# line 296 "../MAX_trajectoryScan.st"
			seq_efClear(seqg_env, buildMon);
# line 297 "../MAX_trajectoryScan.st"
			seq_efClear(seqg_env, executeMon);
# line 298 "../MAX_trajectoryScan.st"
			seq_efClear(seqg_env, abortMon);
# line 299 "../MAX_trajectoryScan.st"
			seq_efClear(seqg_env, readbackMon);
# line 300 "../MAX_trajectoryScan.st"
			seq_efClear(seqg_env, nelementsMon);
# line 301 "../MAX_trajectoryScan.st"
			seq_efClear(seqg_env, motorMDVSMon);
# line 302 "../MAX_trajectoryScan.st"
			seq_efClear(seqg_env, moveModeMon);
# line 304 "../MAX_trajectoryScan.st"
			seqg_var->moveModePrev = seqg_var->moveMode;
# line 305 "../MAX_trajectoryScan.st"
			if (seqg_var->initStatus == 0)
# line 305 "../MAX_trajectoryScan.st"
				seqg_var->initStatus = 1;
		}
		return;
	}
}

/****** Code for state "monitor_inputs" in state set "maxTrajectoryScan" ******/

/* Event function for state "monitor_inputs" in state set "maxTrajectoryScan" */
static seqBool seqg_event_maxTrajectoryScan_0_monitor_inputs(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 311 "../MAX_trajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, buildMon) && (seqg_var->build == 1) && (seqg_var->initStatus == 1))
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 314 "../MAX_trajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, executeMon) && (seqg_var->execute == 1) && (seqg_var->buildStatus == 1))
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 317 "../MAX_trajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, readbackMon) && (seqg_var->readback == 1))
	{
		*seqg_pnst = 5;
		*seqg_ptrn = 2;
		return TRUE;
	}
# line 320 "../MAX_trajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, nelementsMon) && (seqg_var->nelements >= 1))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 3;
		return TRUE;
	}
# line 328 "../MAX_trajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, motorMDVSMon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 4;
		return TRUE;
	}
# line 332 "../MAX_trajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, moveModeMon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 5;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "monitor_inputs" in state set "maxTrajectoryScan" */
static void seqg_action_maxTrajectoryScan_0_monitor_inputs(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
		}
		return;
	case 1:
		{
		}
		return;
	case 2:
		{
		}
		return;
	case 3:
		{
# line 324 "../MAX_trajectoryScan.st"
			seqg_var->endPulses = seqg_var->nelements;
# line 325 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 5/*endPulses*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 4:
		{
		}
		return;
	case 5:
		{
# line 334 "../MAX_trajectoryScan.st"
			if (seqg_var->moveMode == 2)
			{
# line 335 "../MAX_trajectoryScan.st"
				seqg_var->moveMode = seqg_var->moveModePrev;
# line 336 "../MAX_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 7/*moveMode*/, DEFAULT, DEFAULT_TIMEOUT);
			}
			else
			{
# line 338 "../MAX_trajectoryScan.st"
				seqg_var->moveModePrev = seqg_var->moveMode;
			}
# line 340 "../MAX_trajectoryScan.st"
			seqg_var->buildStatus = 0;
# line 341 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 14/*buildStatus*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "build" in state set "maxTrajectoryScan" ******/

/* Event function for state "build" in state set "maxTrajectoryScan" */
static seqBool seqg_event_maxTrajectoryScan_0_build(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "build" in state set "maxTrajectoryScan" */
static void seqg_action_maxTrajectoryScan_0_build(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 349 "../MAX_trajectoryScan.st"
			seqg_var->buildState = 1;
# line 350 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 13/*buildState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 351 "../MAX_trajectoryScan.st"
			seqg_var->buildStatus = 0;
# line 352 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 14/*buildStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 353 "../MAX_trajectoryScan.st"
			epicsSnprintf(seqg_var->buildMessage, 40, "Building...");
# line 354 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 15/*buildMessage*/, DEFAULT, DEFAULT_TIMEOUT);
# line 357 "../MAX_trajectoryScan.st"
			seqg_var->buildStatus = 1;
# line 361 "../MAX_trajectoryScan.st"
			if (seqg_var->timeMode == 0)
			{
# line 362 "../MAX_trajectoryScan.st"
				seqg_var->dtime = seqg_var->time_PV / (seqg_var->nelements - 1);
# line 363 "../MAX_trajectoryScan.st"
				for (seqg_var->i = 0; seqg_var->i < seqg_var->nelements - 1; seqg_var->i++)
# line 363 "../MAX_trajectoryScan.st"
					seqg_var->timeTrajectory[seqg_var->i] = seqg_var->dtime;
# line 364 "../MAX_trajectoryScan.st"
				for (seqg_var->i = seqg_var->nelements - 1; seqg_var->i < 1000; seqg_var->i++)
# line 364 "../MAX_trajectoryScan.st"
					seqg_var->timeTrajectory[seqg_var->i] = 0;
# line 365 "../MAX_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 26/*timeTrajectory*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 368 "../MAX_trajectoryScan.st"
			if (seqg_var->moveMode == 0)
			{
# line 369 "../MAX_trajectoryScan.st"
				seqg_var->npoints = seqg_var->nelements;
			}
			else
			{
# line 371 "../MAX_trajectoryScan.st"
				seqg_var->npoints = seqg_var->nelements;
			}
# line 375 "../MAX_trajectoryScan.st"
			seqg_var->realTimeTrajectory[0] = 0.;
# line 376 "../MAX_trajectoryScan.st"
			for (seqg_var->i = 1; seqg_var->i < seqg_var->npoints; seqg_var->i++)
			{
# line 377 "../MAX_trajectoryScan.st"
				seqg_var->realTimeTrajectory[seqg_var->i] = seqg_var->realTimeTrajectory[seqg_var->i - 1] + seqg_var->timeTrajectory[seqg_var->i - 1];
			}
# line 379 "../MAX_trajectoryScan.st"
			for (seqg_var->i = 0; seqg_var->i < seqg_var->npoints; seqg_var->i++)
# line 379 "../MAX_trajectoryScan.st"
				seqg_var->realTimeTrajectory[seqg_var->i] *= seqg_var->timeScale;
# line 382 "../MAX_trajectoryScan.st"
			for (; seqg_var->i < 1000; seqg_var->i++)
# line 382 "../MAX_trajectoryScan.st"
				seqg_var->realTimeTrajectory[seqg_var->i] = seqg_var->realTimeTrajectory[seqg_var->i - 1];
# line 383 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 33/*realTimeTrajectory*/, DEFAULT, DEFAULT_TIMEOUT);
# line 386 "../MAX_trajectoryScan.st"
			seqg_var->realTimeTrajectoryAccelDecel[0] = 0;
# line 387 "../MAX_trajectoryScan.st"
			for (seqg_var->i = 1; seqg_var->i < seqg_var->npoints + 1; seqg_var->i++)
# line 387 "../MAX_trajectoryScan.st"
				seqg_var->realTimeTrajectoryAccelDecel[seqg_var->i] = seqg_var->realTimeTrajectory[seqg_var->i - 1] + seqg_var->accel;
# line 388 "../MAX_trajectoryScan.st"
			seqg_var->realTimeTrajectoryAccelDecel[seqg_var->npoints + 1] = seqg_var->realTimeTrajectoryAccelDecel[seqg_var->npoints] + seqg_var->accel;
# line 391 "../MAX_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < 8; seqg_var->j++)
			{
# line 392 "../MAX_trajectoryScan.st"
				if (seqg_var->moveAxis[seqg_var->j])
				{
# line 393 "../MAX_trajectoryScan.st"
					seqg_var->rttraj = seqg_var->realTimeTrajectoryAccelDecel;
# line 394 "../MAX_trajectoryScan.st"
					if (seqg_var->addAccelDecel)
# line 394 "../MAX_trajectoryScan.st"
						seqg_var->rttraj = seqg_var->realTimeTrajectoryAccelDecel;
					buildTrajectory(ssId, pVar, pVar->rttraj, pVar->motorTrajectory[pVar->j],
					pVar->epicsMotorDir[pVar->j], pVar->moveMode, pVar->npoints,
					pVar->epicsMotorOff[pVar->j], pVar->epicsMotorMres[pVar->j], pVar->epicsMotorVMIN[pVar->j],
					pVar->position[pVar->j], pVar->velocity[pVar->j], pVar->acceleration[pVar->j],
					&aDist, &dDist);
					pVar->accelDist[pVar->j] = aDist;
					pVar->decelDist[pVar->j] = dDist;
				}
			}
# line 406 "../MAX_trajectoryScan.st"
			if (seqg_var->addAccelDecel)
			{
# line 408 "../MAX_trajectoryScan.st"
				seqg_var->expectedTime = seqg_var->realTimeTrajectoryAccelDecel[seqg_var->npoints + 1];
			}
			else
			{
# line 410 "../MAX_trajectoryScan.st"
				seqg_var->expectedTime = seqg_var->realTimeTrajectory[seqg_var->npoints - 1];
			}
# line 414 "../MAX_trajectoryScan.st"
			seqg_var->limitViolation = 0;
# line 415 "../MAX_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes && !seqg_var->limitViolation; seqg_var->j++)
			{
# line 416 "../MAX_trajectoryScan.st"
				if (seqg_var->moveAxis[seqg_var->j])
				{
# line 417 "../MAX_trajectoryScan.st"
					seqg_var->vmax = seqg_var->epicsMotorVMAX[seqg_var->j];
# line 418 "../MAX_trajectoryScan.st"
					if (fabs(seqg_var->vmax) < .001)
# line 418 "../MAX_trajectoryScan.st"
						seqg_var->vmax = seqg_var->epicsMotorVELO[seqg_var->j];
# line 419 "../MAX_trajectoryScan.st"
					seqg_var->amax = seqg_var->vmax / seqg_var->epicsMotorACCL[seqg_var->j];
# line 420 "../MAX_trajectoryScan.st"
					seqg_var->motorMVA[seqg_var->j] = 0.;
# line 421 "../MAX_trajectoryScan.st"
					seqg_var->motorMAA[seqg_var->j] = 0.;
# line 422 "../MAX_trajectoryScan.st"
					seqg_var->motorMVE[seqg_var->j] = 0;
# line 423 "../MAX_trajectoryScan.st"
					seqg_var->motorMAE[seqg_var->j] = 0;
# line 424 "../MAX_trajectoryScan.st"
					for (seqg_var->k = 0; seqg_var->k < seqg_var->npoints && !seqg_var->limitViolation; seqg_var->k++)
					{
# line 425 "../MAX_trajectoryScan.st"
						seqg_var->posActual = seqg_var->motorTrajectory[seqg_var->j][seqg_var->k];
# line 426 "../MAX_trajectoryScan.st"
						if (seqg_var->moveMode != 1)
# line 426 "../MAX_trajectoryScan.st"
							seqg_var->posActual += seqg_var->epicsMotorPos[seqg_var->j];
# line 427 "../MAX_trajectoryScan.st"
						seqg_var->limitViolation |= (seqg_var->posActual > seqg_var->epicsMotorHLM[seqg_var->j]) || (seqg_var->posActual < seqg_var->epicsMotorLLM[seqg_var->j]);
# line 428 "../MAX_trajectoryScan.st"
						if (seqg_var->limitViolation)
						{
# line 429 "../MAX_trajectoryScan.st"
							epicsSnprintf(seqg_var->buildMessage, 40, "Limit: m%d at pt. %d (%f)", seqg_var->j + 1, seqg_var->k + 1, seqg_var->posActual);
						}
# line 431 "../MAX_trajectoryScan.st"
						if (seqg_var->velocity[seqg_var->j][seqg_var->k] * seqg_var->epicsMotorMres[seqg_var->j] > seqg_var->vmax)
						{
# line 432 "../MAX_trajectoryScan.st"
							seqg_var->limitViolation |= 1;
# line 434 "../MAX_trajectoryScan.st"
							epicsSnprintf(seqg_var->buildMessage, 40, "V limit: m%d at pt. %d (%f)", seqg_var->j + 1, seqg_var->k + 1, seqg_var->velocity[seqg_var->j][seqg_var->k] * seqg_var->epicsMotorMres[seqg_var->j]);
						}
# line 436 "../MAX_trajectoryScan.st"
						if (fabs(seqg_var->acceleration[seqg_var->j][seqg_var->k] * seqg_var->epicsMotorMres[seqg_var->j]) > seqg_var->amax)
						{
# line 437 "../MAX_trajectoryScan.st"
							seqg_var->limitViolation |= 1;
# line 439 "../MAX_trajectoryScan.st"
							epicsSnprintf(seqg_var->buildMessage, 40, "A limit: m%d at pt. %d (%f)", seqg_var->j + 1, seqg_var->k + 1, seqg_var->acceleration[seqg_var->j][seqg_var->k] * seqg_var->epicsMotorMres[seqg_var->j]);
						}
# line 441 "../MAX_trajectoryScan.st"
						if (fabs(seqg_var->velocity[seqg_var->j][seqg_var->k]) > seqg_var->motorMVA[seqg_var->j])
						{
# line 442 "../MAX_trajectoryScan.st"
							seqg_var->motorMVA[seqg_var->j] = seqg_var->velocity[seqg_var->j][seqg_var->k];
# line 443 "../MAX_trajectoryScan.st"
							seqg_var->motorMVE[seqg_var->j] = seqg_var->k;
						}
# line 445 "../MAX_trajectoryScan.st"
						if (fabs(seqg_var->acceleration[seqg_var->j][seqg_var->k]) > seqg_var->motorMAA[seqg_var->j])
						{
# line 446 "../MAX_trajectoryScan.st"
							seqg_var->motorMAA[seqg_var->j] = seqg_var->acceleration[seqg_var->j][seqg_var->k];
# line 447 "../MAX_trajectoryScan.st"
							seqg_var->motorMAE[seqg_var->j] = seqg_var->k;
						}
					}
# line 450 "../MAX_trajectoryScan.st"
					seqg_var->motorMVA[seqg_var->j] *= seqg_var->epicsMotorMres[seqg_var->j];
# line 451 "../MAX_trajectoryScan.st"
					seqg_var->motorMAA[seqg_var->j] *= seqg_var->epicsMotorMres[seqg_var->j];
# line 452 "../MAX_trajectoryScan.st"
					seq_pvPutTmo(seqg_env, 155/*motorMVA*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
# line 453 "../MAX_trajectoryScan.st"
					seq_pvPutTmo(seqg_env, 171/*motorMAA*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
# line 454 "../MAX_trajectoryScan.st"
					seq_pvPutTmo(seqg_env, 163/*motorMVE*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
# line 455 "../MAX_trajectoryScan.st"
					seq_pvPutTmo(seqg_env, 179/*motorMAE*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
				}
			}
# line 459 "../MAX_trajectoryScan.st"
			if (seqg_var->limitViolation)
			{
# line 460 "../MAX_trajectoryScan.st"
				seqg_var->buildStatus = 2;
			}
# line 464 "../MAX_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 465 "../MAX_trajectoryScan.st"
				if (seqg_var->moveAxis[seqg_var->j])
				{
# line 466 "../MAX_trajectoryScan.st"
					if (seqg_var->moveMode == 1)
					{
# line 467 "../MAX_trajectoryScan.st"
						seqg_var->motorStart[seqg_var->j] = seqg_var->motorTrajectory[seqg_var->j][0];
# line 468 "../MAX_trajectoryScan.st"
						seqg_var->motorEnd[seqg_var->j] = seqg_var->motorTrajectory[seqg_var->j][seqg_var->npoints - 1];
					}
					else
					{
# line 470 "../MAX_trajectoryScan.st"
						seqg_var->motorStart[seqg_var->j] = seqg_var->epicsMotorPos[seqg_var->j];
# line 471 "../MAX_trajectoryScan.st"
						seqg_var->motorEnd[seqg_var->j] = seqg_var->motorStart[seqg_var->j] + (seqg_var->motorTrajectory[seqg_var->j][seqg_var->npoints - 1] - seqg_var->motorTrajectory[seqg_var->j][0]);
					}
# line 473 "../MAX_trajectoryScan.st"
					if (seqg_var->addAccelDecel)
					{
# line 474 "../MAX_trajectoryScan.st"
						seqg_var->motorStart[seqg_var->j] -= seqg_var->accelDist[seqg_var->j];
# line 475 "../MAX_trajectoryScan.st"
						seqg_var->motorEnd[seqg_var->j] += seqg_var->decelDist[seqg_var->j];
					}
# line 477 "../MAX_trajectoryScan.st"
					seq_pvPutTmo(seqg_env, 82/*motorStart*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
				}
			}
			getMotorPositions(ssId, pVar, pVar->motorCurrent, pVar->motorCurrentRaw, &(pVar->dtime));
# line 483 "../MAX_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 484 "../MAX_trajectoryScan.st"
				if (seqg_var->moveAxis[seqg_var->j])
				{
# line 485 "../MAX_trajectoryScan.st"
					seq_pvPutTmo(seqg_env, 123/*motorCurrent*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
				}
			}
# line 499 "../MAX_trajectoryScan.st"
			seqg_var->buildState = 0;
# line 500 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 13/*buildState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 501 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 14/*buildStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 502 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 15/*buildMessage*/, DEFAULT, DEFAULT_TIMEOUT);
# line 505 "../MAX_trajectoryScan.st"
			seqg_var->build = 0;
# line 506 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 12/*build*/, DEFAULT, DEFAULT_TIMEOUT);
# line 507 "../MAX_trajectoryScan.st"
			if (seqg_var->buildStatus == 1)
			{
# line 508 "../MAX_trajectoryScan.st"
				epicsSnprintf(seqg_var->buildMessage, 40, "Done");
# line 509 "../MAX_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 15/*buildMessage*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	}
}

/****** Code for state "execute" in state set "maxTrajectoryScan" ******/

/* Event function for state "execute" in state set "maxTrajectoryScan" */
static seqBool seqg_event_maxTrajectoryScan_0_execute(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 4;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "execute" in state set "maxTrajectoryScan" */
static void seqg_action_maxTrajectoryScan_0_execute(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 518 "../MAX_trajectoryScan.st"
			seqg_var->execState = 1;
# line 519 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 18/*execState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 521 "../MAX_trajectoryScan.st"
			seqg_var->execStatus = 0;
# line 522 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 19/*execStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 524 "../MAX_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 525 "../MAX_trajectoryScan.st"
				for (seqg_var->i = 0; seqg_var->i < 1000; seqg_var->i++)
				{
# line 526 "../MAX_trajectoryScan.st"
					seqg_var->motorReadbacks[seqg_var->j][seqg_var->i] = 0.;
# line 527 "../MAX_trajectoryScan.st"
					seqg_var->motorError[seqg_var->j][seqg_var->i] = 0.;
				}
			}
# line 530 "../MAX_trajectoryScan.st"
			seqg_var->currPulse = 0;
# line 532 "../MAX_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
# line 532 "../MAX_trajectoryScan.st"
				seqg_var->motorStart[seqg_var->j] = seqg_var->epicsMotorPos[seqg_var->j];
# line 535 "../MAX_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 536 "../MAX_trajectoryScan.st"
				if (seqg_var->moveAxis[seqg_var->j])
				{
# line 537 "../MAX_trajectoryScan.st"
					if (seqg_var->moveMode == 1)
					{
# line 538 "../MAX_trajectoryScan.st"
						seqg_var->motorStart[seqg_var->j] = seqg_var->motorTrajectory[seqg_var->j][0];
# line 539 "../MAX_trajectoryScan.st"
						seqg_var->motorEnd[seqg_var->j] = seqg_var->motorTrajectory[seqg_var->j][seqg_var->npoints - 1];
					}
					else
					{
# line 541 "../MAX_trajectoryScan.st"
						seqg_var->motorStart[seqg_var->j] = seqg_var->epicsMotorPos[seqg_var->j];
# line 542 "../MAX_trajectoryScan.st"
						seqg_var->motorEnd[seqg_var->j] = seqg_var->motorStart[seqg_var->j] + (seqg_var->motorTrajectory[seqg_var->j][seqg_var->npoints - 1] - seqg_var->motorTrajectory[seqg_var->j][0]);
					}
# line 544 "../MAX_trajectoryScan.st"
					if (seqg_var->addAccelDecel)
					{
# line 545 "../MAX_trajectoryScan.st"
						seqg_var->motorStart[seqg_var->j] -= seqg_var->accelDist[seqg_var->j];
# line 546 "../MAX_trajectoryScan.st"
						seqg_var->motorEnd[seqg_var->j] += seqg_var->decelDist[seqg_var->j];
					}
# line 548 "../MAX_trajectoryScan.st"
					seq_pvPutTmo(seqg_env, 82/*motorStart*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
				}
			}
# line 553 "../MAX_trajectoryScan.st"
			if ((seqg_var->moveMode == 1) || seqg_var->addAccelDecel)
			{
# line 554 "../MAX_trajectoryScan.st"
				for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
				{
# line 555 "../MAX_trajectoryScan.st"
					if (seqg_var->moveAxis[seqg_var->j])
					{
# line 556 "../MAX_trajectoryScan.st"
						seqg_var->epicsMotorPos[seqg_var->j] = seqg_var->motorStart[seqg_var->j];
# line 557 "../MAX_trajectoryScan.st"
						seq_pvPutTmo(seqg_env, 187/*epicsMotorPos*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
					}
				}
				waitEpicsMotors(ssId, pVar);
			}
			loadTrajectory(ssId, pVar, pVar->simMode);
			getMotorPositions(ssId, pVar, pVar->motorStart, pVar->motorStartRaw, &(pVar->dtime));
# line 573 "../MAX_trajectoryScan.st"
			seqg_var->n = sprintf(seqg_var->stringOut, "AM;");
# line 574 "../MAX_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < 8; seqg_var->j++)
			{
# line 575 "../MAX_trajectoryScan.st"
				if (seqg_var->moveAxis[seqg_var->j])
				{
# line 576 "../MAX_trajectoryScan.st"
					seqg_var->n += sprintf(&(seqg_var->stringOut[seqg_var->n]), "VO[%d]=100;", seqg_var->j + 1);
				}
			}
			writeOnly(ssId, pVar, pVar->stringOut);
# line 581 "../MAX_trajectoryScan.st"
			seqg_var->n = sprintf(seqg_var->stringOut, "AM;");
# line 582 "../MAX_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < 8; seqg_var->j++)
			{
# line 583 "../MAX_trajectoryScan.st"
				if (seqg_var->moveAxis[seqg_var->j])
				{
# line 584 "../MAX_trajectoryScan.st"
					seqg_var->n += sprintf(&(seqg_var->stringOut[seqg_var->n]), "VG[%d];", seqg_var->j + 1);
				}
			}
			writeOnly(ssId, pVar, pVar->stringOut);
# line 590 "../MAX_trajectoryScan.st"
			seqg_var->elapsedTime = 0.;
# line 591 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 28/*elapsedTime*/, DEFAULT, DEFAULT_TIMEOUT);
# line 592 "../MAX_trajectoryScan.st"
			seqg_var->startTime = time(0);
			epicsTimeGetCurrent(&eStartTime);
# line 594 "../MAX_trajectoryScan.st"
			seqg_var->execState = 2;
# line 595 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 18/*execState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 596 "../MAX_trajectoryScan.st"
			seqg_var->lastPollTime = -(1 / 5.);
# line 597 "../MAX_trajectoryScan.st"
			seqg_var->lastRealTimePoint = 0;
# line 598 "../MAX_trajectoryScan.st"
			seqg_var->waitingForTrigger = ((seqg_var->inBitNum >= 0) && (seqg_var->inBitNum <= 15));
# line 599 "../MAX_trajectoryScan.st"
			for (seqg_var->j = 0 , seqg_var->movingMask = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 600 "../MAX_trajectoryScan.st"
				if (seqg_var->moveAxis[seqg_var->j])
# line 600 "../MAX_trajectoryScan.st"
					seqg_var->movingMask |= (1 << seqg_var->j);
			}
		}
		return;
	}
}

/****** Code for state "wait_execute" in state set "maxTrajectoryScan" ******/

/* Event function for state "wait_execute" in state set "maxTrajectoryScan" */
static seqBool seqg_event_maxTrajectoryScan_0_wait_execute(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 608 "../MAX_trajectoryScan.st"
	if (seqg_var->execStatus == 3)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 638 "../MAX_trajectoryScan.st"
	if (seqg_var->execState == 2)
	{
		*seqg_pnst = 4;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 745 "../MAX_trajectoryScan.st"
	if (seqg_var->execState == 3)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 2;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "wait_execute" in state set "maxTrajectoryScan" */
static void seqg_action_maxTrajectoryScan_0_wait_execute(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 612 "../MAX_trajectoryScan.st"
			if (seqg_var->debugLevel)
# line 612 "../MAX_trajectoryScan.st"
				printf("\nabort\n");
# line 613 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 28/*elapsedTime*/, DEFAULT, DEFAULT_TIMEOUT);
# line 614 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 19/*execStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 615 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 20/*execMessage*/, DEFAULT, DEFAULT_TIMEOUT);
			getMotorPositions(ssId, pVar, pVar->motorCurrent, pVar->motorCurrentRaw, &(pVar->dtime));
# line 618 "../MAX_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 619 "../MAX_trajectoryScan.st"
				if (seqg_var->moveAxis[seqg_var->j])
				{
# line 620 "../MAX_trajectoryScan.st"
					seq_pvPutTmo(seqg_env, 123/*motorCurrent*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
# line 621 "../MAX_trajectoryScan.st"
					seqg_var->epicsMotorPos[seqg_var->j] = seqg_var->motorCurrent[seqg_var->j];
# line 625 "../MAX_trajectoryScan.st"
					seq_pvPutTmo(seqg_env, 187/*epicsMotorPos*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
				}
			}
			waitEpicsMotors(ssId, pVar);
# line 629 "../MAX_trajectoryScan.st"
			if (seqg_var->debugLevel)
# line 629 "../MAX_trajectoryScan.st"
				printf("\n...abort done\n");
# line 630 "../MAX_trajectoryScan.st"
			seqg_var->execState = 0;
# line 631 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 18/*execState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 634 "../MAX_trajectoryScan.st"
			seqg_var->execute = 0;
# line 635 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 17/*execute*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 1:
		{
# line 640 "../MAX_trajectoryScan.st"
			if (seqg_var->waitingForTrigger)
			{
				/* C code definitions */
# line 641 "../MAX_trajectoryScan.st"
				getMotorPositions(ssId, pVar, pVar->motorCurrent, pVar->motorCurrentRaw, &(pVar->dtime));
# line 642 "../MAX_trajectoryScan.st"
				for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
				{
# line 643 "../MAX_trajectoryScan.st"
					if (seqg_var->moveAxis[seqg_var->j] && (seqg_var->motorStartRaw[seqg_var->j] != seqg_var->motorCurrentRaw[seqg_var->j]))
# line 643 "../MAX_trajectoryScan.st"
						seqg_var->waitingForTrigger = 0;
				}
# line 645 "../MAX_trajectoryScan.st"
				if (seqg_var->waitingForTrigger)
				{
					/* C code definitions */
# line 646 "../MAX_trajectoryScan.st"
					pVar->waitingForTrigger = (getStarted(ssId, pVar) ? 0 : 1);
# line 647 "../MAX_trajectoryScan.st"
					seqg_var->startTime = time(0);
					epicsTimeGetCurrent(&eStartTime);
				}
			}
# line 652 "../MAX_trajectoryScan.st"
			if (!seqg_var->waitingForTrigger)
			{
				/* C code definitions */
# line 654 "../MAX_trajectoryScan.st"
				getMotorPositions(ssId, pVar, pVar->motorCurrent, pVar->motorCurrentRaw, &(pVar->dtime));
# line 655 "../MAX_trajectoryScan.st"
				seqg_var->elapsedTime = seqg_var->dtime;
# line 657 "../MAX_trajectoryScan.st"
				seqg_var->doPoll = (seqg_var->dtime - seqg_var->lastPollTime) > (1 / 5.);
# line 658 "../MAX_trajectoryScan.st"
				if (seqg_var->doPoll)
# line 658 "../MAX_trajectoryScan.st"
					seq_pvPutTmo(seqg_env, 28/*elapsedTime*/, DEFAULT, DEFAULT_TIMEOUT);
# line 659 "../MAX_trajectoryScan.st"
				for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
				{
# line 660 "../MAX_trajectoryScan.st"
					if (seqg_var->moveAxis[seqg_var->j])
					{
# line 661 "../MAX_trajectoryScan.st"
						seq_pvPutTmo(seqg_env, 123/*motorCurrent*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
# line 663 "../MAX_trajectoryScan.st"
						if (seqg_var->currPulse < 1000 - 1)
						{
# line 664 "../MAX_trajectoryScan.st"
							seqg_var->motorReadbacks[seqg_var->j][seqg_var->currPulse] = seqg_var->motorCurrent[seqg_var->j];
# line 665 "../MAX_trajectoryScan.st"
							seqg_var->motorError[seqg_var->j][seqg_var->currPulse] = seqg_var->dtime;
# line 666 "../MAX_trajectoryScan.st"
							if (seqg_var->debugLevel >= 10)
# line 667 "../MAX_trajectoryScan.st"
								printf("wait_execute: motor %d: rb=%f, t=%f\n", seqg_var->j, seqg_var->motorReadbacks[seqg_var->j][seqg_var->currPulse], seqg_var->motorError[seqg_var->j][seqg_var->currPulse]);
						}
# line 671 "../MAX_trajectoryScan.st"
						for (seqg_var->i = seqg_var->lastRealTimePoint; (seqg_var->i < seqg_var->npoints - 1) && (seqg_var->dtime > 0.) && (seqg_var->dtime > seqg_var->realTimeTrajectoryAccelDecel[seqg_var->i]); seqg_var->i++)
# line 671 "../MAX_trajectoryScan.st"
							;
# line 672 "../MAX_trajectoryScan.st"
						seqg_var->i--;
# line 673 "../MAX_trajectoryScan.st"
						if (seqg_var->i < 0)
# line 673 "../MAX_trajectoryScan.st"
							seqg_var->i = 0;
# line 674 "../MAX_trajectoryScan.st"
						if (seqg_var->doPoll && (seqg_var->i > 2) && (seqg_var->i < seqg_var->npoints - 2) && (seqg_var->overrideFactor >= .01) && (seqg_var->currPulse < 1000 - 1))
						{
# line 675 "../MAX_trajectoryScan.st"
							if (seqg_var->debugLevel >= 10)
# line 676 "../MAX_trajectoryScan.st"
								printf("wait_execute: time=%f, i=%d, realTimeTrajectoryAccelDecel[i]=%f\n", seqg_var->dtime, seqg_var->i, seqg_var->realTimeTrajectoryAccelDecel[seqg_var->i]);
# line 677 "../MAX_trajectoryScan.st"
							seqg_var->frac = (seqg_var->dtime - seqg_var->realTimeTrajectoryAccelDecel[seqg_var->i]) / (seqg_var->realTimeTrajectoryAccelDecel[seqg_var->i + 1] - seqg_var->realTimeTrajectoryAccelDecel[seqg_var->i]);
# line 678 "../MAX_trajectoryScan.st"
							seqg_var->posTheory = seqg_var->motorTrajectory[seqg_var->j][seqg_var->i] + seqg_var->frac * (seqg_var->motorTrajectory[seqg_var->j][seqg_var->i + 1] - seqg_var->motorTrajectory[seqg_var->j][seqg_var->i]);
# line 679 "../MAX_trajectoryScan.st"
							if (seqg_var->moveMode != 1)
							{
# line 680 "../MAX_trajectoryScan.st"
								seqg_var->posTheory += seqg_var->motorStart[seqg_var->j];
							}
# line 682 "../MAX_trajectoryScan.st"
							seqg_var->dpos = seqg_var->motorCurrent[seqg_var->j] - seqg_var->posTheory;
# line 683 "../MAX_trajectoryScan.st"
							if (seqg_var->debugLevel >= 4)
# line 684 "../MAX_trajectoryScan.st"
								printf("\n   wait_execute: actual=%.2f, ideal=%.2f, err=%.2f\n", seqg_var->motorCurrent[seqg_var->j], seqg_var->posTheory, seqg_var->dpos);
# line 687 "../MAX_trajectoryScan.st"
							seqg_var->v = (seqg_var->motorReadbacks[seqg_var->j][seqg_var->currPulse] - seqg_var->motorReadbacks[seqg_var->j][seqg_var->currPulse - 1]) / (seqg_var->motorError[seqg_var->j][seqg_var->currPulse] - seqg_var->motorError[seqg_var->j][seqg_var->currPulse - 1]);
# line 690 "../MAX_trajectoryScan.st"
							seqg_var->deltaV = seqg_var->dpos / (seqg_var->realTimeTrajectoryAccelDecel[seqg_var->i + 1] - seqg_var->realTimeTrajectoryAccelDecel[seqg_var->i]);
# line 691 "../MAX_trajectoryScan.st"
							seqg_var->vO = (1 - (seqg_var->deltaV / seqg_var->v) * seqg_var->overrideFactor) * 100;
							pVar->vOverride = (int)((pVar->vO)>0 ? (pVar->vO)+0.5 : (pVar->vO)-0.5);
# line 693 "../MAX_trajectoryScan.st"
							if (seqg_var->vOverride < 80)
# line 693 "../MAX_trajectoryScan.st"
								seqg_var->vOverride = 80;
# line 694 "../MAX_trajectoryScan.st"
							if (seqg_var->vOverride > 120)
# line 694 "../MAX_trajectoryScan.st"
								seqg_var->vOverride = 120;
# line 695 "../MAX_trajectoryScan.st"
							if (seqg_var->debugLevel >= 10)
# line 696 "../MAX_trajectoryScan.st"
								printf("   wait_execute: v=%.2f, dV=%.2f, vOverride=%.2f (%d)\n", seqg_var->v, seqg_var->deltaV, seqg_var->vO, seqg_var->vOverride);
# line 698 "../MAX_trajectoryScan.st"
							sprintf(seqg_var->stringOut, "AM; VO[%d]=%d;", seqg_var->j + 1, seqg_var->vOverride);
							writeOnly(ssId, pVar, pVar->stringOut);
# line 700 "../MAX_trajectoryScan.st"
							if (seqg_var->debugLevel >= 2)
# line 700 "../MAX_trajectoryScan.st"
								printf(", 'VO[%d]=%3d'", seqg_var->j + 1, seqg_var->vOverride);
						}
					}
				}
# line 705 "../MAX_trajectoryScan.st"
				++seqg_var->currPulse;
# line 706 "../MAX_trajectoryScan.st"
				seqg_var->lastRealTimePoint = seqg_var->i;
# line 707 "../MAX_trajectoryScan.st"
				if (seqg_var->doPoll)
				{
# line 708 "../MAX_trajectoryScan.st"
					seqg_var->lastPollTime = seqg_var->dtime;
					pVar->anyMoving = getMotorMoving(ssId, pVar, pVar->movingMask);
# line 710 "../MAX_trajectoryScan.st"
					if (seqg_var->anyMoving == 0)
					{
# line 711 "../MAX_trajectoryScan.st"
						seqg_var->execState = 3;
# line 712 "../MAX_trajectoryScan.st"
						seqg_var->execStatus = 1;
# line 713 "../MAX_trajectoryScan.st"
						strcpy(seqg_var->execMessage, " ");
					}
# line 716 "../MAX_trajectoryScan.st"
					if (difftime(time(0), seqg_var->startTime) > seqg_var->expectedTime * 2.)
					{
# line 717 "../MAX_trajectoryScan.st"
						seqg_var->execState = 3;
# line 718 "../MAX_trajectoryScan.st"
						seqg_var->execStatus = 4;
# line 719 "../MAX_trajectoryScan.st"
						strcpy(seqg_var->execMessage, "Timeout");
# line 721 "../MAX_trajectoryScan.st"
						for (seqg_var->j = 0; seqg_var->j < 8; seqg_var->j++)
						{
# line 722 "../MAX_trajectoryScan.st"
							if (seqg_var->moveAxis[seqg_var->j])
							{
# line 723 "../MAX_trajectoryScan.st"
								sprintf(seqg_var->stringOut, "AM; VH[%d]1;", seqg_var->j + 1);
								writeOnly(ssId, pVar, pVar->stringOut);
							}
						}
# line 729 "../MAX_trajectoryScan.st"
						sprintf(seqg_var->stringOut, "KS");
# line 730 "../MAX_trajectoryScan.st"
						for (seqg_var->j = 0; seqg_var->j < 8; seqg_var->j++)
						{
# line 731 "../MAX_trajectoryScan.st"
							if (seqg_var->moveAxis[seqg_var->j])
# line 731 "../MAX_trajectoryScan.st"
								strcat(seqg_var->stringOut, "1");
# line 732 "../MAX_trajectoryScan.st"
							if (seqg_var->j < (8 - 1))
# line 732 "../MAX_trajectoryScan.st"
								strcat(seqg_var->stringOut, ",");
						}
# line 734 "../MAX_trajectoryScan.st"
						strcat(seqg_var->stringOut, ";");
# line 735 "../MAX_trajectoryScan.st"
						if (seqg_var->debugLevel)
# line 735 "../MAX_trajectoryScan.st"
							printf("timeout: sending command '%s'\n", seqg_var->stringOut);
						writeOnly(ssId, pVar, pVar->stringOut);
						waitEpicsMotors(ssId, pVar);
					}
				}
			}
		}
		return;
	case 2:
		{
# line 746 "../MAX_trajectoryScan.st"
			if (seqg_var->debugLevel)
# line 746 "../MAX_trajectoryScan.st"
				printf("\nflyback. currPulse=%d\n", seqg_var->currPulse);
# line 747 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 28/*elapsedTime*/, DEFAULT, DEFAULT_TIMEOUT);
# line 748 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 18/*execState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 749 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 19/*execStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 750 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 20/*execMessage*/, DEFAULT, DEFAULT_TIMEOUT);
			getMotorPositions(ssId, pVar, pVar->motorCurrent, pVar->motorCurrentRaw, &(pVar->dtime));
# line 753 "../MAX_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 754 "../MAX_trajectoryScan.st"
				if (seqg_var->moveAxis[seqg_var->j])
				{
# line 755 "../MAX_trajectoryScan.st"
					seq_pvPutTmo(seqg_env, 123/*motorCurrent*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
# line 756 "../MAX_trajectoryScan.st"
					seqg_var->epicsMotorPos[seqg_var->j] = seqg_var->motorCurrent[seqg_var->j];
# line 760 "../MAX_trajectoryScan.st"
					seq_pvPutTmo(seqg_env, 187/*epicsMotorPos*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
				}
			}
			waitEpicsMotors(ssId, pVar);
# line 764 "../MAX_trajectoryScan.st"
			if (seqg_var->debugLevel)
# line 764 "../MAX_trajectoryScan.st"
				printf("\n...flyback done\n");
# line 766 "../MAX_trajectoryScan.st"
			seqg_var->execState = 0;
# line 767 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 18/*execState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 770 "../MAX_trajectoryScan.st"
			seqg_var->execute = 0;
# line 771 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 17/*execute*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "readback" in state set "maxTrajectoryScan" ******/

/* Event function for state "readback" in state set "maxTrajectoryScan" */
static seqBool seqg_event_maxTrajectoryScan_0_readback(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "readback" in state set "maxTrajectoryScan" */
static void seqg_action_maxTrajectoryScan_0_readback(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 779 "../MAX_trajectoryScan.st"
			seqg_var->readState = 1;
# line 780 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 23/*readState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 781 "../MAX_trajectoryScan.st"
			seqg_var->readStatus = 0;
# line 782 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 24/*readStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 785 "../MAX_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < 8; seqg_var->j++)
			{
# line 786 "../MAX_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 107/*motorReadbacks*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
# line 787 "../MAX_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 115/*motorError*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
			}
# line 790 "../MAX_trajectoryScan.st"
			seqg_var->readState = 0;
# line 791 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 23/*readState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 793 "../MAX_trajectoryScan.st"
			seqg_var->readStatus = 1;
# line 794 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 24/*readStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 795 "../MAX_trajectoryScan.st"
			strcpy(seqg_var->readMessage, " ");
# line 796 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 25/*readMessage*/, DEFAULT, DEFAULT_TIMEOUT);
# line 799 "../MAX_trajectoryScan.st"
			seqg_var->readback = 0;
# line 800 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 22/*readback*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "monitorAbort" in state set "trajectoryAbort" ******/

/* Event function for state "monitorAbort" in state set "trajectoryAbort" */
static seqBool seqg_event_trajectoryAbort_1_monitorAbort(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 812 "../MAX_trajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, abortMon) && (seqg_var->abort == 1))
	{
		*seqg_pnst = 0;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "monitorAbort" in state set "trajectoryAbort" */
static void seqg_action_trajectoryAbort_1_monitorAbort(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 813 "../MAX_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < 8; seqg_var->j++)
			{
# line 814 "../MAX_trajectoryScan.st"
				if (seqg_var->moveAxis[seqg_var->j])
				{
# line 815 "../MAX_trajectoryScan.st"
					sprintf(seqg_var->stringOut, "AM; VH[%d]1;", seqg_var->j + 1);
					writeOnly(ssId, pVar, pVar->stringOut);
				}
			}
# line 821 "../MAX_trajectoryScan.st"
			sprintf(seqg_var->stringOut, "KS");
# line 822 "../MAX_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < 8; seqg_var->j++)
			{
# line 823 "../MAX_trajectoryScan.st"
				if (seqg_var->moveAxis[seqg_var->j])
# line 823 "../MAX_trajectoryScan.st"
					strcat(seqg_var->stringOut, "1");
# line 824 "../MAX_trajectoryScan.st"
				if (seqg_var->j < (8 - 1))
# line 824 "../MAX_trajectoryScan.st"
					strcat(seqg_var->stringOut, ",");
			}
# line 826 "../MAX_trajectoryScan.st"
			strcat(seqg_var->stringOut, ";");
# line 827 "../MAX_trajectoryScan.st"
			if (seqg_var->debugLevel)
# line 827 "../MAX_trajectoryScan.st"
				printf("abort: sending command '%s'\n", seqg_var->stringOut);
			writeOnly(ssId, pVar, pVar->stringOut);
# line 830 "../MAX_trajectoryScan.st"
			seqg_var->execStatus = 3;
# line 831 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 19/*execStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 832 "../MAX_trajectoryScan.st"
			strcpy(seqg_var->execMessage, "Motion aborted");
# line 833 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 20/*execMessage*/, DEFAULT, DEFAULT_TIMEOUT);
# line 834 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 28/*elapsedTime*/, DEFAULT, DEFAULT_TIMEOUT);
# line 837 "../MAX_trajectoryScan.st"
			seqg_var->abort = 0;
# line 838 "../MAX_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 21/*abort*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

#undef seqg_var

/************************ Tables ************************/

/* Channel table */
static seqChan seqg_chans[] = {
	/* chName, offset, varName, varType, count, eventNum, efId, monitored, queueSize, queueIndex */
	{"{P}{R}DebugLevel.VAL", offsetof(struct seqg_vars, debugLevel), "debugLevel", P_INT, 1, 9, 0, 1, 0, 0},
	{"{P}{R}NumAxes.VAL", offsetof(struct seqg_vars, numAxes), "numAxes", P_INT, 1, 10, 0, 1, 0, 0},
	{"{P}{R}Nelements.VAL", offsetof(struct seqg_vars, nelements), "nelements", P_INT, 1, 11, 7, 1, 0, 0},
	{"{P}{R}Npulses.VAL", offsetof(struct seqg_vars, npulses), "npulses", P_INT, 1, 12, 0, 1, 0, 0},
	{"{P}{R}StartPulses.VAL", offsetof(struct seqg_vars, startPulses), "startPulses", P_INT, 1, 13, 0, 1, 0, 0},
	{"{P}{R}EndPulses.VAL", offsetof(struct seqg_vars, endPulses), "endPulses", P_INT, 1, 14, 0, 1, 0, 0},
	{"{P}{R}Nactual.VAL", offsetof(struct seqg_vars, nactual), "nactual", P_INT, 1, 15, 0, 0, 0, 0},
	{"{P}{R}MoveMode.VAL", offsetof(struct seqg_vars, moveMode), "moveMode", P_INT, 1, 16, 1, 1, 0, 0},
	{"{P}{R}Time.VAL", offsetof(struct seqg_vars, time_PV), "time_PV", P_DOUBLE, 1, 17, 0, 1, 0, 0},
	{"{P}{R}TimeScale.VAL", offsetof(struct seqg_vars, timeScale), "timeScale", P_DOUBLE, 1, 18, 0, 1, 0, 0},
	{"{P}{R}TimeMode.VAL", offsetof(struct seqg_vars, timeMode), "timeMode", P_INT, 1, 19, 0, 1, 0, 0},
	{"{P}{R}Accel.VAL", offsetof(struct seqg_vars, accel), "accel", P_DOUBLE, 1, 20, 0, 1, 0, 0},
	{"{P}{R}Build.VAL", offsetof(struct seqg_vars, build), "build", P_INT, 1, 21, 2, 1, 0, 0},
	{"{P}{R}BuildState.VAL", offsetof(struct seqg_vars, buildState), "buildState", P_INT, 1, 22, 0, 0, 0, 0},
	{"{P}{R}BuildStatus.VAL", offsetof(struct seqg_vars, buildStatus), "buildStatus", P_INT, 1, 23, 0, 0, 0, 0},
	{"{P}{R}BuildMessage.VAL", offsetof(struct seqg_vars, buildMessage), "buildMessage", P_STRING, 1, 24, 0, 0, 0, 0},
	{"{P}{R}SimMode.VAL", offsetof(struct seqg_vars, simMode), "simMode", P_INT, 1, 25, 0, 1, 0, 0},
	{"{P}{R}Execute.VAL", offsetof(struct seqg_vars, execute), "execute", P_INT, 1, 26, 3, 1, 0, 0},
	{"{P}{R}ExecState.VAL", offsetof(struct seqg_vars, execState), "execState", P_INT, 1, 27, 4, 1, 0, 0},
	{"{P}{R}ExecStatus.VAL", offsetof(struct seqg_vars, execStatus), "execStatus", P_INT, 1, 28, 0, 0, 0, 0},
	{"{P}{R}ExecMessage.VAL", offsetof(struct seqg_vars, execMessage), "execMessage", P_STRING, 1, 29, 0, 0, 0, 0},
	{"{P}{R}Abort.VAL", offsetof(struct seqg_vars, abort), "abort", P_INT, 1, 30, 5, 1, 0, 0},
	{"{P}{R}Readback.VAL", offsetof(struct seqg_vars, readback), "readback", P_INT, 1, 31, 6, 1, 0, 0},
	{"{P}{R}ReadState.VAL", offsetof(struct seqg_vars, readState), "readState", P_INT, 1, 32, 0, 0, 0, 0},
	{"{P}{R}ReadStatus.VAL", offsetof(struct seqg_vars, readStatus), "readStatus", P_INT, 1, 33, 0, 0, 0, 0},
	{"{P}{R}ReadMessage.VAL", offsetof(struct seqg_vars, readMessage), "readMessage", P_STRING, 1, 34, 0, 0, 0, 0},
	{"{P}{R}TimeTraj.VAL", offsetof(struct seqg_vars, timeTrajectory), "timeTrajectory", P_DOUBLE, 1000, 35, 0, 1, 0, 0},
	{"{P}{R}TrajectoryFile.VAL", offsetof(struct seqg_vars, trajectoryFile), "trajectoryFile", P_STRING, 1, 36, 0, 1, 0, 0},
	{"{P}{R}ElapsedTime.VAL", offsetof(struct seqg_vars, elapsedTime), "elapsedTime", P_DOUBLE, 1, 37, 0, 0, 0, 0},
	{"{P}{R}OutBitNum.VAL", offsetof(struct seqg_vars, outBitNum), "outBitNum", P_INT, 1, 38, 0, 1, 0, 0},
	{"{P}{R}InBitNum.VAL", offsetof(struct seqg_vars, inBitNum), "inBitNum", P_INT, 1, 39, 0, 1, 0, 0},
	{"{P}{R}OverrideFactor", offsetof(struct seqg_vars, overrideFactor), "overrideFactor", P_DOUBLE, 1, 40, 0, 1, 0, 0},
	{"{P}{R}UpdateFreq.RVAL", offsetof(struct seqg_vars, updateFreq), "updateFreq", P_INT, 1, 41, 0, 1, 0, 0},
	{"{P}{R}realTimeTrajectory.VAL", offsetof(struct seqg_vars, realTimeTrajectory), "realTimeTrajectory", P_DOUBLE, 1000, 42, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorMres[0]), "epicsMotorMres[0]", P_DOUBLE, 1, 43, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorMres[1]), "epicsMotorMres[1]", P_DOUBLE, 1, 44, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorMres[2]), "epicsMotorMres[2]", P_DOUBLE, 1, 45, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorMres[3]), "epicsMotorMres[3]", P_DOUBLE, 1, 46, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorMres[4]), "epicsMotorMres[4]", P_DOUBLE, 1, 47, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorMres[5]), "epicsMotorMres[5]", P_DOUBLE, 1, 48, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorMres[6]), "epicsMotorMres[6]", P_DOUBLE, 1, 49, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorMres[7]), "epicsMotorMres[7]", P_DOUBLE, 1, 50, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorCard[0]), "epicsMotorCard[0]", P_INT, 1, 51, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorCard[1]), "epicsMotorCard[1]", P_INT, 1, 52, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorCard[2]), "epicsMotorCard[2]", P_INT, 1, 53, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorCard[3]), "epicsMotorCard[3]", P_INT, 1, 54, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorCard[4]), "epicsMotorCard[4]", P_INT, 1, 55, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorCard[5]), "epicsMotorCard[5]", P_INT, 1, 56, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorCard[6]), "epicsMotorCard[6]", P_INT, 1, 57, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorCard[7]), "epicsMotorCard[7]", P_INT, 1, 58, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorHLM[0]), "epicsMotorHLM[0]", P_DOUBLE, 1, 59, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorHLM[1]), "epicsMotorHLM[1]", P_DOUBLE, 1, 60, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorHLM[2]), "epicsMotorHLM[2]", P_DOUBLE, 1, 61, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorHLM[3]), "epicsMotorHLM[3]", P_DOUBLE, 1, 62, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorHLM[4]), "epicsMotorHLM[4]", P_DOUBLE, 1, 63, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorHLM[5]), "epicsMotorHLM[5]", P_DOUBLE, 1, 64, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorHLM[6]), "epicsMotorHLM[6]", P_DOUBLE, 1, 65, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorHLM[7]), "epicsMotorHLM[7]", P_DOUBLE, 1, 66, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorLLM[0]), "epicsMotorLLM[0]", P_DOUBLE, 1, 67, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorLLM[1]), "epicsMotorLLM[1]", P_DOUBLE, 1, 68, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorLLM[2]), "epicsMotorLLM[2]", P_DOUBLE, 1, 69, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorLLM[3]), "epicsMotorLLM[3]", P_DOUBLE, 1, 70, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorLLM[4]), "epicsMotorLLM[4]", P_DOUBLE, 1, 71, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorLLM[5]), "epicsMotorLLM[5]", P_DOUBLE, 1, 72, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorLLM[6]), "epicsMotorLLM[6]", P_DOUBLE, 1, 73, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorLLM[7]), "epicsMotorLLM[7]", P_DOUBLE, 1, 74, 0, 1, 0, 0},
	{"{P}{R}M1MinSpeed.VAL", offsetof(struct seqg_vars, motorMinSpeed[0]), "motorMinSpeed[0]", P_DOUBLE, 1, 75, 0, 0, 0, 0},
	{"{P}{R}M2MinSpeed.VAL", offsetof(struct seqg_vars, motorMinSpeed[1]), "motorMinSpeed[1]", P_DOUBLE, 1, 76, 0, 0, 0, 0},
	{"{P}{R}M3MinSpeed.VAL", offsetof(struct seqg_vars, motorMinSpeed[2]), "motorMinSpeed[2]", P_DOUBLE, 1, 77, 0, 0, 0, 0},
	{"{P}{R}M4MinSpeed.VAL", offsetof(struct seqg_vars, motorMinSpeed[3]), "motorMinSpeed[3]", P_DOUBLE, 1, 78, 0, 0, 0, 0},
	{"{P}{R}M5MinSpeed.VAL", offsetof(struct seqg_vars, motorMinSpeed[4]), "motorMinSpeed[4]", P_DOUBLE, 1, 79, 0, 0, 0, 0},
	{"{P}{R}M6MinSpeed.VAL", offsetof(struct seqg_vars, motorMinSpeed[5]), "motorMinSpeed[5]", P_DOUBLE, 1, 80, 0, 0, 0, 0},
	{"{P}{R}M7MinSpeed.VAL", offsetof(struct seqg_vars, motorMinSpeed[6]), "motorMinSpeed[6]", P_DOUBLE, 1, 81, 0, 0, 0, 0},
	{"{P}{R}M8MinSpeed.VAL", offsetof(struct seqg_vars, motorMinSpeed[7]), "motorMinSpeed[7]", P_DOUBLE, 1, 82, 0, 0, 0, 0},
	{"{P}{R}M1MaxSpeed.VAL", offsetof(struct seqg_vars, motorMaxSpeed[0]), "motorMaxSpeed[0]", P_DOUBLE, 1, 83, 0, 0, 0, 0},
	{"{P}{R}M2MaxSpeed.VAL", offsetof(struct seqg_vars, motorMaxSpeed[1]), "motorMaxSpeed[1]", P_DOUBLE, 1, 84, 0, 0, 0, 0},
	{"{P}{R}M3MaxSpeed.VAL", offsetof(struct seqg_vars, motorMaxSpeed[2]), "motorMaxSpeed[2]", P_DOUBLE, 1, 85, 0, 0, 0, 0},
	{"{P}{R}M4MaxSpeed.VAL", offsetof(struct seqg_vars, motorMaxSpeed[3]), "motorMaxSpeed[3]", P_DOUBLE, 1, 86, 0, 0, 0, 0},
	{"{P}{R}M5MaxSpeed.VAL", offsetof(struct seqg_vars, motorMaxSpeed[4]), "motorMaxSpeed[4]", P_DOUBLE, 1, 87, 0, 0, 0, 0},
	{"{P}{R}M6MaxSpeed.VAL", offsetof(struct seqg_vars, motorMaxSpeed[5]), "motorMaxSpeed[5]", P_DOUBLE, 1, 88, 0, 0, 0, 0},
	{"{P}{R}M7MaxSpeed.VAL", offsetof(struct seqg_vars, motorMaxSpeed[6]), "motorMaxSpeed[6]", P_DOUBLE, 1, 89, 0, 0, 0, 0},
	{"{P}{R}M8MaxSpeed.VAL", offsetof(struct seqg_vars, motorMaxSpeed[7]), "motorMaxSpeed[7]", P_DOUBLE, 1, 90, 0, 0, 0, 0},
	{"{P}{R}M1Start.VAL", offsetof(struct seqg_vars, motorStart[0]), "motorStart[0]", P_DOUBLE, 1, 91, 0, 0, 0, 0},
	{"{P}{R}M2Start.VAL", offsetof(struct seqg_vars, motorStart[1]), "motorStart[1]", P_DOUBLE, 1, 92, 0, 0, 0, 0},
	{"{P}{R}M3Start.VAL", offsetof(struct seqg_vars, motorStart[2]), "motorStart[2]", P_DOUBLE, 1, 93, 0, 0, 0, 0},
	{"{P}{R}M4Start.VAL", offsetof(struct seqg_vars, motorStart[3]), "motorStart[3]", P_DOUBLE, 1, 94, 0, 0, 0, 0},
	{"{P}{R}M5Start.VAL", offsetof(struct seqg_vars, motorStart[4]), "motorStart[4]", P_DOUBLE, 1, 95, 0, 0, 0, 0},
	{"{P}{R}M6Start.VAL", offsetof(struct seqg_vars, motorStart[5]), "motorStart[5]", P_DOUBLE, 1, 96, 0, 0, 0, 0},
	{"{P}{R}M7Start.VAL", offsetof(struct seqg_vars, motorStart[6]), "motorStart[6]", P_DOUBLE, 1, 97, 0, 0, 0, 0},
	{"{P}{R}M8Start.VAL", offsetof(struct seqg_vars, motorStart[7]), "motorStart[7]", P_DOUBLE, 1, 98, 0, 0, 0, 0},
	{"{P}{R}AddAccelDecel.VAL", offsetof(struct seqg_vars, addAccelDecel), "addAccelDecel", P_INT, 1, 99, 0, 1, 0, 0},
	{"{P}{R}M1Move.VAL", offsetof(struct seqg_vars, moveAxis[0]), "moveAxis[0]", P_INT, 1, 100, 0, 1, 0, 0},
	{"{P}{R}M2Move.VAL", offsetof(struct seqg_vars, moveAxis[1]), "moveAxis[1]", P_INT, 1, 101, 0, 1, 0, 0},
	{"{P}{R}M3Move.VAL", offsetof(struct seqg_vars, moveAxis[2]), "moveAxis[2]", P_INT, 1, 102, 0, 1, 0, 0},
	{"{P}{R}M4Move.VAL", offsetof(struct seqg_vars, moveAxis[3]), "moveAxis[3]", P_INT, 1, 103, 0, 1, 0, 0},
	{"{P}{R}M5Move.VAL", offsetof(struct seqg_vars, moveAxis[4]), "moveAxis[4]", P_INT, 1, 104, 0, 1, 0, 0},
	{"{P}{R}M6Move.VAL", offsetof(struct seqg_vars, moveAxis[5]), "moveAxis[5]", P_INT, 1, 105, 0, 1, 0, 0},
	{"{P}{R}M7Move.VAL", offsetof(struct seqg_vars, moveAxis[6]), "moveAxis[6]", P_INT, 1, 106, 0, 1, 0, 0},
	{"{P}{R}M8Move.VAL", offsetof(struct seqg_vars, moveAxis[7]), "moveAxis[7]", P_INT, 1, 107, 0, 1, 0, 0},
	{"{P}{R}M1Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[0]), "motorTrajectory[0]", P_DOUBLE, 1000, 108, 0, 1, 0, 0},
	{"{P}{R}M2Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[1]), "motorTrajectory[1]", P_DOUBLE, 1000, 109, 0, 1, 0, 0},
	{"{P}{R}M3Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[2]), "motorTrajectory[2]", P_DOUBLE, 1000, 110, 0, 1, 0, 0},
	{"{P}{R}M4Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[3]), "motorTrajectory[3]", P_DOUBLE, 1000, 111, 0, 1, 0, 0},
	{"{P}{R}M5Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[4]), "motorTrajectory[4]", P_DOUBLE, 1000, 112, 0, 1, 0, 0},
	{"{P}{R}M6Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[5]), "motorTrajectory[5]", P_DOUBLE, 1000, 113, 0, 1, 0, 0},
	{"{P}{R}M7Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[6]), "motorTrajectory[6]", P_DOUBLE, 1000, 114, 0, 1, 0, 0},
	{"{P}{R}M8Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[7]), "motorTrajectory[7]", P_DOUBLE, 1000, 115, 0, 1, 0, 0},
	{"{P}{R}M1Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[0]), "motorReadbacks[0]", P_DOUBLE, 1000, 116, 0, 0, 0, 0},
	{"{P}{R}M2Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[1]), "motorReadbacks[1]", P_DOUBLE, 1000, 117, 0, 0, 0, 0},
	{"{P}{R}M3Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[2]), "motorReadbacks[2]", P_DOUBLE, 1000, 118, 0, 0, 0, 0},
	{"{P}{R}M4Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[3]), "motorReadbacks[3]", P_DOUBLE, 1000, 119, 0, 0, 0, 0},
	{"{P}{R}M5Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[4]), "motorReadbacks[4]", P_DOUBLE, 1000, 120, 0, 0, 0, 0},
	{"{P}{R}M6Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[5]), "motorReadbacks[5]", P_DOUBLE, 1000, 121, 0, 0, 0, 0},
	{"{P}{R}M7Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[6]), "motorReadbacks[6]", P_DOUBLE, 1000, 122, 0, 0, 0, 0},
	{"{P}{R}M8Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[7]), "motorReadbacks[7]", P_DOUBLE, 1000, 123, 0, 0, 0, 0},
	{"{P}{R}M1Error.VAL", offsetof(struct seqg_vars, motorError[0]), "motorError[0]", P_DOUBLE, 1000, 124, 0, 0, 0, 0},
	{"{P}{R}M2Error.VAL", offsetof(struct seqg_vars, motorError[1]), "motorError[1]", P_DOUBLE, 1000, 125, 0, 0, 0, 0},
	{"{P}{R}M3Error.VAL", offsetof(struct seqg_vars, motorError[2]), "motorError[2]", P_DOUBLE, 1000, 126, 0, 0, 0, 0},
	{"{P}{R}M4Error.VAL", offsetof(struct seqg_vars, motorError[3]), "motorError[3]", P_DOUBLE, 1000, 127, 0, 0, 0, 0},
	{"{P}{R}M5Error.VAL", offsetof(struct seqg_vars, motorError[4]), "motorError[4]", P_DOUBLE, 1000, 128, 0, 0, 0, 0},
	{"{P}{R}M6Error.VAL", offsetof(struct seqg_vars, motorError[5]), "motorError[5]", P_DOUBLE, 1000, 129, 0, 0, 0, 0},
	{"{P}{R}M7Error.VAL", offsetof(struct seqg_vars, motorError[6]), "motorError[6]", P_DOUBLE, 1000, 130, 0, 0, 0, 0},
	{"{P}{R}M8Error.VAL", offsetof(struct seqg_vars, motorError[7]), "motorError[7]", P_DOUBLE, 1000, 131, 0, 0, 0, 0},
	{"{P}{R}M1Current.VAL", offsetof(struct seqg_vars, motorCurrent[0]), "motorCurrent[0]", P_DOUBLE, 1, 132, 0, 0, 0, 0},
	{"{P}{R}M2Current.VAL", offsetof(struct seqg_vars, motorCurrent[1]), "motorCurrent[1]", P_DOUBLE, 1, 133, 0, 0, 0, 0},
	{"{P}{R}M3Current.VAL", offsetof(struct seqg_vars, motorCurrent[2]), "motorCurrent[2]", P_DOUBLE, 1, 134, 0, 0, 0, 0},
	{"{P}{R}M4Current.VAL", offsetof(struct seqg_vars, motorCurrent[3]), "motorCurrent[3]", P_DOUBLE, 1, 135, 0, 0, 0, 0},
	{"{P}{R}M5Current.VAL", offsetof(struct seqg_vars, motorCurrent[4]), "motorCurrent[4]", P_DOUBLE, 1, 136, 0, 0, 0, 0},
	{"{P}{R}M6Current.VAL", offsetof(struct seqg_vars, motorCurrent[5]), "motorCurrent[5]", P_DOUBLE, 1, 137, 0, 0, 0, 0},
	{"{P}{R}M7Current.VAL", offsetof(struct seqg_vars, motorCurrent[6]), "motorCurrent[6]", P_DOUBLE, 1, 138, 0, 0, 0, 0},
	{"{P}{R}M8Current.VAL", offsetof(struct seqg_vars, motorCurrent[7]), "motorCurrent[7]", P_DOUBLE, 1, 139, 0, 0, 0, 0},
	{"{P}{R}M1MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[0]), "motorMDVS[0]", P_DOUBLE, 1, 140, 8, 1, 0, 0},
	{"{P}{R}M2MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[1]), "motorMDVS[1]", P_DOUBLE, 1, 141, 8, 1, 0, 0},
	{"{P}{R}M3MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[2]), "motorMDVS[2]", P_DOUBLE, 1, 142, 8, 1, 0, 0},
	{"{P}{R}M4MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[3]), "motorMDVS[3]", P_DOUBLE, 1, 143, 8, 1, 0, 0},
	{"{P}{R}M5MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[4]), "motorMDVS[4]", P_DOUBLE, 1, 144, 8, 1, 0, 0},
	{"{P}{R}M6MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[5]), "motorMDVS[5]", P_DOUBLE, 1, 145, 8, 1, 0, 0},
	{"{P}{R}M7MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[6]), "motorMDVS[6]", P_DOUBLE, 1, 146, 8, 1, 0, 0},
	{"{P}{R}M8MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[7]), "motorMDVS[7]", P_DOUBLE, 1, 147, 8, 1, 0, 0},
	{"{P}{R}M1MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[0]), "motorMDVA[0]", P_DOUBLE, 1, 148, 0, 0, 0, 0},
	{"{P}{R}M2MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[1]), "motorMDVA[1]", P_DOUBLE, 1, 149, 0, 0, 0, 0},
	{"{P}{R}M3MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[2]), "motorMDVA[2]", P_DOUBLE, 1, 150, 0, 0, 0, 0},
	{"{P}{R}M4MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[3]), "motorMDVA[3]", P_DOUBLE, 1, 151, 0, 0, 0, 0},
	{"{P}{R}M5MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[4]), "motorMDVA[4]", P_DOUBLE, 1, 152, 0, 0, 0, 0},
	{"{P}{R}M6MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[5]), "motorMDVA[5]", P_DOUBLE, 1, 153, 0, 0, 0, 0},
	{"{P}{R}M7MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[6]), "motorMDVA[6]", P_DOUBLE, 1, 154, 0, 0, 0, 0},
	{"{P}{R}M8MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[7]), "motorMDVA[7]", P_DOUBLE, 1, 155, 0, 0, 0, 0},
	{"{P}{R}M1MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[0]), "motorMDVE[0]", P_INT, 1, 156, 0, 0, 0, 0},
	{"{P}{R}M2MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[1]), "motorMDVE[1]", P_INT, 1, 157, 0, 0, 0, 0},
	{"{P}{R}M3MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[2]), "motorMDVE[2]", P_INT, 1, 158, 0, 0, 0, 0},
	{"{P}{R}M4MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[3]), "motorMDVE[3]", P_INT, 1, 159, 0, 0, 0, 0},
	{"{P}{R}M5MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[4]), "motorMDVE[4]", P_INT, 1, 160, 0, 0, 0, 0},
	{"{P}{R}M6MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[5]), "motorMDVE[5]", P_INT, 1, 161, 0, 0, 0, 0},
	{"{P}{R}M7MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[6]), "motorMDVE[6]", P_INT, 1, 162, 0, 0, 0, 0},
	{"{P}{R}M8MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[7]), "motorMDVE[7]", P_INT, 1, 163, 0, 0, 0, 0},
	{"{P}{R}M1MVA.VAL", offsetof(struct seqg_vars, motorMVA[0]), "motorMVA[0]", P_DOUBLE, 1, 164, 0, 0, 0, 0},
	{"{P}{R}M2MVA.VAL", offsetof(struct seqg_vars, motorMVA[1]), "motorMVA[1]", P_DOUBLE, 1, 165, 0, 0, 0, 0},
	{"{P}{R}M3MVA.VAL", offsetof(struct seqg_vars, motorMVA[2]), "motorMVA[2]", P_DOUBLE, 1, 166, 0, 0, 0, 0},
	{"{P}{R}M4MVA.VAL", offsetof(struct seqg_vars, motorMVA[3]), "motorMVA[3]", P_DOUBLE, 1, 167, 0, 0, 0, 0},
	{"{P}{R}M5MVA.VAL", offsetof(struct seqg_vars, motorMVA[4]), "motorMVA[4]", P_DOUBLE, 1, 168, 0, 0, 0, 0},
	{"{P}{R}M6MVA.VAL", offsetof(struct seqg_vars, motorMVA[5]), "motorMVA[5]", P_DOUBLE, 1, 169, 0, 0, 0, 0},
	{"{P}{R}M7MVA.VAL", offsetof(struct seqg_vars, motorMVA[6]), "motorMVA[6]", P_DOUBLE, 1, 170, 0, 0, 0, 0},
	{"{P}{R}M8MVA.VAL", offsetof(struct seqg_vars, motorMVA[7]), "motorMVA[7]", P_DOUBLE, 1, 171, 0, 0, 0, 0},
	{"{P}{R}M1MVE.VAL", offsetof(struct seqg_vars, motorMVE[0]), "motorMVE[0]", P_INT, 1, 172, 0, 0, 0, 0},
	{"{P}{R}M2MVE.VAL", offsetof(struct seqg_vars, motorMVE[1]), "motorMVE[1]", P_INT, 1, 173, 0, 0, 0, 0},
	{"{P}{R}M3MVE.VAL", offsetof(struct seqg_vars, motorMVE[2]), "motorMVE[2]", P_INT, 1, 174, 0, 0, 0, 0},
	{"{P}{R}M4MVE.VAL", offsetof(struct seqg_vars, motorMVE[3]), "motorMVE[3]", P_INT, 1, 175, 0, 0, 0, 0},
	{"{P}{R}M5MVE.VAL", offsetof(struct seqg_vars, motorMVE[4]), "motorMVE[4]", P_INT, 1, 176, 0, 0, 0, 0},
	{"{P}{R}M6MVE.VAL", offsetof(struct seqg_vars, motorMVE[5]), "motorMVE[5]", P_INT, 1, 177, 0, 0, 0, 0},
	{"{P}{R}M7MVE.VAL", offsetof(struct seqg_vars, motorMVE[6]), "motorMVE[6]", P_INT, 1, 178, 0, 0, 0, 0},
	{"{P}{R}M8MVE.VAL", offsetof(struct seqg_vars, motorMVE[7]), "motorMVE[7]", P_INT, 1, 179, 0, 0, 0, 0},
	{"{P}{R}M1MAA.VAL", offsetof(struct seqg_vars, motorMAA[0]), "motorMAA[0]", P_DOUBLE, 1, 180, 0, 0, 0, 0},
	{"{P}{R}M2MAA.VAL", offsetof(struct seqg_vars, motorMAA[1]), "motorMAA[1]", P_DOUBLE, 1, 181, 0, 0, 0, 0},
	{"{P}{R}M3MAA.VAL", offsetof(struct seqg_vars, motorMAA[2]), "motorMAA[2]", P_DOUBLE, 1, 182, 0, 0, 0, 0},
	{"{P}{R}M4MAA.VAL", offsetof(struct seqg_vars, motorMAA[3]), "motorMAA[3]", P_DOUBLE, 1, 183, 0, 0, 0, 0},
	{"{P}{R}M5MAA.VAL", offsetof(struct seqg_vars, motorMAA[4]), "motorMAA[4]", P_DOUBLE, 1, 184, 0, 0, 0, 0},
	{"{P}{R}M6MAA.VAL", offsetof(struct seqg_vars, motorMAA[5]), "motorMAA[5]", P_DOUBLE, 1, 185, 0, 0, 0, 0},
	{"{P}{R}M7MAA.VAL", offsetof(struct seqg_vars, motorMAA[6]), "motorMAA[6]", P_DOUBLE, 1, 186, 0, 0, 0, 0},
	{"{P}{R}M8MAA.VAL", offsetof(struct seqg_vars, motorMAA[7]), "motorMAA[7]", P_DOUBLE, 1, 187, 0, 0, 0, 0},
	{"{P}{R}M1MAE.VAL", offsetof(struct seqg_vars, motorMAE[0]), "motorMAE[0]", P_INT, 1, 188, 0, 0, 0, 0},
	{"{P}{R}M2MAE.VAL", offsetof(struct seqg_vars, motorMAE[1]), "motorMAE[1]", P_INT, 1, 189, 0, 0, 0, 0},
	{"{P}{R}M3MAE.VAL", offsetof(struct seqg_vars, motorMAE[2]), "motorMAE[2]", P_INT, 1, 190, 0, 0, 0, 0},
	{"{P}{R}M4MAE.VAL", offsetof(struct seqg_vars, motorMAE[3]), "motorMAE[3]", P_INT, 1, 191, 0, 0, 0, 0},
	{"{P}{R}M5MAE.VAL", offsetof(struct seqg_vars, motorMAE[4]), "motorMAE[4]", P_INT, 1, 192, 0, 0, 0, 0},
	{"{P}{R}M6MAE.VAL", offsetof(struct seqg_vars, motorMAE[5]), "motorMAE[5]", P_INT, 1, 193, 0, 0, 0, 0},
	{"{P}{R}M7MAE.VAL", offsetof(struct seqg_vars, motorMAE[6]), "motorMAE[6]", P_INT, 1, 194, 0, 0, 0, 0},
	{"{P}{R}M8MAE.VAL", offsetof(struct seqg_vars, motorMAE[7]), "motorMAE[7]", P_INT, 1, 195, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[0]), "epicsMotorPos[0]", P_DOUBLE, 1, 196, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[1]), "epicsMotorPos[1]", P_DOUBLE, 1, 197, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[2]), "epicsMotorPos[2]", P_DOUBLE, 1, 198, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[3]), "epicsMotorPos[3]", P_DOUBLE, 1, 199, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[4]), "epicsMotorPos[4]", P_DOUBLE, 1, 200, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[5]), "epicsMotorPos[5]", P_DOUBLE, 1, 201, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[6]), "epicsMotorPos[6]", P_DOUBLE, 1, 202, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[7]), "epicsMotorPos[7]", P_DOUBLE, 1, 203, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[0]), "epicsMotorDir[0]", P_INT, 1, 204, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[1]), "epicsMotorDir[1]", P_INT, 1, 205, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[2]), "epicsMotorDir[2]", P_INT, 1, 206, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[3]), "epicsMotorDir[3]", P_INT, 1, 207, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[4]), "epicsMotorDir[4]", P_INT, 1, 208, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[5]), "epicsMotorDir[5]", P_INT, 1, 209, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[6]), "epicsMotorDir[6]", P_INT, 1, 210, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[7]), "epicsMotorDir[7]", P_INT, 1, 211, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[0]), "epicsMotorOff[0]", P_DOUBLE, 1, 212, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[1]), "epicsMotorOff[1]", P_DOUBLE, 1, 213, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[2]), "epicsMotorOff[2]", P_DOUBLE, 1, 214, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[3]), "epicsMotorOff[3]", P_DOUBLE, 1, 215, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[4]), "epicsMotorOff[4]", P_DOUBLE, 1, 216, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[5]), "epicsMotorOff[5]", P_DOUBLE, 1, 217, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[6]), "epicsMotorOff[6]", P_DOUBLE, 1, 218, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[7]), "epicsMotorOff[7]", P_DOUBLE, 1, 219, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[0]), "epicsMotorDone[0]", P_DOUBLE, 1, 220, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[1]), "epicsMotorDone[1]", P_DOUBLE, 1, 221, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[2]), "epicsMotorDone[2]", P_DOUBLE, 1, 222, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[3]), "epicsMotorDone[3]", P_DOUBLE, 1, 223, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[4]), "epicsMotorDone[4]", P_DOUBLE, 1, 224, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[5]), "epicsMotorDone[5]", P_DOUBLE, 1, 225, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[6]), "epicsMotorDone[6]", P_DOUBLE, 1, 226, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[7]), "epicsMotorDone[7]", P_DOUBLE, 1, 227, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVELO[0]), "epicsMotorVELO[0]", P_DOUBLE, 1, 228, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVELO[1]), "epicsMotorVELO[1]", P_DOUBLE, 1, 229, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVELO[2]), "epicsMotorVELO[2]", P_DOUBLE, 1, 230, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVELO[3]), "epicsMotorVELO[3]", P_DOUBLE, 1, 231, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVELO[4]), "epicsMotorVELO[4]", P_DOUBLE, 1, 232, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVELO[5]), "epicsMotorVELO[5]", P_DOUBLE, 1, 233, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVELO[6]), "epicsMotorVELO[6]", P_DOUBLE, 1, 234, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVELO[7]), "epicsMotorVELO[7]", P_DOUBLE, 1, 235, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMAX[0]), "epicsMotorVMAX[0]", P_DOUBLE, 1, 236, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMAX[1]), "epicsMotorVMAX[1]", P_DOUBLE, 1, 237, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMAX[2]), "epicsMotorVMAX[2]", P_DOUBLE, 1, 238, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMAX[3]), "epicsMotorVMAX[3]", P_DOUBLE, 1, 239, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMAX[4]), "epicsMotorVMAX[4]", P_DOUBLE, 1, 240, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMAX[5]), "epicsMotorVMAX[5]", P_DOUBLE, 1, 241, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMAX[6]), "epicsMotorVMAX[6]", P_DOUBLE, 1, 242, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMAX[7]), "epicsMotorVMAX[7]", P_DOUBLE, 1, 243, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMIN[0]), "epicsMotorVMIN[0]", P_DOUBLE, 1, 244, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMIN[1]), "epicsMotorVMIN[1]", P_DOUBLE, 1, 245, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMIN[2]), "epicsMotorVMIN[2]", P_DOUBLE, 1, 246, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMIN[3]), "epicsMotorVMIN[3]", P_DOUBLE, 1, 247, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMIN[4]), "epicsMotorVMIN[4]", P_DOUBLE, 1, 248, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMIN[5]), "epicsMotorVMIN[5]", P_DOUBLE, 1, 249, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMIN[6]), "epicsMotorVMIN[6]", P_DOUBLE, 1, 250, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMIN[7]), "epicsMotorVMIN[7]", P_DOUBLE, 1, 251, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorACCL[0]), "epicsMotorACCL[0]", P_DOUBLE, 1, 252, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorACCL[1]), "epicsMotorACCL[1]", P_DOUBLE, 1, 253, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorACCL[2]), "epicsMotorACCL[2]", P_DOUBLE, 1, 254, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorACCL[3]), "epicsMotorACCL[3]", P_DOUBLE, 1, 255, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorACCL[4]), "epicsMotorACCL[4]", P_DOUBLE, 1, 256, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorACCL[5]), "epicsMotorACCL[5]", P_DOUBLE, 1, 257, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorACCL[6]), "epicsMotorACCL[6]", P_DOUBLE, 1, 258, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorACCL[7]), "epicsMotorACCL[7]", P_DOUBLE, 1, 259, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOUT[0]), "epicsMotorOUT[0]", P_STRING, 1, 260, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOUT[1]), "epicsMotorOUT[1]", P_STRING, 1, 261, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOUT[2]), "epicsMotorOUT[2]", P_STRING, 1, 262, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOUT[3]), "epicsMotorOUT[3]", P_STRING, 1, 263, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOUT[4]), "epicsMotorOUT[4]", P_STRING, 1, 264, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOUT[5]), "epicsMotorOUT[5]", P_STRING, 1, 265, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOUT[6]), "epicsMotorOUT[6]", P_STRING, 1, 266, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOUT[7]), "epicsMotorOUT[7]", P_STRING, 1, 267, 0, 0, 0, 0},
};

/* Event masks for state set "maxTrajectoryScan" */
static const seqMask seqg_mask_maxTrajectoryScan_0_init[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_maxTrajectoryScan_0_monitor_inputs[] = {
	0x84a009ce,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_maxTrajectoryScan_0_build[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_maxTrajectoryScan_0_execute[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_maxTrajectoryScan_0_wait_execute[] = {
	0x18000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_maxTrajectoryScan_0_readback[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};

/* State table for state set "maxTrajectoryScan" */
static seqState seqg_states_maxTrajectoryScan[] = {
	{
	/* state name */        "init",
	/* action function */   seqg_action_maxTrajectoryScan_0_init,
	/* event function */    seqg_event_maxTrajectoryScan_0_init,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_maxTrajectoryScan_0_init,
	/* state options */     (0)
	},
	{
	/* state name */        "monitor_inputs",
	/* action function */   seqg_action_maxTrajectoryScan_0_monitor_inputs,
	/* event function */    seqg_event_maxTrajectoryScan_0_monitor_inputs,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_maxTrajectoryScan_0_monitor_inputs,
	/* state options */     (0)
	},
	{
	/* state name */        "build",
	/* action function */   seqg_action_maxTrajectoryScan_0_build,
	/* event function */    seqg_event_maxTrajectoryScan_0_build,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_maxTrajectoryScan_0_build,
	/* state options */     (0)
	},
	{
	/* state name */        "execute",
	/* action function */   seqg_action_maxTrajectoryScan_0_execute,
	/* event function */    seqg_event_maxTrajectoryScan_0_execute,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_maxTrajectoryScan_0_execute,
	/* state options */     (0)
	},
	{
	/* state name */        "wait_execute",
	/* action function */   seqg_action_maxTrajectoryScan_0_wait_execute,
	/* event function */    seqg_event_maxTrajectoryScan_0_wait_execute,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_maxTrajectoryScan_0_wait_execute,
	/* state options */     (0)
	},
	{
	/* state name */        "readback",
	/* action function */   seqg_action_maxTrajectoryScan_0_readback,
	/* event function */    seqg_event_maxTrajectoryScan_0_readback,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_maxTrajectoryScan_0_readback,
	/* state options */     (0)
	},
};

/* Event masks for state set "trajectoryAbort" */
static const seqMask seqg_mask_trajectoryAbort_1_monitorAbort[] = {
	0x40000020,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};

/* State table for state set "trajectoryAbort" */
static seqState seqg_states_trajectoryAbort[] = {
	{
	/* state name */        "monitorAbort",
	/* action function */   seqg_action_trajectoryAbort_1_monitorAbort,
	/* event function */    seqg_event_trajectoryAbort_1_monitorAbort,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_trajectoryAbort_1_monitorAbort,
	/* state options */     (0)
	},
};

/* State set table */
static seqSS seqg_statesets[] = {
	{
	/* state set name */    "maxTrajectoryScan",
	/* states */            seqg_states_maxTrajectoryScan,
	/* number of states */  6
	},

	{
	/* state set name */    "trajectoryAbort",
	/* states */            seqg_states_trajectoryAbort,
	/* number of states */  1
	},
};

/* Program table (global) */
seqProgram MAX_trajectoryScan = {
	/* magic number */      2002005,
	/* program name */      "MAX_trajectoryScan",
	/* channels */          seqg_chans,
	/* num. channels */     259,
	/* state sets */        seqg_statesets,
	/* num. state sets */   2,
	/* user var size */     sizeof(struct seqg_vars),
	/* param */             "P=13IDC:,R=traj1,M1=M1,M2=M2,M3=M3,M4=M4,M5=M5,M6=M6,M7=M7,M8=M8,PORT=serial1",
	/* num. event flags */  8,
	/* encoded options */   (0 | OPT_CONN | OPT_NEWEF | OPT_REENT),
	/* init func */         seqg_init,
	/* entry func */        0,
	/* exit func */         0,
	/* num. queues */       0
};
# line 845 "../MAX_trajectoryScan.st"



static int writeOnly(SS_ID ssId, struct UserVar *pVar, char *command)
{
 asynStatus status=0;
 int debug_out=0;
# 864 "../MAX_trajectoryScan.st"
 if (pVar->simMode==0) {
  status = (asynStatus) MAXV_send_mess(pVar->cardNumber, command, (char *) NULL);
 }

 if (pVar->execState==2)
  debug_out = (pVar->debugLevel >= 7);
 else
  debug_out = (pVar->debugLevel >= 2);
 if (debug_out) printf("    writeOnly:command='%s'\n", command);
 return(status);
}





static int writeRead(SS_ID ssId, struct UserVar *pVar, char *command, char *reply)
{
 asynStatus status;
 char buffer[100];





 strncpy(buffer, command, 100 -3);
# 902 "../MAX_trajectoryScan.st"
 status = MAXV_send_recv_mess(pVar->cardNumber, command, (char *) NULL, reply, 1);

 if (pVar->debugLevel >= 2) {
  printf("    writeRead:command='%s', reply='%s'\n", buffer, reply);
 }
 return(status);
}



static int getMotorPositions(SS_ID ssId, struct UserVar *pVar, double *pos, epicsInt32 *rawP, double *dt)
{
    int j;
    int dir;
 epicsTimeStamp currtime;

 MAXV_getPositions(pVar->cardNumber, rawP, pVar->numAxes);

 epicsTimeGetCurrent(&currtime);
 *dt = epicsTimeDiffInSeconds(&currtime, &eStartTime);
    for (j=0; j<pVar->numAxes; j++) {
        if (pVar->epicsMotorDir[j] == 0) dir=1; else dir=-1;
  pos[j] = rawToUser(rawP[j], pVar->epicsMotorOff[j], dir, pVar->epicsMotorMres[j]);
    }

 if (pVar->debugLevel >= 1) {
  printf("\ndt=%6.3f, p=%7d", *dt, rawP[0]);
 }
 epicsThreadSleep((1/60.));
 return(0);
}



static int getMotorMoving(SS_ID ssId, struct UserVar *pVar, int movingMask)
{
 int i, j, mask, moving;

 for (j=0; j<2; j++) {
  mask = 1;
  moving = 0;

  writeRead(ssId, pVar, "QI", pVar->stringIn);






  for (i=1; i<37; i+=5, mask<<=1) {
   if (pVar->stringIn[i] == 'N') moving |= mask;
  }

  pVar->stringIn[40] = '\0';
  if (pVar->debugLevel >= 7) {
   printf("\ngetMotorMoving: reply = '%s', moving = %2x", pVar->stringIn, moving);
  }
  if (moving & movingMask) return(1);
 }
 return(0);
}


static int getStarted(SS_ID ssId, struct UserVar *pVar) {
 int i, bits, mask;
 char c;

 writeRead(ssId, pVar, "BX", pVar->stringIn);
 for (i=0, bits=0; i<4; i++) {
  bits <<= 4;
  c = pVar->stringIn[i];

  if (isdigit((int)c)) {
   c = c - '0';
  } else if (isxdigit((int)c)) {
   if (islower((int)c)) {
    c = (c - 'a') + 10;
   } else {
    c = (c - 'A') + 10;
   }
  }
  bits |= c;
 }
 mask = 1 << (pVar->inBitNum);
 if (pVar->debugLevel >= 5)
  printf("\ngetStarted: reply='%s', bits=0x%x, mask=0x%x", pVar->stringIn, bits, mask);
 return (bits & mask);
}




static int getEpicsMotorMoving(SS_ID ssId, struct UserVar *pVar)
{
 int j;
 int result=0, mask=0x01;

 for (j=0; j<pVar->numAxes; j++) {
  seq_pvGet(ssId, pVar->epicsMotorDoneIndex[j], 0);
  if (pVar->epicsMotorDone[j] == 0) result |= mask;
  mask = mask << 1;
 }
 return(result);
}



static int waitEpicsMotors(SS_ID ssId, struct UserVar *pVar)
{
 int j;



 while (getEpicsMotorMoving(ssId, pVar)) {

  for (j=0; j<pVar->numAxes; j++) {
   pVar->motorCurrent[j] = pVar->epicsMotorPos[j];
   seq_pvPut(ssId, pVar->motorCurrentIndex[j], 0);
  }
  if (pVar->debugLevel >= 1) printf("waitEpicsMotors: m1=%f\n", pVar->epicsMotorPos[0]);
  epicsThreadSleep((1/5.));
 }
 for (j=0; j<pVar->numAxes; j++) {
  pVar->motorCurrent[j] = pVar->epicsMotorPos[j];
  seq_pvPut(ssId, pVar->motorCurrentIndex[j], 0);
 }
 return(0);
}




volatile int MAXv_traj_quantized = 1;
volatile int MAXv_traj_vmin = 0;

double y2[1002], v_out[1002], a_out[1002], calcMotorTrajectory[1002];
static int buildTrajectory(SS_ID ssId, struct UserVar *pVar, double *realTimeTrajectory,
 double *motorTrajectory, int epicsMotorDir, int moveMode, int npoints, double motorOffset,
 double motorResolution, double motorVmin, int *position, int *velocity, int *acceleration,
 double *accelDist, double *decelDist)
{

 double dp, dt, v_ideal, v_lin, accel_p, accel_v, thisTime;
 double x0;
 int i, dir;

 *accelDist = 0;
 *decelDist = 0;

 if (pVar->addAccelDecel) {
  dp = motorTrajectory[1] - motorTrajectory[0];
  dt = realTimeTrajectory[2] - realTimeTrajectory[1];
  *accelDist = (dp/dt * pVar->accel) / 2;

  dp = motorTrajectory[npoints-1] - motorTrajectory[npoints-2];
  dt = realTimeTrajectory[npoints] - realTimeTrajectory[npoints-1];

  *decelDist = (dp/dt * pVar->accel) / 2;



  for (i=npoints; i>0; i--) {
   motorTrajectory[i] = motorTrajectory[i-1];
  }
  motorTrajectory[0] = motorTrajectory[1] - *accelDist;
  motorTrajectory[npoints+1] = motorTrajectory[npoints] + *decelDist;
  npoints += 2;
 }

 calcMotorTrajectory[0] = motorTrajectory[0];
 v_out[0] = 0;
 if (pVar->debugLevel >= 7) {
  printf("\n###:%8s %8s %7s %8s %8s %8s %8s %8s\n",
   "pos", "calcPos", "dp", "t", "v_ideal", "accel_p", "accel_v", "accel_s");
 }
 for (i=1; i<npoints; i++) {

  dp = motorTrajectory[i]-calcMotorTrajectory[i-1];
  dt = realTimeTrajectory[i]-realTimeTrajectory[i-1];

  accel_p = 2*(dp - v_out[i-1]*dt)/(dt*dt);
  if (i < npoints-1) {


   v_lin = (motorTrajectory[i+1]-motorTrajectory[i-1])/(realTimeTrajectory[i+1]-realTimeTrajectory[i-1]);
   v_ideal = v_lin;


   accel_v = (v_ideal - v_out[i-1])/dt;


   a_out[i-1] = (accel_p + accel_v)/2;

  } else {
   v_ideal = 0.;
   accel_v = (v_ideal - v_out[i-1])/dt;
   a_out[i-1] = accel_v;
  }
  if (pVar->debugLevel >= 7) {
   printf("%3d:%8.2f %8.2f %7.2f %8.3f %8.3f %8.3f %8.3f %8.3f\n",
    i, motorTrajectory[i-1], calcMotorTrajectory[i-1], dp, realTimeTrajectory[i-1], v_ideal, accel_p, accel_v, (y2[i-1]+y2[i])/2);
  }
  if (MAXv_traj_quantized) {

   a_out[i-1] = motorResolution * (int)((a_out[i-1]/motorResolution)>0 ? (a_out[i-1]/motorResolution)+0.5 : (a_out[i-1]/motorResolution)-0.5);
  }
  v_out[i] = v_out[i-1] + a_out[i-1]*dt;
  if (MAXv_traj_quantized) {

   v_out[i] = motorResolution * (int)((v_out[i]/motorResolution)>0 ? (v_out[i]/motorResolution)+0.5 : (v_out[i]/motorResolution)-0.5);
  }
  if (MAXv_traj_vmin) {

   if (v_out[i] < motorVmin) {
    double vsav = v_out[i];
    v_out[i] = (v_out[i] < motorVmin/2) ? 0. : motorVmin;
    printf("v < vmin; %f corrected to %f\n", vsav, v_out[i]);
   }
  }
  calcMotorTrajectory[i] = calcMotorTrajectory[i-1] + v_out[i-1]*dt + .5 * a_out[i-1]*dt*dt;
 }
 a_out[npoints-1] = a_out[npoints-2];

 if (pVar->debugLevel >= 7) {
  printf("buildTrajectory:\n");
  printf("%10s %10s %10s %10s %10s\n", "realTime", "motorTraj", "calcTraj", "v_out", "a_out");
  for (i=0; i<npoints; i++) {
   printf("%10.2f %10.5f %10.5f %10.5f %10.5f\n",
    realTimeTrajectory[i], motorTrajectory[i], calcMotorTrajectory[i], v_out[i], a_out[i]);
  }
 }


 dir = (epicsMotorDir == 0) ? 1 : -1;
 v_out[0] = 0;
 if (pVar->debugLevel >= 1) {
  printf("motor resolution %f\n", motorResolution);
  printf("%10s %10s %10s %10s %10s\n", "time", "position", "calcpos", "velocity", "acceleration");
 }
 for (i=0; i<npoints; i++) {
  if (i < npoints-1) {
   thisTime = realTimeTrajectory[i+1];
   dt = realTimeTrajectory[i+1] - realTimeTrajectory[i];
   position[i] = userToRaw(calcMotorTrajectory[i+1], motorOffset, dir, motorResolution);
   velocity[i] = (int)((dir*v_out[i+1]/motorResolution)>0 ? (dir*v_out[i+1]/motorResolution)+0.5 : (dir*v_out[i+1]/motorResolution)-0.5);
   acceleration[i] = (int)((dir*a_out[i]/motorResolution)>0 ? (dir*a_out[i]/motorResolution)+0.5 : (dir*a_out[i]/motorResolution)-0.5);
  } else {
   thisTime = realTimeTrajectory[i];
   dt = realTimeTrajectory[i] - realTimeTrajectory[i-1];
   position[i] = userToRaw(calcMotorTrajectory[i], motorOffset, dir, motorResolution);
   velocity[i] = 0;
   acceleration[i] = (int)((dir*a_out[i]/motorResolution)>0 ? (dir*a_out[i]/motorResolution)+0.5 : (dir*a_out[i]/motorResolution)-0.5);
  }
  if (i>0) {
   x0 = position[i-1] + velocity[i-1]*dt + .5 * acceleration[i]*dt*dt;
  } else {
   x0 = .5 * acceleration[i]*dt*dt;
  }
  if (pVar->debugLevel >= 1) printf("%10.2f %10d %10d %10d %10d\n", thisTime, position[i], (int)((x0)>0 ? (x0)+0.5 : (x0)-0.5), velocity[i], acceleration[i]);
 }

 if (pVar->addAccelDecel) {

  npoints -= 2;
  for (i=0; i<npoints; i++) {
   motorTrajectory[i] = motorTrajectory[i+1];
  }
  motorTrajectory[npoints] = 0;
 }

 return(0);
}

static int userToRaw(double user, double off, int dir, double res) {
 return ((int)(((user-off)*dir/res)>0 ? ((user-off)*dir/res)+0.5 : ((user-off)*dir/res)-0.5));
}

static double rawToUser(int raw, double off, int dir, double res) {

 return (raw*res*dir+off);
}


static int loadTrajectory(SS_ID ssId, struct UserVar *pVar, int simMode) {
 int i, j, k, n, currUpdateRate;
 int onMask=0, offMask=0, outMask=0;
 int segment_accel, segment_decel, segment_v_start, segment_v_end;
 char absRel;
 char stringOut[100];
 int firstTask;
 double addForRelMove;
 int dir;

 int p1=0, v1=0, do_split;
 double p1_double, t_v0;
 int pulsesEnabled = 0;
 int startPulses, endPulses, npoints;

 startPulses = pVar->startPulses;
 endPulses = pVar->endPulses;
 npoints = pVar->npoints;

 if (pVar->addAccelDecel) {


  startPulses++;
  endPulses++;
  npoints+=2;
 }

 sprintf(stringOut, "AM;");
 writeOnly(ssId, pVar, stringOut);


 if ((pVar->outBitNum >= 0) && (pVar->outBitNum <= 15)) {
  onMask = 1 << (pVar->outBitNum);
  offMask = 0;
  outMask = 1 << (pVar->outBitNum);

  sprintf(stringOut, "BD%04x;", outMask);
  writeOnly(ssId, pVar, stringOut);
  sprintf(stringOut, "BL%d;", pVar->outBitNum);
  writeOnly(ssId, pVar, stringOut);
 }

 if ((pVar->inBitNum >= 0) && (pVar->inBitNum <= 15)) {
  sprintf(stringOut, "IO%d,0;", pVar->inBitNum);
  writeOnly(ssId, pVar, stringOut);
 }


 absRel = 'A';



 sprintf(stringOut, "AM; SI");
 for (j=0; j<8; j++) {
  if (pVar->moveAxis[j]) strcat(stringOut, "1");
  if (j<(8 -1)) strcat(stringOut, ",");
 }
 strcat(stringOut, ";");
 writeOnly(ssId, pVar, stringOut);


 sprintf(stringOut, "AX; #UR?;");
 writeRead(ssId, pVar, stringOut, stringOut);
 if (pVar->debugLevel > 0) printf("Update rate ='%s'\n", stringOut);
 currUpdateRate = atol(stringOut);

 epicsTimeGetCurrent(&eStartTime);
 getMotorPositions(ssId, pVar, pVar->motorCurrent, pVar->motorCurrentRaw, &(pVar->dtime));
# 1275 "../MAX_trajectoryScan.st"
 epicsTimeGetCurrent(&eStartTime);
 getMotorPositions(ssId, pVar, pVar->motorCurrent, pVar->motorCurrentRaw, &(pVar->dtime));

 for (j=0, firstTask=1; j<8; j++) {
  if (pVar->moveAxis[j]) {
   if (pVar->epicsMotorDir[j] == 0) dir=1; else dir=-1;

   addForRelMove = pVar->motorCurrent[j]*dir / pVar->epicsMotorMres[j];
   if (pVar->debugLevel > 2) printf("addForRelMove=%f\n", addForRelMove);


   if (firstTask && ((pVar->outBitNum >= 0) && (pVar->outBitNum <= 15))) {

    sprintf(stringOut, "AM; VIO[%d]%04x,%04x,%04x;", j+1, onMask, offMask, outMask);
    writeOnly(ssId, pVar, stringOut);
    pulsesEnabled = 1;
   } else {

    sprintf(stringOut, "AM; VIO[%d]0,0,0;", j+1);
    writeOnly(ssId, pVar, stringOut);
    pulsesEnabled = 0;
   }

   sprintf(stringOut, "AM; VID[%d]1;", j+1);
   writeOnly(ssId, pVar, stringOut);


   sprintf(stringOut, "AM; VH[%d]0;", j+1);
   writeOnly(ssId, pVar, stringOut);




   if ((pVar->inBitNum >= 0) && (pVar->inBitNum <= 15)) {

    sprintf(stringOut, "A%c; SW%d;", axis_name[j], pVar->inBitNum);
    writeOnly(ssId, pVar, stringOut);
   }

   for (i=0; i<npoints; i++) {
    if (pVar->acceleration[j][i] > 0) {
     segment_accel = pVar->acceleration[j][i];
     segment_decel = pVar->acceleration[j][i];
    } else {
     segment_accel = -(pVar->acceleration[j][i]);
     segment_decel = -(pVar->acceleration[j][i]);
    }
    if (segment_accel < 1) segment_accel = 1;
    if (segment_accel > 8000000) segment_accel = 8000000;
    if (segment_decel < 1) segment_decel = 1;
    if (segment_decel > 8000000) segment_decel = 8000000;

    segment_v_start = (i==0) ? pVar->velocity[j][0] : pVar->velocity[j][i-1];
    segment_v_end = pVar->velocity[j][i];


    do_split = (segment_v_start>0) != (segment_v_end>0);
    do_split = do_split && (abs(segment_v_start)>2) && (abs(segment_v_end)>2);
    do_split = do_split && (i>0);
    if (do_split) {

     t_v0 = (double)(-segment_v_start) / pVar->acceleration[j][i];

     if ((t_v0 < .005) || (((pVar->realTimeTrajectoryAccelDecel[i] - pVar->realTimeTrajectoryAccelDecel[i-1]) - t_v0) < .005)) {

      if (pVar->debugLevel > 0) printf("declined to split segment at t=%f\n", t_v0);
      do_split = 0;
     } else {
      v1 = 0;
      p1_double = pVar->position[j][i-1] + segment_v_start*t_v0 +
       0.5 * pVar->acceleration[j][i]*t_v0*t_v0;
      p1 = (int)((p1_double)>0 ? (p1_double)+0.5 : (p1_double)-0.5);
      if (pVar->debugLevel > 0) printf("split segment at t=%f, x=%d\n", t_v0, p1);
     }
    }

    segment_v_start = abs(segment_v_start);
    segment_v_end = abs(segment_v_end);

    if (segment_v_start < 1) segment_v_start = 1;
    if (segment_v_start > 4194303) segment_v_start = 4194303;
    if (segment_v_end < 0) segment_v_end = 0;
    if (segment_v_end > 4194303) segment_v_end = 4194303;

    if (pVar->moveMode != 1) {
     p1_double = pVar->position[j][i];
     pVar->position[j][i] = (int)((p1_double + addForRelMove)>0 ? (p1_double + addForRelMove)+0.5 : (p1_double + addForRelMove)-0.5);
    }

    if (do_split) {
     if (firstTask && ((pVar->outBitNum >= 0) && (pVar->outBitNum <= 15))) {

      if (pulsesEnabled) {
       sprintf(stringOut, "AM; VIO[%d]0,0,0;", j+1);
       writeOnly(ssId, pVar, stringOut);
       pulsesEnabled = 0;
      }
     }

     n = sprintf(stringOut, "AM; VA[%d]%d;", j+1, segment_accel);
     n += sprintf(&stringOut[n], "VV[%d]%d,%d;", j+1, segment_v_start, v1);
     n += sprintf(&stringOut[n], "VP[%d]%c", j+1, absRel);
     for (k=0; k<j; k++) {strcat(stringOut, ","); n++;}
     n += sprintf(&(stringOut[n]), "%d", p1);
     for (k=j+1; k<8; k++) {strcat(stringOut, ","); n++;}
     strcat(stringOut, ";");
     writeOnly(ssId, pVar, stringOut);

     if (firstTask && ((pVar->outBitNum >= 0) && (pVar->outBitNum <= 15))) {

      if (!pulsesEnabled) {
       sprintf(stringOut, "AM; VIO[%d]%04x,%04x,%04x;", j+1, onMask, offMask, outMask);
       writeOnly(ssId, pVar, stringOut);
       pulsesEnabled = 1;
      }
     }
     n = sprintf(stringOut, "AM; VA[%d]%d;", j+1, segment_accel);
     if (i < (pVar->npoints)-1) {
      n += sprintf(&stringOut[n], "VV[%d]%d;", j+1, segment_v_end);
     } else {
      n += sprintf(&stringOut[n], "VV[%d]%d,%d;", j+1, 1, segment_v_end);
     }
     n += sprintf(&stringOut[n], "VP[%d]%c", j+1, absRel);
     for (k=0; k<j; k++) {strcat(stringOut, ","); n++;}
     n += sprintf(&(stringOut[n]), "%d", pVar->position[j][i]);
     for (k=j+1; k<8; k++) {strcat(stringOut, ","); n++;}
     strcat(stringOut, ";");
     writeOnly(ssId, pVar, stringOut);
    } else {

     if (firstTask && ((pVar->outBitNum >= 0) && (pVar->outBitNum <= 15))) {
      if (i >= startPulses && i <= endPulses) {

       if (!pulsesEnabled) {
        sprintf(stringOut, "AM; VIO[%d]%04x,%04x,%04x;", j+1, onMask, offMask, outMask);
        writeOnly(ssId, pVar, stringOut);
        pulsesEnabled = 1;
       }
      } else {
       if (pulsesEnabled) {

        sprintf(stringOut, "AM; VIO[%d]0,0,0;", j+1);
        writeOnly(ssId, pVar, stringOut);
        pulsesEnabled = 0;
       }
      }
     }

     n = sprintf(stringOut, "AM; VA[%d]%d;", j+1, segment_accel);
     if (i < (pVar->npoints)-1) {
      n += sprintf(&stringOut[n], "VV[%d]%d;", j+1, segment_v_end);
     } else {
      n += sprintf(&stringOut[n], "VV[%d]%d,%d;", j+1, segment_v_start, segment_v_end);
     }
     n += sprintf(&stringOut[n], "VP[%d]%c", j+1, absRel);
     for (k=0; k<j; k++) {strcat(stringOut, ","); n++;}
     n += sprintf(&(stringOut[n]), "%d", pVar->position[j][i]);
     for (k=j+1; k<8; k++) {strcat(stringOut, ","); n++;}
     strcat(stringOut, ";");
     writeOnly(ssId, pVar, stringOut);
    }
   }
   sprintf(stringOut, "AM; VE[%d];", j+1);
   writeOnly(ssId, pVar, stringOut);
   firstTask = 0;
  }
 }
 return(0);
}



/* Register sequencer commands and program */
#include "epicsExport.h"
static void MAX_trajectoryScanRegistrar (void) {
    seqRegisterSequencerCommands();
    seqRegisterSequencerProgram (&MAX_trajectoryScan);
}
epicsExportRegistrar(MAX_trajectoryScanRegistrar);
