/* C code for program XPS_trajectoryScan, generated by snc from ../XPS_trajectoryScan.st */
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>

#include "seq_snc.h"
# line 19 "../XPS_trajectoryScan.st"
#include <string.h>
# line 20 "../XPS_trajectoryScan.st"
#include <stdio.h>
# line 21 "../XPS_trajectoryScan.st"
#include <math.h>
# line 22 "../XPS_trajectoryScan.st"
#include <stdarg.h>
# line 23 "../XPS_trajectoryScan.st"
#define epicsExportSharedSymbols
# line 24 "../XPS_trajectoryScan.st"
#include <shareLib.h>
# line 25 "../XPS_trajectoryScan.st"
#include "XPS_C8_drivers.h"
# line 26 "../XPS_trajectoryScan.st"
#include "XPS_C8_errors.h"
# line 27 "../XPS_trajectoryScan.st"
#include "Socket.h"
# line 28 "../XPS_trajectoryScan.st"
#include "xps_ftp.h"
# line 243 "../trajectoryScan.h"
static const EF_ID buildMon = 1;
# line 244 "../trajectoryScan.h"
static const EF_ID executeMon = 2;
# line 245 "../trajectoryScan.h"
static const EF_ID execStateMon = 3;
# line 246 "../trajectoryScan.h"
static const EF_ID abortMon = 4;
# line 247 "../trajectoryScan.h"
static const EF_ID readbackMon = 5;
# line 248 "../trajectoryScan.h"
static const EF_ID nelementsMon = 6;
# line 249 "../trajectoryScan.h"
static const EF_ID motorMDVSMon = 7;
# line 130 "../XPS_trajectoryScan.st"
static int getMotorPositions(SS_ID ssId, struct UserVar *pVar, double *pos);
# line 131 "../XPS_trajectoryScan.st"
static int getMotorMoving(SS_ID ssId, struct UserVar *pVar);
# line 132 "../XPS_trajectoryScan.st"
static int waitMotors(SS_ID ssId, struct UserVar *pVar);
# line 133 "../XPS_trajectoryScan.st"
static int getEpicsMotorMoving(SS_ID ssId, struct UserVar *pVar);
# line 134 "../XPS_trajectoryScan.st"
static int waitEpicsMotors(SS_ID ssId, struct UserVar *pVar);
# line 136 "../XPS_trajectoryScan.st"
static int getSocket(SS_ID ssId, struct UserVar *pVar, double timeout);
# line 137 "../XPS_trajectoryScan.st"
static void trajectoryExecute(SS_ID ssId, struct UserVar *pVar);
# line 138 "../XPS_trajectoryScan.st"
static void buildAndVerify(SS_ID ssId, struct UserVar *pVar);
# line 139 "../XPS_trajectoryScan.st"
static int currentElement(SS_ID ssId, struct UserVar *pVar);
# line 140 "../XPS_trajectoryScan.st"
static int getGroupStatus(SS_ID ssId, struct UserVar *pVar);
# line 141 "../XPS_trajectoryScan.st"
static void readGathering(SS_ID ssId, struct UserVar *pVar);
# line 142 "../XPS_trajectoryScan.st"
static int trajectoryAbort(SS_ID ssId, struct UserVar *pVar);
# line 143 "../XPS_trajectoryScan.st"
static void printMessage(const char *pformat, ...);

/* Variable declarations */
struct seqg_vars {
# line 40 "../trajectoryScan.h"
	int debugLevel;
# line 42 "../trajectoryScan.h"
	int numAxes;
# line 44 "../trajectoryScan.h"
	int nelements;
# line 46 "../trajectoryScan.h"
	int npulses;
# line 48 "../trajectoryScan.h"
	int startPulses;
# line 50 "../trajectoryScan.h"
	int endPulses;
# line 52 "../trajectoryScan.h"
	int nactual;
# line 53 "../trajectoryScan.h"
	int moveMode;
# line 55 "../trajectoryScan.h"
	double time_PV;
# line 57 "../trajectoryScan.h"
	double timeScale;
# line 59 "../trajectoryScan.h"
	int timeMode;
# line 61 "../trajectoryScan.h"
	double accel;
# line 63 "../trajectoryScan.h"
	int build;
# line 65 "../trajectoryScan.h"
	int buildState;
# line 66 "../trajectoryScan.h"
	int buildStatus;
# line 67 "../trajectoryScan.h"
	string buildMessage;
# line 68 "../trajectoryScan.h"
	int simMode;
# line 70 "../trajectoryScan.h"
	int execute;
# line 72 "../trajectoryScan.h"
	int execState;
# line 74 "../trajectoryScan.h"
	int execStatus;
# line 75 "../trajectoryScan.h"
	string execMessage;
# line 76 "../trajectoryScan.h"
	int abort;
# line 78 "../trajectoryScan.h"
	int readback;
# line 80 "../trajectoryScan.h"
	int readState;
# line 81 "../trajectoryScan.h"
	int readStatus;
# line 82 "../trajectoryScan.h"
	string readMessage;
# line 83 "../trajectoryScan.h"
	double timeTrajectory[2000];
# line 86 "../trajectoryScan.h"
	string trajectoryFile;
# line 89 "../trajectoryScan.h"
	int moveAxis[8];
# line 101 "../trajectoryScan.h"
	double motorTrajectory[8][2000];
# line 113 "../trajectoryScan.h"
	double motorReadbacks[8][2000];
# line 124 "../trajectoryScan.h"
	double motorError[8][2000];
# line 135 "../trajectoryScan.h"
	double motorCurrent[8];
# line 146 "../trajectoryScan.h"
	double motorMDVS[8];
# line 158 "../trajectoryScan.h"
	double motorMDVA[8];
# line 169 "../trajectoryScan.h"
	int motorMDVE[8];
# line 180 "../trajectoryScan.h"
	double motorMVA[8];
# line 191 "../trajectoryScan.h"
	int motorMVE[8];
# line 202 "../trajectoryScan.h"
	double motorMAA[8];
# line 213 "../trajectoryScan.h"
	int motorMAE[8];
# line 226 "../trajectoryScan.h"
	double epicsMotorPos[8];
# line 230 "../trajectoryScan.h"
	double epicsMotorDir[8];
# line 234 "../trajectoryScan.h"
	double epicsMotorOff[8];
# line 238 "../trajectoryScan.h"
	double epicsMotorDone[8];
# line 80 "../XPS_trajectoryScan.st"
	int status;
# line 81 "../XPS_trajectoryScan.st"
	int i;
# line 82 "../XPS_trajectoryScan.st"
	int j;
# line 83 "../XPS_trajectoryScan.st"
	int k;
# line 84 "../XPS_trajectoryScan.st"
	int anyMoving;
# line 85 "../XPS_trajectoryScan.st"
	int ncomplete;
# line 86 "../XPS_trajectoryScan.st"
	int nextra;
# line 87 "../XPS_trajectoryScan.st"
	int npoints;
# line 88 "../XPS_trajectoryScan.st"
	int dir;
# line 89 "../XPS_trajectoryScan.st"
	int pollSocket;
# line 90 "../XPS_trajectoryScan.st"
	int driveSocket;
# line 91 "../XPS_trajectoryScan.st"
	int abortSocket;
# line 92 "../XPS_trajectoryScan.st"
	int positionSocket;
# line 93 "../XPS_trajectoryScan.st"
	int xpsStatus;
# line 94 "../XPS_trajectoryScan.st"
	int count;
# line 95 "../XPS_trajectoryScan.st"
	double dtime;
# line 96 "../XPS_trajectoryScan.st"
	double posActual;
# line 97 "../XPS_trajectoryScan.st"
	double posTheory;
# line 98 "../XPS_trajectoryScan.st"
	double expectedTime;
# line 99 "../XPS_trajectoryScan.st"
	double initialPos[8];
# line 100 "../XPS_trajectoryScan.st"
	double trajVel;
# line 101 "../XPS_trajectoryScan.st"
	double preDistance[8];
# line 102 "../XPS_trajectoryScan.st"
	double postDistance[8];
# line 103 "../XPS_trajectoryScan.st"
	double motorLowLimit[8];
# line 104 "../XPS_trajectoryScan.st"
	double motorHighLimit[8];
# line 105 "../XPS_trajectoryScan.st"
	double motorMinPos[8];
# line 106 "../XPS_trajectoryScan.st"
	double motorMaxPos[8];
# line 107 "../XPS_trajectoryScan.st"
	double pulseTime;
# line 108 "../XPS_trajectoryScan.st"
	double pulsePeriod;
# line 109 "../XPS_trajectoryScan.st"
	char groupName[100];
# line 110 "../XPS_trajectoryScan.st"
	char xpsAddress[100];
# line 111 "../XPS_trajectoryScan.st"
	char *axisName[8];
# line 112 "../XPS_trajectoryScan.st"
	char macroBuf[100];
# line 113 "../XPS_trajectoryScan.st"
	char motorName[100];
# line 114 "../XPS_trajectoryScan.st"
	char userName[100];
# line 115 "../XPS_trajectoryScan.st"
	char password[100];
# line 116 "../XPS_trajectoryScan.st"
	int xpsPort;
# line 122 "../XPS_trajectoryScan.st"
	int motorCurrentIndex[8];
# line 123 "../XPS_trajectoryScan.st"
	int epicsMotorDoneIndex[8];
# line 127 "../XPS_trajectoryScan.st"
	unsigned long startTime;
};


/* Function declarations */

#define seqg_var (*(struct seqg_vars *const *)seqg_env)

/* Program init func */
static void seqg_init(PROG_ID seqg_env)
{
}

/****** Code for state "init" in state set "xpsTrajectoryScan" ******/

/* Event function for state "init" in state set "xpsTrajectoryScan" */
static seqBool seqg_event_xpsTrajectoryScan_0_init(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "init" in state set "xpsTrajectoryScan" */
static void seqg_action_xpsTrajectoryScan_0_init(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 152 "../XPS_trajectoryScan.st"
			strcpy(seqg_var->groupName, seq_macValueGet(seqg_env, "GROUP"));
# line 153 "../XPS_trajectoryScan.st"
			strcpy(seqg_var->xpsAddress, seq_macValueGet(seqg_env, "IPADDR"));
# line 154 "../XPS_trajectoryScan.st"
			strcpy(seqg_var->userName, seq_macValueGet(seqg_env, "USERNAME"));
# line 155 "../XPS_trajectoryScan.st"
			strcpy(seqg_var->password, seq_macValueGet(seqg_env, "PASSWORD"));
# line 156 "../XPS_trajectoryScan.st"
			seqg_var->xpsPort = atoi(seq_macValueGet(seqg_env, "PORT"));
# line 157 "../XPS_trajectoryScan.st"
			if (seqg_var->debugLevel > 0)
			{
# line 160 "../XPS_trajectoryScan.st"
				printf("XPS_trajectoryScan: ss xpsTrajectoryScan: state init: xpsAddress=%s groupName=%s\n", seqg_var->xpsAddress, seqg_var->groupName);
			}
# line 162 "../XPS_trajectoryScan.st"
			for (seqg_var->i = 0; seqg_var->i < seqg_var->numAxes; seqg_var->i++)
			{
# line 163 "../XPS_trajectoryScan.st"
				seqg_var->axisName[seqg_var->i] = malloc(100);
# line 164 "../XPS_trajectoryScan.st"
				sprintf(seqg_var->macroBuf, "P%d", seqg_var->i + 1);
# line 165 "../XPS_trajectoryScan.st"
				sprintf(seqg_var->axisName[seqg_var->i], "%s.%s", seqg_var->groupName, seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 166 "../XPS_trajectoryScan.st"
				sprintf(seqg_var->macroBuf, "M%d", seqg_var->i + 1);
# line 167 "../XPS_trajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.VAL", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 168 "../XPS_trajectoryScan.st"
				seq_pvAssign(seqg_env, 124/*epicsMotorPos*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 169 "../XPS_trajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.DIR", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 170 "../XPS_trajectoryScan.st"
				seq_pvAssign(seqg_env, 132/*epicsMotorDir*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 171 "../XPS_trajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.OFF", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 172 "../XPS_trajectoryScan.st"
				seq_pvAssign(seqg_env, 140/*epicsMotorOff*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 173 "../XPS_trajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.DMOV", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 174 "../XPS_trajectoryScan.st"
				seq_pvAssign(seqg_env, 148/*epicsMotorDone*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
			}
# line 176 "../XPS_trajectoryScan.st"
			seqg_var->xpsStatus = 0;
# line 177 "../XPS_trajectoryScan.st"
			seqg_var->ncomplete = 1;
# line 180 "../XPS_trajectoryScan.st"
			for (seqg_var->i = 0; seqg_var->i < 2000; seqg_var->i++)
			{
# line 181 "../XPS_trajectoryScan.st"
				for (seqg_var->j = 0; seqg_var->j < 8; seqg_var->j++)
				{
# line 182 "../XPS_trajectoryScan.st"
					seqg_var->motorTrajectory[seqg_var->j][seqg_var->i] = 0.0;
				}
			}
# line 187 "../XPS_trajectoryScan.st"
			if (seqg_var->numAxes > 8)
# line 187 "../XPS_trajectoryScan.st"
				seqg_var->numAxes = 8;
			pVar->pollSocket = getSocket(ssId, pVar, 1.0);
			pVar->driveSocket = getSocket(ssId, pVar, 100000.);
			pVar->abortSocket = getSocket(ssId, pVar, 10.);
# line 194 "../XPS_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 195 "../XPS_trajectoryScan.st"
				seqg_var->motorCurrentIndex[seqg_var->j] = seq_pvIndex(seqg_env, 60/*motorCurrent*/ + (CH_ID)(seqg_var->j));
# line 196 "../XPS_trajectoryScan.st"
				seqg_var->epicsMotorDoneIndex[seqg_var->j] = seq_pvIndex(seqg_env, 148/*epicsMotorDone*/ + (CH_ID)(seqg_var->j));
			}
# line 200 "../XPS_trajectoryScan.st"
			seq_efClear(seqg_env, buildMon);
# line 201 "../XPS_trajectoryScan.st"
			seq_efClear(seqg_env, executeMon);
# line 202 "../XPS_trajectoryScan.st"
			seq_efClear(seqg_env, abortMon);
# line 203 "../XPS_trajectoryScan.st"
			seq_efClear(seqg_env, readbackMon);
# line 204 "../XPS_trajectoryScan.st"
			seq_efClear(seqg_env, nelementsMon);
		}
		return;
	}
}

/****** Code for state "monitor_inputs" in state set "xpsTrajectoryScan" ******/

/* Entry function for state "monitor_inputs" in state set "xpsTrajectoryScan" */
static void seqg_entry_xpsTrajectoryScan_0_monitor_inputs(SS_ID seqg_env)
{
# line 212 "../XPS_trajectoryScan.st"
	if (seqg_var->debugLevel > 0)
	{
# line 214 "../XPS_trajectoryScan.st"
		printMessage("XPS_trajectoryScan: ss xpsTrajectoryScan: state monitor_inputs: entry\n");
	}
}

/* Event function for state "monitor_inputs" in state set "xpsTrajectoryScan" */
static seqBool seqg_event_xpsTrajectoryScan_0_monitor_inputs(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 217 "../XPS_trajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, buildMon) && (seqg_var->build == 1))
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 221 "../XPS_trajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, executeMon) && (seqg_var->execute == 1) && (seqg_var->buildStatus == 1))
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 225 "../XPS_trajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, readbackMon) && (seqg_var->readback == 1) && (seqg_var->execStatus == 1))
	{
		*seqg_pnst = 5;
		*seqg_ptrn = 2;
		return TRUE;
	}
# line 228 "../XPS_trajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, nelementsMon) && (seqg_var->nelements >= 1))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 3;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "monitor_inputs" in state set "xpsTrajectoryScan" */
static void seqg_action_xpsTrajectoryScan_0_monitor_inputs(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
		}
		return;
	case 1:
		{
		}
		return;
	case 2:
		{
		}
		return;
	case 3:
		{
# line 232 "../XPS_trajectoryScan.st"
			if (seqg_var->moveMode == 0)
# line 233 "../XPS_trajectoryScan.st"
				seqg_var->endPulses = seqg_var->nelements;
			else
# line 235 "../XPS_trajectoryScan.st"
				seqg_var->endPulses = seqg_var->nelements - 1;
# line 236 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 5/*endPulses*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "build" in state set "xpsTrajectoryScan" ******/

/* Entry function for state "build" in state set "xpsTrajectoryScan" */
static void seqg_entry_xpsTrajectoryScan_0_build(SS_ID seqg_env)
{
# line 245 "../XPS_trajectoryScan.st"
	if (seqg_var->debugLevel > 0)
	{
# line 247 "../XPS_trajectoryScan.st"
		printMessage("XPS_trajectoryScan: ss xpsTrajectoryScan: state build: entry\n");
	}
}

/* Event function for state "build" in state set "xpsTrajectoryScan" */
static seqBool seqg_event_xpsTrajectoryScan_0_build(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "build" in state set "xpsTrajectoryScan" */
static void seqg_action_xpsTrajectoryScan_0_build(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 252 "../XPS_trajectoryScan.st"
			seqg_var->buildState = 1;
# line 253 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 13/*buildState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 254 "../XPS_trajectoryScan.st"
			seqg_var->buildStatus = 0;
# line 255 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 14/*buildStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 257 "../XPS_trajectoryScan.st"
			if (seqg_var->moveMode == 0)
# line 258 "../XPS_trajectoryScan.st"
				seqg_var->npoints = seqg_var->nelements;
			else
# line 260 "../XPS_trajectoryScan.st"
				seqg_var->npoints = seqg_var->nelements - 1;
# line 263 "../XPS_trajectoryScan.st"
			if (seqg_var->timeMode == 0)
			{
# line 264 "../XPS_trajectoryScan.st"
				seqg_var->dtime = seqg_var->time_PV / seqg_var->npoints;
# line 265 "../XPS_trajectoryScan.st"
				for (seqg_var->i = 0; seqg_var->i < seqg_var->nelements; seqg_var->i++)
# line 265 "../XPS_trajectoryScan.st"
					seqg_var->timeTrajectory[seqg_var->i] = seqg_var->dtime;
# line 266 "../XPS_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 26/*timeTrajectory*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 270 "../XPS_trajectoryScan.st"
			seqg_var->expectedTime = 0;
# line 271 "../XPS_trajectoryScan.st"
			for (seqg_var->i = 0; seqg_var->i < seqg_var->npoints; seqg_var->i++)
			{
# line 272 "../XPS_trajectoryScan.st"
				seqg_var->expectedTime += seqg_var->timeTrajectory[seqg_var->i];
			}
			buildAndVerify(ssId, pVar);
# line 278 "../XPS_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 279 "../XPS_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 92/*motorMVA*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
# line 280 "../XPS_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 108/*motorMAA*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
			}
# line 283 "../XPS_trajectoryScan.st"
			seqg_var->buildState = 0;
# line 284 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 13/*buildState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 285 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 14/*buildStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 286 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 15/*buildMessage*/, DEFAULT, DEFAULT_TIMEOUT);
# line 289 "../XPS_trajectoryScan.st"
			seqg_var->build = 0;
# line 290 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 12/*build*/, DEFAULT, DEFAULT_TIMEOUT);
# line 292 "../XPS_trajectoryScan.st"
			seqg_var->execStatus = 0;
# line 293 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 19/*execStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 294 "../XPS_trajectoryScan.st"
			strcpy(seqg_var->execMessage, " ");
		}
		return;
	}
}

/****** Code for state "execute" in state set "xpsTrajectoryScan" ******/

/* Entry function for state "execute" in state set "xpsTrajectoryScan" */
static void seqg_entry_xpsTrajectoryScan_0_execute(SS_ID seqg_env)
{
# line 302 "../XPS_trajectoryScan.st"
	if (seqg_var->debugLevel > 0)
	{
# line 304 "../XPS_trajectoryScan.st"
		printMessage("XPS_trajectoryScan: ss xpsTrajectoryScan: state execute: entry\n");
	}
	waitMotors(ssId, pVar);
# line 309 "../XPS_trajectoryScan.st"
	for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
# line 309 "../XPS_trajectoryScan.st"
		seqg_var->initialPos[seqg_var->j] = seqg_var->epicsMotorPos[seqg_var->j];
# line 312 "../XPS_trajectoryScan.st"
	if (seqg_var->moveMode == 1)
	{
# line 313 "../XPS_trajectoryScan.st"
		for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
		{
# line 314 "../XPS_trajectoryScan.st"
			if (seqg_var->moveAxis[seqg_var->j])
			{
# line 315 "../XPS_trajectoryScan.st"
				seqg_var->epicsMotorPos[seqg_var->j] = seqg_var->motorTrajectory[seqg_var->j][0] - seqg_var->preDistance[seqg_var->j];
# line 316 "../XPS_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 124/*epicsMotorPos*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
			}
		}
	}
	else
	{
# line 321 "../XPS_trajectoryScan.st"
		for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
		{
# line 322 "../XPS_trajectoryScan.st"
			if (seqg_var->moveAxis[seqg_var->j])
			{
# line 323 "../XPS_trajectoryScan.st"
				seqg_var->epicsMotorPos[seqg_var->j] = seqg_var->epicsMotorPos[seqg_var->j] - seqg_var->preDistance[seqg_var->j];
# line 324 "../XPS_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 124/*epicsMotorPos*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
			}
		}
	}
	waitEpicsMotors(ssId, pVar);
# line 331 "../XPS_trajectoryScan.st"
	if (seqg_var->npulses > 0)
	{
# line 333 "../XPS_trajectoryScan.st"
		if (seqg_var->startPulses < 1)
# line 333 "../XPS_trajectoryScan.st"
			seqg_var->startPulses = 1;
# line 334 "../XPS_trajectoryScan.st"
		if (seqg_var->startPulses > seqg_var->nelements)
# line 334 "../XPS_trajectoryScan.st"
			seqg_var->startPulses = seqg_var->nelements;
# line 335 "../XPS_trajectoryScan.st"
		seq_pvPutTmo(seqg_env, 4/*startPulses*/, DEFAULT, DEFAULT_TIMEOUT);
# line 336 "../XPS_trajectoryScan.st"
		if (seqg_var->endPulses < seqg_var->startPulses)
# line 336 "../XPS_trajectoryScan.st"
			seqg_var->endPulses = seqg_var->startPulses;
# line 337 "../XPS_trajectoryScan.st"
		if (seqg_var->endPulses > seqg_var->nelements)
# line 337 "../XPS_trajectoryScan.st"
			seqg_var->endPulses = seqg_var->nelements;
# line 338 "../XPS_trajectoryScan.st"
		seq_pvPutTmo(seqg_env, 5/*endPulses*/, DEFAULT, DEFAULT_TIMEOUT);
# line 346 "../XPS_trajectoryScan.st"
		seqg_var->pulseTime = 0;
# line 347 "../XPS_trajectoryScan.st"
		for (seqg_var->i = seqg_var->startPulses; seqg_var->i <= seqg_var->endPulses; seqg_var->i++)
		{
# line 348 "../XPS_trajectoryScan.st"
			seqg_var->pulseTime += seqg_var->timeTrajectory[seqg_var->i - 1];
		}
# line 350 "../XPS_trajectoryScan.st"
		seqg_var->pulsePeriod = seqg_var->pulseTime / seqg_var->npulses;
	}
	else
	{
# line 352 "../XPS_trajectoryScan.st"
		seqg_var->pulsePeriod = 0.;
	}
# line 356 "../XPS_trajectoryScan.st"
	for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
	{
# line 357 "../XPS_trajectoryScan.st"
		if (seqg_var->moveAxis[seqg_var->j])
		{
# line 361 "../XPS_trajectoryScan.st"
			seqg_var->status = PositionerUserTravelLimitsGet(seqg_var->pollSocket, seqg_var->axisName[seqg_var->j], &seqg_var->motorLowLimit[seqg_var->j], &seqg_var->motorHighLimit[seqg_var->j]);
# line 364 "../XPS_trajectoryScan.st"
			if (seqg_var->epicsMotorDir[seqg_var->j] == 0)
# line 364 "../XPS_trajectoryScan.st"
				seqg_var->dir = 1;
			else
# line 364 "../XPS_trajectoryScan.st"
				seqg_var->dir = -1;
# line 365 "../XPS_trajectoryScan.st"
			if (((seqg_var->epicsMotorPos[seqg_var->j] * seqg_var->dir + seqg_var->epicsMotorOff[seqg_var->j]) + seqg_var->motorMinPos[seqg_var->j]) < seqg_var->motorLowLimit[seqg_var->j])
			{
# line 366 "../XPS_trajectoryScan.st"
				seqg_var->execStatus = 2;
# line 367 "../XPS_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 19/*execStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 368 "../XPS_trajectoryScan.st"
				sprintf(seqg_var->execMessage, "Low soft limit violation on motor %d", seqg_var->j);
# line 369 "../XPS_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 20/*execMessage*/, DEFAULT, DEFAULT_TIMEOUT);
# line 371 "../XPS_trajectoryScan.st"
				printMessage("Low soft limit violation on motor %d, epicsMotorPos=%f, motorMinPos=%f, motorLowLimit=%f\n", seqg_var->j, seqg_var->epicsMotorPos[seqg_var->j], seqg_var->motorMinPos[seqg_var->j], seqg_var->motorLowLimit[seqg_var->j]);
			}
# line 373 "../XPS_trajectoryScan.st"
			if (((seqg_var->epicsMotorPos[seqg_var->j] * seqg_var->dir + seqg_var->epicsMotorOff[seqg_var->j]) + seqg_var->motorMaxPos[seqg_var->j]) > seqg_var->motorHighLimit[seqg_var->j])
			{
# line 374 "../XPS_trajectoryScan.st"
				seqg_var->execStatus = 2;
# line 375 "../XPS_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 19/*execStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 376 "../XPS_trajectoryScan.st"
				sprintf(seqg_var->execMessage, "High soft limit violation on motor %d", seqg_var->j);
# line 378 "../XPS_trajectoryScan.st"
				printMessage("High soft limit violation on motor %d, epicsMotorPos=%f, motorMaxPos=%f, motorHighLimit=%f\n", seqg_var->j, seqg_var->epicsMotorPos[seqg_var->j], seqg_var->motorMaxPos[seqg_var->j], seqg_var->motorHighLimit[seqg_var->j]);
# line 379 "../XPS_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 20/*execMessage*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
	}
}

/* Event function for state "execute" in state set "xpsTrajectoryScan" */
static seqBool seqg_event_xpsTrajectoryScan_0_execute(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 386 "../XPS_trajectoryScan.st"
	if (seqg_var->execStatus == 2)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 398 "../XPS_trajectoryScan.st"
	if (seqg_var->execStatus != 2)
	{
		*seqg_pnst = 4;
		*seqg_ptrn = 1;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "execute" in state set "xpsTrajectoryScan" */
static void seqg_action_xpsTrajectoryScan_0_execute(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 389 "../XPS_trajectoryScan.st"
			if (seqg_var->debugLevel > 0)
			{
# line 391 "../XPS_trajectoryScan.st"
				printMessage("XPS_trajectoryScan: ss xpsTrajectoryScan: state execute: execStatus = STATUS_FAILURE\n");
			}
# line 393 "../XPS_trajectoryScan.st"
			seqg_var->execute = 0;
# line 394 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 17/*execute*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 1:
		{
			/* C code definitions */
# line 399 "../XPS_trajectoryScan.st"
			pVar->xpsStatus = getGroupStatus(ssId, pVar);
# line 401 "../XPS_trajectoryScan.st"
			if (seqg_var->debugLevel > 0)
			{
# line 403 "../XPS_trajectoryScan.st"
				printMessage("XPS_trajectoryScan: ss xpsTrajectoryScan: state execute: setting execState = EXECUTE_STATE_MOVE_START\n");
			}
# line 405 "../XPS_trajectoryScan.st"
			seqg_var->execState = 1;
# line 406 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 18/*execState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 407 "../XPS_trajectoryScan.st"
			seqg_var->count = 0;
# line 408 "../XPS_trajectoryScan.st"
			while (seqg_var->execState != 2 && seqg_var->count < 100)
			{
# line 410 "../XPS_trajectoryScan.st"
				epicsThreadSleep(0.1);
# line 411 "../XPS_trajectoryScan.st"
				seqg_var->count++;
			}
# line 413 "../XPS_trajectoryScan.st"
			if (seqg_var->count == 100)
			{
# line 414 "../XPS_trajectoryScan.st"
				strcpy(seqg_var->execMessage, "Exec Timeout!");
# line 415 "../XPS_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 20/*execMessage*/, DEFAULT, DEFAULT_TIMEOUT);
# line 416 "../XPS_trajectoryScan.st"
				seqg_var->execStatus = 3;
# line 417 "../XPS_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 19/*execStatus*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 419 "../XPS_trajectoryScan.st"
			seqg_var->count = 0;
# line 421 "../XPS_trajectoryScan.st"
			while (seqg_var->xpsStatus != 45 && seqg_var->count < 100 && seqg_var->execStatus != 2)
			{
# line 424 "../XPS_trajectoryScan.st"
				epicsThreadSleep(0.1);
# line 425 "../XPS_trajectoryScan.st"
				seqg_var->count++;
				pVar->xpsStatus = getGroupStatus(ssId, pVar);
			}
# line 428 "../XPS_trajectoryScan.st"
			if (seqg_var->count == 100)
			{
# line 429 "../XPS_trajectoryScan.st"
				strcpy(seqg_var->execMessage, "Exec Timeout!");
# line 430 "../XPS_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 20/*execMessage*/, DEFAULT, DEFAULT_TIMEOUT);
# line 431 "../XPS_trajectoryScan.st"
				seqg_var->execStatus = 3;
# line 432 "../XPS_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 19/*execStatus*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 434 "../XPS_trajectoryScan.st"
			seqg_var->readStatus = 0;
# line 435 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 24/*readStatus*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "wait_execute" in state set "xpsTrajectoryScan" ******/

/* Entry function for state "wait_execute" in state set "xpsTrajectoryScan" */
static void seqg_entry_xpsTrajectoryScan_0_wait_execute(SS_ID seqg_env)
{
# line 443 "../XPS_trajectoryScan.st"
	if (seqg_var->debugLevel > 0)
	{
# line 445 "../XPS_trajectoryScan.st"
		printMessage("XPS_trajectoryScan: ss xpsTrajectoryScan: state wait_execute: entry\n");
	}
}

/* Event function for state "wait_execute" in state set "xpsTrajectoryScan" */
static seqBool seqg_event_xpsTrajectoryScan_0_wait_execute(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 448 "../XPS_trajectoryScan.st"
	if (seqg_var->execStatus == 3)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 464 "../XPS_trajectoryScan.st"
	if (seq_delay(seqg_env, 0.1) && seqg_var->execState == 2)
	{
		*seqg_pnst = 4;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 496 "../XPS_trajectoryScan.st"
	if (seqg_var->execState == 3)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 2;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "wait_execute" in state set "xpsTrajectoryScan" */
static void seqg_action_xpsTrajectoryScan_0_wait_execute(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 449 "../XPS_trajectoryScan.st"
			if (seqg_var->debugLevel > 0)
			{
# line 451 "../XPS_trajectoryScan.st"
				printMessage("XPS_trajectoryScan: ss xpsTrajectoryScan: state wait_execute: execStatus = STATUS_ABORT\n");
			}
# line 456 "../XPS_trajectoryScan.st"
			seqg_var->execState = 0;
# line 457 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 18/*execState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 460 "../XPS_trajectoryScan.st"
			seqg_var->execute = 0;
# line 461 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 17/*execute*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 1:
		{
			/* C code definitions */
# line 466 "../XPS_trajectoryScan.st"
			getMotorPositions(ssId, pVar, pVar->motorCurrent);
# line 467 "../XPS_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
# line 467 "../XPS_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 60/*motorCurrent*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
			pVar->xpsStatus = getGroupStatus(ssId, pVar);
# line 470 "../XPS_trajectoryScan.st"
			if (seqg_var->xpsStatus == 45)
			{
				/* C code definitions */
# line 471 "../XPS_trajectoryScan.st"
				pVar->ncomplete = currentElement(ssId, pVar);
# line 473 "../XPS_trajectoryScan.st"
				sprintf(seqg_var->execMessage, "Executing element %d/%d", seqg_var->ncomplete, seqg_var->nelements);
# line 474 "../XPS_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 20/*execMessage*/, DEFAULT, DEFAULT_TIMEOUT);
			}
			else
# line 476 "../XPS_trajectoryScan.st"
				if (seqg_var->xpsStatus == 12)
				{
# line 478 "../XPS_trajectoryScan.st"
					seqg_var->execState = 3;
# line 479 "../XPS_trajectoryScan.st"
					seqg_var->execStatus = 1;
# line 480 "../XPS_trajectoryScan.st"
					strcpy(seqg_var->execMessage, " ");
				}
				else
# line 482 "../XPS_trajectoryScan.st"
					if (seqg_var->xpsStatus < 10)
					{
# line 484 "../XPS_trajectoryScan.st"
						seqg_var->execState = 3;
# line 485 "../XPS_trajectoryScan.st"
						seqg_var->execStatus = 2;
# line 486 "../XPS_trajectoryScan.st"
						sprintf(seqg_var->execMessage, "XPS Status Error=%d", seqg_var->xpsStatus);
					}
# line 489 "../XPS_trajectoryScan.st"
			if (difftime(time(0), seqg_var->startTime) > (seqg_var->expectedTime + 10))
			{
# line 490 "../XPS_trajectoryScan.st"
				seqg_var->execState = 3;
# line 491 "../XPS_trajectoryScan.st"
				seqg_var->execStatus = 4;
# line 492 "../XPS_trajectoryScan.st"
				strcpy(seqg_var->execMessage, "Timeout");
			}
		}
		return;
	case 2:
		{
# line 497 "../XPS_trajectoryScan.st"
			if (seqg_var->debugLevel > 0)
			{
# line 499 "../XPS_trajectoryScan.st"
				printMessage("XPS_trajectoryScan: ss xpsTrajectoryScan: state wait_execute: execStatus = EXECUTE_STATE_FLYBACK\n");
			}
# line 501 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 18/*execState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 502 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 19/*execStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 503 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 20/*execMessage*/, DEFAULT, DEFAULT_TIMEOUT);
# line 506 "../XPS_trajectoryScan.st"
			if (seqg_var->execStatus == 1)
			{
				/* C code definitions */
# line 508 "../XPS_trajectoryScan.st"
				waitMotors(ssId, pVar);
# line 509 "../XPS_trajectoryScan.st"
				waitEpicsMotors(ssId, pVar);
# line 512 "../XPS_trajectoryScan.st"
				getMotorPositions(ssId, pVar, pVar->motorCurrent);
# line 513 "../XPS_trajectoryScan.st"
				for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
# line 513 "../XPS_trajectoryScan.st"
					seq_pvPutTmo(seqg_env, 60/*motorCurrent*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
# line 514 "../XPS_trajectoryScan.st"
				for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
				{
# line 515 "../XPS_trajectoryScan.st"
					seqg_var->epicsMotorPos[seqg_var->j] = seqg_var->motorCurrent[seqg_var->j];
# line 516 "../XPS_trajectoryScan.st"
					seq_pvPutTmo(seqg_env, 124/*epicsMotorPos*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
				}
				waitEpicsMotors(ssId, pVar);
			}
# line 521 "../XPS_trajectoryScan.st"
			seqg_var->execState = 0;
# line 522 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 18/*execState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 525 "../XPS_trajectoryScan.st"
			seqg_var->execute = 0;
# line 526 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 17/*execute*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "readback" in state set "xpsTrajectoryScan" ******/

/* Entry function for state "readback" in state set "xpsTrajectoryScan" */
static void seqg_entry_xpsTrajectoryScan_0_readback(SS_ID seqg_env)
{
# line 534 "../XPS_trajectoryScan.st"
	if (seqg_var->debugLevel > 0)
	{
# line 536 "../XPS_trajectoryScan.st"
		printMessage("XPS_trajectoryScan: ss xpsTrajectoryScan: state readback: entry\n");
	}
}

/* Event function for state "readback" in state set "xpsTrajectoryScan" */
static seqBool seqg_event_xpsTrajectoryScan_0_readback(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "readback" in state set "xpsTrajectoryScan" */
static void seqg_action_xpsTrajectoryScan_0_readback(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 541 "../XPS_trajectoryScan.st"
			seqg_var->readState = 1;
# line 542 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 23/*readState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 543 "../XPS_trajectoryScan.st"
			seqg_var->readStatus = 0;
# line 544 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 24/*readStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 546 "../XPS_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 547 "../XPS_trajectoryScan.st"
				for (seqg_var->i = 0; seqg_var->i < 2000; seqg_var->i++)
				{
# line 548 "../XPS_trajectoryScan.st"
					seqg_var->motorReadbacks[seqg_var->j][seqg_var->i] = 0.;
# line 549 "../XPS_trajectoryScan.st"
					seqg_var->motorError[seqg_var->j][seqg_var->i] = 0.;
				}
			}
			readGathering(ssId, pVar);
# line 556 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 6/*nactual*/, DEFAULT, DEFAULT_TIMEOUT);
# line 559 "../XPS_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 560 "../XPS_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 44/*motorReadbacks*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
# line 561 "../XPS_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 52/*motorError*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
			}
# line 564 "../XPS_trajectoryScan.st"
			seqg_var->readState = 0;
# line 565 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 23/*readState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 567 "../XPS_trajectoryScan.st"
			seqg_var->readStatus = 1;
# line 568 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 24/*readStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 569 "../XPS_trajectoryScan.st"
			strcpy(seqg_var->readMessage, " ");
# line 570 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 25/*readMessage*/, DEFAULT, DEFAULT_TIMEOUT);
# line 573 "../XPS_trajectoryScan.st"
			seqg_var->readback = 0;
# line 574 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 22/*readback*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "monitorAbort" in state set "xpsTrajectoryAbort" ******/

/* Event function for state "monitorAbort" in state set "xpsTrajectoryAbort" */
static seqBool seqg_event_xpsTrajectoryAbort_1_monitorAbort(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 586 "../XPS_trajectoryScan.st"
	if ((seq_efTestAndClear(seqg_env, abortMon)) && (seqg_var->abort == 1) && (seqg_var->execState == 2))
	{
		*seqg_pnst = 0;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "monitorAbort" in state set "xpsTrajectoryAbort" */
static void seqg_action_xpsTrajectoryAbort_1_monitorAbort(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 589 "../XPS_trajectoryScan.st"
			seqg_var->execStatus = 3;
# line 590 "../XPS_trajectoryScan.st"
			if (seqg_var->debugLevel > 0)
			{
# line 592 "../XPS_trajectoryScan.st"
				printMessage("XPS_trajectoryScan: ss xpsTrajectoryAbort: state monitorAbort: setting execStatus = STATUS_ABORT\n");
			}
# line 594 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 19/*execStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 595 "../XPS_trajectoryScan.st"
			strcpy(seqg_var->execMessage, "Motion aborted");
# line 596 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 20/*execMessage*/, DEFAULT, DEFAULT_TIMEOUT);
			trajectoryAbort(ssId, pVar);
# line 602 "../XPS_trajectoryScan.st"
			seqg_var->abort = 0;
# line 603 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 21/*abort*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "asyncExecute" in state set "xpsTrajectoryRun" ******/

/* Event function for state "asyncExecute" in state set "xpsTrajectoryRun" */
static seqBool seqg_event_xpsTrajectoryRun_2_asyncExecute(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 613 "../XPS_trajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, execStateMon) && (seqg_var->execState == 1))
	{
		*seqg_pnst = 0;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "asyncExecute" in state set "xpsTrajectoryRun" */
static void seqg_action_xpsTrajectoryRun_2_asyncExecute(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 615 "../XPS_trajectoryScan.st"
			if (seqg_var->debugLevel > 0)
			{
# line 617 "../XPS_trajectoryScan.st"
				printMessage("XPS_trajectoryScan: ss xpsTrajectoryRun: state asyncExecute: setting execState = EXECUTE_STATE_EXECUTING\n");
			}
# line 619 "../XPS_trajectoryScan.st"
			seqg_var->execState = 2;
# line 620 "../XPS_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 18/*execState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 623 "../XPS_trajectoryScan.st"
			if (seqg_var->xpsStatus > 9 && seqg_var->xpsStatus < 20)
			{
# line 625 "../XPS_trajectoryScan.st"
				seqg_var->startTime = time(0);
				trajectoryExecute(ssId, pVar);
			}
			else
			{
# line 629 "../XPS_trajectoryScan.st"
				seqg_var->execStatus = 2;
# line 630 "../XPS_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 19/*execStatus*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	}
}

/****** Code for state "positionUpdate" in state set "xpsTrajectoryPosition" ******/

/* Event function for state "positionUpdate" in state set "xpsTrajectoryPosition" */
static seqBool seqg_event_xpsTrajectoryPosition_3_positionUpdate(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 640 "../XPS_trajectoryScan.st"
	if (seq_delay(seqg_env, 1) && (seqg_var->execState == 0))
	{
		*seqg_pnst = 0;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "positionUpdate" in state set "xpsTrajectoryPosition" */
static void seqg_action_xpsTrajectoryPosition_3_positionUpdate(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
			/* C code definitions */
# line 641 "../XPS_trajectoryScan.st"
			getMotorPositions(ssId, pVar, pVar->motorCurrent);
# line 642 "../XPS_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
# line 642 "../XPS_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 60/*motorCurrent*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

#undef seqg_var

/************************ Tables ************************/

/* Channel table */
static seqChan seqg_chans[] = {
	/* chName, offset, varName, varType, count, eventNum, efId, monitored, queueSize, queueIndex */
	{"{P}{R}DebugLevel.VAL", offsetof(struct seqg_vars, debugLevel), "debugLevel", P_INT, 1, 8, 0, 1, 0, 0},
	{"{P}{R}NumAxes.VAL", offsetof(struct seqg_vars, numAxes), "numAxes", P_INT, 1, 9, 0, 1, 0, 0},
	{"{P}{R}Nelements.VAL", offsetof(struct seqg_vars, nelements), "nelements", P_INT, 1, 10, 6, 1, 0, 0},
	{"{P}{R}Npulses.VAL", offsetof(struct seqg_vars, npulses), "npulses", P_INT, 1, 11, 0, 1, 0, 0},
	{"{P}{R}StartPulses.VAL", offsetof(struct seqg_vars, startPulses), "startPulses", P_INT, 1, 12, 0, 1, 0, 0},
	{"{P}{R}EndPulses.VAL", offsetof(struct seqg_vars, endPulses), "endPulses", P_INT, 1, 13, 0, 1, 0, 0},
	{"{P}{R}Nactual.VAL", offsetof(struct seqg_vars, nactual), "nactual", P_INT, 1, 14, 0, 0, 0, 0},
	{"{P}{R}MoveMode.VAL", offsetof(struct seqg_vars, moveMode), "moveMode", P_INT, 1, 15, 0, 1, 0, 0},
	{"{P}{R}Time.VAL", offsetof(struct seqg_vars, time_PV), "time_PV", P_DOUBLE, 1, 16, 0, 1, 0, 0},
	{"{P}{R}TimeScale.VAL", offsetof(struct seqg_vars, timeScale), "timeScale", P_DOUBLE, 1, 17, 0, 1, 0, 0},
	{"{P}{R}TimeMode.VAL", offsetof(struct seqg_vars, timeMode), "timeMode", P_INT, 1, 18, 0, 1, 0, 0},
	{"{P}{R}Accel.VAL", offsetof(struct seqg_vars, accel), "accel", P_DOUBLE, 1, 19, 0, 1, 0, 0},
	{"{P}{R}Build.VAL", offsetof(struct seqg_vars, build), "build", P_INT, 1, 20, 1, 1, 0, 0},
	{"{P}{R}BuildState.VAL", offsetof(struct seqg_vars, buildState), "buildState", P_INT, 1, 21, 0, 0, 0, 0},
	{"{P}{R}BuildStatus.VAL", offsetof(struct seqg_vars, buildStatus), "buildStatus", P_INT, 1, 22, 0, 0, 0, 0},
	{"{P}{R}BuildMessage.VAL", offsetof(struct seqg_vars, buildMessage), "buildMessage", P_STRING, 1, 23, 0, 0, 0, 0},
	{"{P}{R}SimMode.VAL", offsetof(struct seqg_vars, simMode), "simMode", P_INT, 1, 24, 0, 1, 0, 0},
	{"{P}{R}Execute.VAL", offsetof(struct seqg_vars, execute), "execute", P_INT, 1, 25, 2, 1, 0, 0},
	{"{P}{R}ExecState.VAL", offsetof(struct seqg_vars, execState), "execState", P_INT, 1, 26, 3, 1, 0, 0},
	{"{P}{R}ExecStatus.VAL", offsetof(struct seqg_vars, execStatus), "execStatus", P_INT, 1, 27, 0, 0, 0, 0},
	{"{P}{R}ExecMessage.VAL", offsetof(struct seqg_vars, execMessage), "execMessage", P_STRING, 1, 28, 0, 0, 0, 0},
	{"{P}{R}Abort.VAL", offsetof(struct seqg_vars, abort), "abort", P_INT, 1, 29, 4, 1, 0, 0},
	{"{P}{R}Readback.VAL", offsetof(struct seqg_vars, readback), "readback", P_INT, 1, 30, 5, 1, 0, 0},
	{"{P}{R}ReadState.VAL", offsetof(struct seqg_vars, readState), "readState", P_INT, 1, 31, 0, 0, 0, 0},
	{"{P}{R}ReadStatus.VAL", offsetof(struct seqg_vars, readStatus), "readStatus", P_INT, 1, 32, 0, 0, 0, 0},
	{"{P}{R}ReadMessage.VAL", offsetof(struct seqg_vars, readMessage), "readMessage", P_STRING, 1, 33, 0, 0, 0, 0},
	{"{P}{R}TimeTraj.VAL", offsetof(struct seqg_vars, timeTrajectory), "timeTrajectory", P_DOUBLE, 2000, 34, 0, 1, 0, 0},
	{"{P}{R}TrajectoryFile.VAL", offsetof(struct seqg_vars, trajectoryFile), "trajectoryFile", P_STRING, 1, 35, 0, 1, 0, 0},
	{"{P}{R}M1Move.VAL", offsetof(struct seqg_vars, moveAxis[0]), "moveAxis[0]", P_INT, 1, 36, 0, 1, 0, 0},
	{"{P}{R}M2Move.VAL", offsetof(struct seqg_vars, moveAxis[1]), "moveAxis[1]", P_INT, 1, 37, 0, 1, 0, 0},
	{"{P}{R}M3Move.VAL", offsetof(struct seqg_vars, moveAxis[2]), "moveAxis[2]", P_INT, 1, 38, 0, 1, 0, 0},
	{"{P}{R}M4Move.VAL", offsetof(struct seqg_vars, moveAxis[3]), "moveAxis[3]", P_INT, 1, 39, 0, 1, 0, 0},
	{"{P}{R}M5Move.VAL", offsetof(struct seqg_vars, moveAxis[4]), "moveAxis[4]", P_INT, 1, 40, 0, 1, 0, 0},
	{"{P}{R}M6Move.VAL", offsetof(struct seqg_vars, moveAxis[5]), "moveAxis[5]", P_INT, 1, 41, 0, 1, 0, 0},
	{"{P}{R}M7Move.VAL", offsetof(struct seqg_vars, moveAxis[6]), "moveAxis[6]", P_INT, 1, 42, 0, 1, 0, 0},
	{"{P}{R}M8Move.VAL", offsetof(struct seqg_vars, moveAxis[7]), "moveAxis[7]", P_INT, 1, 43, 0, 1, 0, 0},
	{"{P}{R}M1Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[0]), "motorTrajectory[0]", P_DOUBLE, 2000, 44, 0, 1, 0, 0},
	{"{P}{R}M2Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[1]), "motorTrajectory[1]", P_DOUBLE, 2000, 45, 0, 1, 0, 0},
	{"{P}{R}M3Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[2]), "motorTrajectory[2]", P_DOUBLE, 2000, 46, 0, 1, 0, 0},
	{"{P}{R}M4Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[3]), "motorTrajectory[3]", P_DOUBLE, 2000, 47, 0, 1, 0, 0},
	{"{P}{R}M5Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[4]), "motorTrajectory[4]", P_DOUBLE, 2000, 48, 0, 1, 0, 0},
	{"{P}{R}M6Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[5]), "motorTrajectory[5]", P_DOUBLE, 2000, 49, 0, 1, 0, 0},
	{"{P}{R}M7Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[6]), "motorTrajectory[6]", P_DOUBLE, 2000, 50, 0, 1, 0, 0},
	{"{P}{R}M8Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[7]), "motorTrajectory[7]", P_DOUBLE, 2000, 51, 0, 1, 0, 0},
	{"{P}{R}M1Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[0]), "motorReadbacks[0]", P_DOUBLE, 2000, 52, 0, 0, 0, 0},
	{"{P}{R}M2Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[1]), "motorReadbacks[1]", P_DOUBLE, 2000, 53, 0, 0, 0, 0},
	{"{P}{R}M3Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[2]), "motorReadbacks[2]", P_DOUBLE, 2000, 54, 0, 0, 0, 0},
	{"{P}{R}M4Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[3]), "motorReadbacks[3]", P_DOUBLE, 2000, 55, 0, 0, 0, 0},
	{"{P}{R}M5Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[4]), "motorReadbacks[4]", P_DOUBLE, 2000, 56, 0, 0, 0, 0},
	{"{P}{R}M6Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[5]), "motorReadbacks[5]", P_DOUBLE, 2000, 57, 0, 0, 0, 0},
	{"{P}{R}M7Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[6]), "motorReadbacks[6]", P_DOUBLE, 2000, 58, 0, 0, 0, 0},
	{"{P}{R}M8Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[7]), "motorReadbacks[7]", P_DOUBLE, 2000, 59, 0, 0, 0, 0},
	{"{P}{R}M1Error.VAL", offsetof(struct seqg_vars, motorError[0]), "motorError[0]", P_DOUBLE, 2000, 60, 0, 0, 0, 0},
	{"{P}{R}M2Error.VAL", offsetof(struct seqg_vars, motorError[1]), "motorError[1]", P_DOUBLE, 2000, 61, 0, 0, 0, 0},
	{"{P}{R}M3Error.VAL", offsetof(struct seqg_vars, motorError[2]), "motorError[2]", P_DOUBLE, 2000, 62, 0, 0, 0, 0},
	{"{P}{R}M4Error.VAL", offsetof(struct seqg_vars, motorError[3]), "motorError[3]", P_DOUBLE, 2000, 63, 0, 0, 0, 0},
	{"{P}{R}M5Error.VAL", offsetof(struct seqg_vars, motorError[4]), "motorError[4]", P_DOUBLE, 2000, 64, 0, 0, 0, 0},
	{"{P}{R}M6Error.VAL", offsetof(struct seqg_vars, motorError[5]), "motorError[5]", P_DOUBLE, 2000, 65, 0, 0, 0, 0},
	{"{P}{R}M7Error.VAL", offsetof(struct seqg_vars, motorError[6]), "motorError[6]", P_DOUBLE, 2000, 66, 0, 0, 0, 0},
	{"{P}{R}M8Error.VAL", offsetof(struct seqg_vars, motorError[7]), "motorError[7]", P_DOUBLE, 2000, 67, 0, 0, 0, 0},
	{"{P}{R}M1Current.VAL", offsetof(struct seqg_vars, motorCurrent[0]), "motorCurrent[0]", P_DOUBLE, 1, 68, 0, 0, 0, 0},
	{"{P}{R}M2Current.VAL", offsetof(struct seqg_vars, motorCurrent[1]), "motorCurrent[1]", P_DOUBLE, 1, 69, 0, 0, 0, 0},
	{"{P}{R}M3Current.VAL", offsetof(struct seqg_vars, motorCurrent[2]), "motorCurrent[2]", P_DOUBLE, 1, 70, 0, 0, 0, 0},
	{"{P}{R}M4Current.VAL", offsetof(struct seqg_vars, motorCurrent[3]), "motorCurrent[3]", P_DOUBLE, 1, 71, 0, 0, 0, 0},
	{"{P}{R}M5Current.VAL", offsetof(struct seqg_vars, motorCurrent[4]), "motorCurrent[4]", P_DOUBLE, 1, 72, 0, 0, 0, 0},
	{"{P}{R}M6Current.VAL", offsetof(struct seqg_vars, motorCurrent[5]), "motorCurrent[5]", P_DOUBLE, 1, 73, 0, 0, 0, 0},
	{"{P}{R}M7Current.VAL", offsetof(struct seqg_vars, motorCurrent[6]), "motorCurrent[6]", P_DOUBLE, 1, 74, 0, 0, 0, 0},
	{"{P}{R}M8Current.VAL", offsetof(struct seqg_vars, motorCurrent[7]), "motorCurrent[7]", P_DOUBLE, 1, 75, 0, 0, 0, 0},
	{"{P}{R}M1MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[0]), "motorMDVS[0]", P_DOUBLE, 1, 76, 7, 1, 0, 0},
	{"{P}{R}M2MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[1]), "motorMDVS[1]", P_DOUBLE, 1, 77, 7, 1, 0, 0},
	{"{P}{R}M3MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[2]), "motorMDVS[2]", P_DOUBLE, 1, 78, 7, 1, 0, 0},
	{"{P}{R}M4MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[3]), "motorMDVS[3]", P_DOUBLE, 1, 79, 7, 1, 0, 0},
	{"{P}{R}M5MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[4]), "motorMDVS[4]", P_DOUBLE, 1, 80, 7, 1, 0, 0},
	{"{P}{R}M6MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[5]), "motorMDVS[5]", P_DOUBLE, 1, 81, 7, 1, 0, 0},
	{"{P}{R}M7MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[6]), "motorMDVS[6]", P_DOUBLE, 1, 82, 7, 1, 0, 0},
	{"{P}{R}M8MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[7]), "motorMDVS[7]", P_DOUBLE, 1, 83, 7, 1, 0, 0},
	{"{P}{R}M1MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[0]), "motorMDVA[0]", P_DOUBLE, 1, 84, 0, 0, 0, 0},
	{"{P}{R}M2MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[1]), "motorMDVA[1]", P_DOUBLE, 1, 85, 0, 0, 0, 0},
	{"{P}{R}M3MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[2]), "motorMDVA[2]", P_DOUBLE, 1, 86, 0, 0, 0, 0},
	{"{P}{R}M4MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[3]), "motorMDVA[3]", P_DOUBLE, 1, 87, 0, 0, 0, 0},
	{"{P}{R}M5MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[4]), "motorMDVA[4]", P_DOUBLE, 1, 88, 0, 0, 0, 0},
	{"{P}{R}M6MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[5]), "motorMDVA[5]", P_DOUBLE, 1, 89, 0, 0, 0, 0},
	{"{P}{R}M7MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[6]), "motorMDVA[6]", P_DOUBLE, 1, 90, 0, 0, 0, 0},
	{"{P}{R}M8MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[7]), "motorMDVA[7]", P_DOUBLE, 1, 91, 0, 0, 0, 0},
	{"{P}{R}M1MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[0]), "motorMDVE[0]", P_INT, 1, 92, 0, 0, 0, 0},
	{"{P}{R}M2MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[1]), "motorMDVE[1]", P_INT, 1, 93, 0, 0, 0, 0},
	{"{P}{R}M3MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[2]), "motorMDVE[2]", P_INT, 1, 94, 0, 0, 0, 0},
	{"{P}{R}M4MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[3]), "motorMDVE[3]", P_INT, 1, 95, 0, 0, 0, 0},
	{"{P}{R}M5MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[4]), "motorMDVE[4]", P_INT, 1, 96, 0, 0, 0, 0},
	{"{P}{R}M6MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[5]), "motorMDVE[5]", P_INT, 1, 97, 0, 0, 0, 0},
	{"{P}{R}M7MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[6]), "motorMDVE[6]", P_INT, 1, 98, 0, 0, 0, 0},
	{"{P}{R}M8MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[7]), "motorMDVE[7]", P_INT, 1, 99, 0, 0, 0, 0},
	{"{P}{R}M1MVA.VAL", offsetof(struct seqg_vars, motorMVA[0]), "motorMVA[0]", P_DOUBLE, 1, 100, 0, 0, 0, 0},
	{"{P}{R}M2MVA.VAL", offsetof(struct seqg_vars, motorMVA[1]), "motorMVA[1]", P_DOUBLE, 1, 101, 0, 0, 0, 0},
	{"{P}{R}M3MVA.VAL", offsetof(struct seqg_vars, motorMVA[2]), "motorMVA[2]", P_DOUBLE, 1, 102, 0, 0, 0, 0},
	{"{P}{R}M4MVA.VAL", offsetof(struct seqg_vars, motorMVA[3]), "motorMVA[3]", P_DOUBLE, 1, 103, 0, 0, 0, 0},
	{"{P}{R}M5MVA.VAL", offsetof(struct seqg_vars, motorMVA[4]), "motorMVA[4]", P_DOUBLE, 1, 104, 0, 0, 0, 0},
	{"{P}{R}M6MVA.VAL", offsetof(struct seqg_vars, motorMVA[5]), "motorMVA[5]", P_DOUBLE, 1, 105, 0, 0, 0, 0},
	{"{P}{R}M7MVA.VAL", offsetof(struct seqg_vars, motorMVA[6]), "motorMVA[6]", P_DOUBLE, 1, 106, 0, 0, 0, 0},
	{"{P}{R}M8MVA.VAL", offsetof(struct seqg_vars, motorMVA[7]), "motorMVA[7]", P_DOUBLE, 1, 107, 0, 0, 0, 0},
	{"{P}{R}M1MVE.VAL", offsetof(struct seqg_vars, motorMVE[0]), "motorMVE[0]", P_INT, 1, 108, 0, 0, 0, 0},
	{"{P}{R}M2MVE.VAL", offsetof(struct seqg_vars, motorMVE[1]), "motorMVE[1]", P_INT, 1, 109, 0, 0, 0, 0},
	{"{P}{R}M3MVE.VAL", offsetof(struct seqg_vars, motorMVE[2]), "motorMVE[2]", P_INT, 1, 110, 0, 0, 0, 0},
	{"{P}{R}M4MVE.VAL", offsetof(struct seqg_vars, motorMVE[3]), "motorMVE[3]", P_INT, 1, 111, 0, 0, 0, 0},
	{"{P}{R}M5MVE.VAL", offsetof(struct seqg_vars, motorMVE[4]), "motorMVE[4]", P_INT, 1, 112, 0, 0, 0, 0},
	{"{P}{R}M6MVE.VAL", offsetof(struct seqg_vars, motorMVE[5]), "motorMVE[5]", P_INT, 1, 113, 0, 0, 0, 0},
	{"{P}{R}M7MVE.VAL", offsetof(struct seqg_vars, motorMVE[6]), "motorMVE[6]", P_INT, 1, 114, 0, 0, 0, 0},
	{"{P}{R}M8MVE.VAL", offsetof(struct seqg_vars, motorMVE[7]), "motorMVE[7]", P_INT, 1, 115, 0, 0, 0, 0},
	{"{P}{R}M1MAA.VAL", offsetof(struct seqg_vars, motorMAA[0]), "motorMAA[0]", P_DOUBLE, 1, 116, 0, 0, 0, 0},
	{"{P}{R}M2MAA.VAL", offsetof(struct seqg_vars, motorMAA[1]), "motorMAA[1]", P_DOUBLE, 1, 117, 0, 0, 0, 0},
	{"{P}{R}M3MAA.VAL", offsetof(struct seqg_vars, motorMAA[2]), "motorMAA[2]", P_DOUBLE, 1, 118, 0, 0, 0, 0},
	{"{P}{R}M4MAA.VAL", offsetof(struct seqg_vars, motorMAA[3]), "motorMAA[3]", P_DOUBLE, 1, 119, 0, 0, 0, 0},
	{"{P}{R}M5MAA.VAL", offsetof(struct seqg_vars, motorMAA[4]), "motorMAA[4]", P_DOUBLE, 1, 120, 0, 0, 0, 0},
	{"{P}{R}M6MAA.VAL", offsetof(struct seqg_vars, motorMAA[5]), "motorMAA[5]", P_DOUBLE, 1, 121, 0, 0, 0, 0},
	{"{P}{R}M7MAA.VAL", offsetof(struct seqg_vars, motorMAA[6]), "motorMAA[6]", P_DOUBLE, 1, 122, 0, 0, 0, 0},
	{"{P}{R}M8MAA.VAL", offsetof(struct seqg_vars, motorMAA[7]), "motorMAA[7]", P_DOUBLE, 1, 123, 0, 0, 0, 0},
	{"{P}{R}M1MAE.VAL", offsetof(struct seqg_vars, motorMAE[0]), "motorMAE[0]", P_INT, 1, 124, 0, 0, 0, 0},
	{"{P}{R}M2MAE.VAL", offsetof(struct seqg_vars, motorMAE[1]), "motorMAE[1]", P_INT, 1, 125, 0, 0, 0, 0},
	{"{P}{R}M3MAE.VAL", offsetof(struct seqg_vars, motorMAE[2]), "motorMAE[2]", P_INT, 1, 126, 0, 0, 0, 0},
	{"{P}{R}M4MAE.VAL", offsetof(struct seqg_vars, motorMAE[3]), "motorMAE[3]", P_INT, 1, 127, 0, 0, 0, 0},
	{"{P}{R}M5MAE.VAL", offsetof(struct seqg_vars, motorMAE[4]), "motorMAE[4]", P_INT, 1, 128, 0, 0, 0, 0},
	{"{P}{R}M6MAE.VAL", offsetof(struct seqg_vars, motorMAE[5]), "motorMAE[5]", P_INT, 1, 129, 0, 0, 0, 0},
	{"{P}{R}M7MAE.VAL", offsetof(struct seqg_vars, motorMAE[6]), "motorMAE[6]", P_INT, 1, 130, 0, 0, 0, 0},
	{"{P}{R}M8MAE.VAL", offsetof(struct seqg_vars, motorMAE[7]), "motorMAE[7]", P_INT, 1, 131, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[0]), "epicsMotorPos[0]", P_DOUBLE, 1, 132, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[1]), "epicsMotorPos[1]", P_DOUBLE, 1, 133, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[2]), "epicsMotorPos[2]", P_DOUBLE, 1, 134, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[3]), "epicsMotorPos[3]", P_DOUBLE, 1, 135, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[4]), "epicsMotorPos[4]", P_DOUBLE, 1, 136, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[5]), "epicsMotorPos[5]", P_DOUBLE, 1, 137, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[6]), "epicsMotorPos[6]", P_DOUBLE, 1, 138, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[7]), "epicsMotorPos[7]", P_DOUBLE, 1, 139, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[0]), "epicsMotorDir[0]", P_DOUBLE, 1, 140, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[1]), "epicsMotorDir[1]", P_DOUBLE, 1, 141, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[2]), "epicsMotorDir[2]", P_DOUBLE, 1, 142, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[3]), "epicsMotorDir[3]", P_DOUBLE, 1, 143, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[4]), "epicsMotorDir[4]", P_DOUBLE, 1, 144, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[5]), "epicsMotorDir[5]", P_DOUBLE, 1, 145, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[6]), "epicsMotorDir[6]", P_DOUBLE, 1, 146, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[7]), "epicsMotorDir[7]", P_DOUBLE, 1, 147, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[0]), "epicsMotorOff[0]", P_DOUBLE, 1, 148, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[1]), "epicsMotorOff[1]", P_DOUBLE, 1, 149, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[2]), "epicsMotorOff[2]", P_DOUBLE, 1, 150, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[3]), "epicsMotorOff[3]", P_DOUBLE, 1, 151, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[4]), "epicsMotorOff[4]", P_DOUBLE, 1, 152, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[5]), "epicsMotorOff[5]", P_DOUBLE, 1, 153, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[6]), "epicsMotorOff[6]", P_DOUBLE, 1, 154, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[7]), "epicsMotorOff[7]", P_DOUBLE, 1, 155, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[0]), "epicsMotorDone[0]", P_DOUBLE, 1, 156, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[1]), "epicsMotorDone[1]", P_DOUBLE, 1, 157, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[2]), "epicsMotorDone[2]", P_DOUBLE, 1, 158, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[3]), "epicsMotorDone[3]", P_DOUBLE, 1, 159, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[4]), "epicsMotorDone[4]", P_DOUBLE, 1, 160, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[5]), "epicsMotorDone[5]", P_DOUBLE, 1, 161, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[6]), "epicsMotorDone[6]", P_DOUBLE, 1, 162, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[7]), "epicsMotorDone[7]", P_DOUBLE, 1, 163, 0, 1, 0, 0},
};

/* Event masks for state set "xpsTrajectoryScan" */
static const seqMask seqg_mask_xpsTrajectoryScan_0_init[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_xpsTrajectoryScan_0_monitor_inputs[] = {
	0x4a500466,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_xpsTrajectoryScan_0_build[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_xpsTrajectoryScan_0_execute[] = {
	0x08000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_xpsTrajectoryScan_0_wait_execute[] = {
	0x0c000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_xpsTrajectoryScan_0_readback[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};

/* State table for state set "xpsTrajectoryScan" */
static seqState seqg_states_xpsTrajectoryScan[] = {
	{
	/* state name */        "init",
	/* action function */   seqg_action_xpsTrajectoryScan_0_init,
	/* event function */    seqg_event_xpsTrajectoryScan_0_init,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_xpsTrajectoryScan_0_init,
	/* state options */     (0)
	},
	{
	/* state name */        "monitor_inputs",
	/* action function */   seqg_action_xpsTrajectoryScan_0_monitor_inputs,
	/* event function */    seqg_event_xpsTrajectoryScan_0_monitor_inputs,
	/* entry function */    seqg_entry_xpsTrajectoryScan_0_monitor_inputs,
	/* exit function */     0,
	/* event mask array */  seqg_mask_xpsTrajectoryScan_0_monitor_inputs,
	/* state options */     (0)
	},
	{
	/* state name */        "build",
	/* action function */   seqg_action_xpsTrajectoryScan_0_build,
	/* event function */    seqg_event_xpsTrajectoryScan_0_build,
	/* entry function */    seqg_entry_xpsTrajectoryScan_0_build,
	/* exit function */     0,
	/* event mask array */  seqg_mask_xpsTrajectoryScan_0_build,
	/* state options */     (0)
	},
	{
	/* state name */        "execute",
	/* action function */   seqg_action_xpsTrajectoryScan_0_execute,
	/* event function */    seqg_event_xpsTrajectoryScan_0_execute,
	/* entry function */    seqg_entry_xpsTrajectoryScan_0_execute,
	/* exit function */     0,
	/* event mask array */  seqg_mask_xpsTrajectoryScan_0_execute,
	/* state options */     (0)
	},
	{
	/* state name */        "wait_execute",
	/* action function */   seqg_action_xpsTrajectoryScan_0_wait_execute,
	/* event function */    seqg_event_xpsTrajectoryScan_0_wait_execute,
	/* entry function */    seqg_entry_xpsTrajectoryScan_0_wait_execute,
	/* exit function */     0,
	/* event mask array */  seqg_mask_xpsTrajectoryScan_0_wait_execute,
	/* state options */     (0)
	},
	{
	/* state name */        "readback",
	/* action function */   seqg_action_xpsTrajectoryScan_0_readback,
	/* event function */    seqg_event_xpsTrajectoryScan_0_readback,
	/* entry function */    seqg_entry_xpsTrajectoryScan_0_readback,
	/* exit function */     0,
	/* event mask array */  seqg_mask_xpsTrajectoryScan_0_readback,
	/* state options */     (0)
	},
};

/* Event masks for state set "xpsTrajectoryAbort" */
static const seqMask seqg_mask_xpsTrajectoryAbort_1_monitorAbort[] = {
	0x24000010,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};

/* State table for state set "xpsTrajectoryAbort" */
static seqState seqg_states_xpsTrajectoryAbort[] = {
	{
	/* state name */        "monitorAbort",
	/* action function */   seqg_action_xpsTrajectoryAbort_1_monitorAbort,
	/* event function */    seqg_event_xpsTrajectoryAbort_1_monitorAbort,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_xpsTrajectoryAbort_1_monitorAbort,
	/* state options */     (0)
	},
};

/* Event masks for state set "xpsTrajectoryRun" */
static const seqMask seqg_mask_xpsTrajectoryRun_2_asyncExecute[] = {
	0x04000008,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};

/* State table for state set "xpsTrajectoryRun" */
static seqState seqg_states_xpsTrajectoryRun[] = {
	{
	/* state name */        "asyncExecute",
	/* action function */   seqg_action_xpsTrajectoryRun_2_asyncExecute,
	/* event function */    seqg_event_xpsTrajectoryRun_2_asyncExecute,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_xpsTrajectoryRun_2_asyncExecute,
	/* state options */     (0)
	},
};

/* Event masks for state set "xpsTrajectoryPosition" */
static const seqMask seqg_mask_xpsTrajectoryPosition_3_positionUpdate[] = {
	0x04000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};

/* State table for state set "xpsTrajectoryPosition" */
static seqState seqg_states_xpsTrajectoryPosition[] = {
	{
	/* state name */        "positionUpdate",
	/* action function */   seqg_action_xpsTrajectoryPosition_3_positionUpdate,
	/* event function */    seqg_event_xpsTrajectoryPosition_3_positionUpdate,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_xpsTrajectoryPosition_3_positionUpdate,
	/* state options */     (0)
	},
};

/* State set table */
static seqSS seqg_statesets[] = {
	{
	/* state set name */    "xpsTrajectoryScan",
	/* states */            seqg_states_xpsTrajectoryScan,
	/* number of states */  6
	},

	{
	/* state set name */    "xpsTrajectoryAbort",
	/* states */            seqg_states_xpsTrajectoryAbort,
	/* number of states */  1
	},

	{
	/* state set name */    "xpsTrajectoryRun",
	/* states */            seqg_states_xpsTrajectoryRun,
	/* number of states */  1
	},

	{
	/* state set name */    "xpsTrajectoryPosition",
	/* states */            seqg_states_xpsTrajectoryPosition,
	/* number of states */  1
	},
};

/* Program table (global) */
seqProgram XPS_trajectoryScan = {
	/* magic number */      2002005,
	/* program name */      "XPS_trajectoryScan",
	/* channels */          seqg_chans,
	/* num. channels */     156,
	/* state sets */        seqg_statesets,
	/* num. state sets */   4,
	/* user var size */     sizeof(struct seqg_vars),
	/* param */             "P=13BMC:,R=traj1,IPADDR=164.54.160.34,PORT=5001,USERNAME=Administrator,PASSWORD=Administrator,M1=m1,M2=m2,M3=m3,M4=m4,M5=m5,M6=m6,M7=m7,M8=m8,GROUP=g1,P1=p1,P2=p2,P3=p3,P4=p4,P5=p5,P6=p6,P7=p7,P8=p8",
	/* num. event flags */  7,
	/* encoded options */   (0 | OPT_CONN | OPT_NEWEF | OPT_REENT),
	/* init func */         seqg_init,
	/* entry func */        0,
	/* exit func */         0,
	/* num. queues */       0
};
# line 649 "../XPS_trajectoryScan.st"





static int getMotorPositions(SS_ID ssId, struct UserVar *pVar, double *pos)
{
    int status;
    int j;
    int dir;



    status = GroupPositionCurrentGet(pVar->positionSocket,
                                     pVar->groupName,pVar->numAxes,pos);
    if (status != 0)
        printMessage("Error performing GroupPositionCurrentGet%i\n", status);

    for (j=0; j<pVar->numAxes; j++) {
        if (pVar->epicsMotorDir[j] == 0) dir=1; else dir=-1;
        pos[j] = pos[j]*dir + pVar->epicsMotorOff[j];
    }

    return(status);
}



static int getMotorMoving(SS_ID ssId, struct UserVar *pVar)
{
    int status;
    int moving=0;
    int groupStatus;



    status = GroupStatusGet(pVar->pollSocket,pVar->groupName,&groupStatus);
    if (status != 0)
        printMessage("Error performing GroupStatusGet %i\n",status);

    if (groupStatus > 42)
        moving = 1;

    return(moving);
}




static int getEpicsMotorMoving(SS_ID ssId, struct UserVar *pVar)
{
    int j;
    int result=0, mask=0x01;

    for (j=0; j<pVar->numAxes; j++) {
  seq_pvGet(ssId, pVar->epicsMotorDoneIndex[j], 0);
        if (pVar->epicsMotorDone[j] == 0) result |= mask;
        mask = mask << 1;
    }
    return(result);
}



static int waitMotors(SS_ID ssId, struct UserVar *pVar)
{
    int j;



    while(getMotorMoving(ssId, pVar)) {

        getMotorPositions(ssId, pVar, pVar->motorCurrent);
        for (j=0; j<pVar->numAxes; j++) {
   seq_pvPut(ssId, pVar->motorCurrentIndex[j], 0);
  }
        epicsThreadSleep(0.1);
    }
    getMotorPositions(ssId, pVar, pVar->motorCurrent);
    for (j=0; j<pVar->numAxes; j++) {
  seq_pvPut(ssId, pVar->motorCurrentIndex[j], 0);
 }
    return(0);
}



static int waitEpicsMotors(SS_ID ssId, struct UserVar *pVar)
{
    int j;



    while(getEpicsMotorMoving(ssId, pVar)) {

        for (j=0; j<pVar->numAxes; j++) {
            pVar->motorCurrent[j] = pVar->epicsMotorPos[j];
   seq_pvPut(ssId, pVar->motorCurrentIndex[j], 0);
        }
        epicsThreadSleep(0.1);
    }
    for (j=0; j<pVar->numAxes; j++) {
        pVar->motorCurrent[j] = pVar->epicsMotorPos[j];
  seq_pvPut(ssId, pVar->motorCurrentIndex[j], 0);
    }
    return(0);
}


static int getSocket(SS_ID ssId, struct UserVar *pVar, double timeout)
{
    int sock = 0;

    sock = TCP_ConnectToServer(pVar->xpsAddress, pVar->xpsPort, timeout);
    if (sock < 0)
            printMessage("Error TCP_ConnectToServer, status=%d\n",sock);
    return (sock);
}



static void trajectoryExecute(SS_ID ssId, struct UserVar *pVar)
{
    int status;
    int j;
    char buffer[60 * 2 * 8];
    int eventId;

    if (pVar->debugLevel > 0) {
        printMessage("XPS_trajectoryScan: trajectoryExecute:"
               " entry\n");
    }



    if (pVar->debugLevel > 0) {
        printMessage("XPS_trajectoryScan: trajectoryExecute:"
               " calling GatheringReset(%d)\n", pVar->pollSocket);
    }
    status = GatheringReset(pVar->pollSocket);
    if (status != 0) {
        printMessage("Error performing GatheringReset, status=%d\n",status);
        return;
    }



    strcpy(buffer, "");
    for (j=0; j<pVar->numAxes; j++) {
        strcat (buffer, pVar->axisName[j]);
        strcat (buffer, ".SetpointPosition;");
        strcat (buffer, pVar->axisName[j]);
        strcat (buffer, ".CurrentPosition;");
    }



    if (pVar->debugLevel > 0) {
        printMessage("XPS_trajectoryScan: trajectoryExecute:"
               " calling GatheringConfigurationSet(%d, %d, %s)\n",
               pVar->pollSocket, pVar->numAxes*2, buffer);
    }
    status = GatheringConfigurationSet(pVar->pollSocket,
                                       pVar->numAxes*2, buffer);
    if (status != 0)
            printMessage("Error performing GatheringConfigurationSet, status=%d, buffer=%p\n",
                   status, buffer);
# 824 "../XPS_trajectoryScan.st"
    if (pVar->debugLevel > 0) {
        printMessage("XPS_trajectoryScan: trajectoryExecute:"
               " calling MultipleAxesPVTPulseOutputSet(%d, %s, %d, %d, %f)\n",
                                           pVar->pollSocket, pVar->groupName,
                                           pVar->startPulses+1,
                                           pVar->endPulses+1,
                                           pVar->pulsePeriod);
    }
    status = MultipleAxesPVTPulseOutputSet(pVar->pollSocket, pVar->groupName,
                                           pVar->startPulses+1,
                                           pVar->endPulses+1,
                                           pVar->pulsePeriod);


    sprintf(buffer, "Always;%s.PVT.TrajectoryPulse", pVar->groupName);
    if (pVar->debugLevel > 0) {
        printMessage("XPS_trajectoryScan: trajectoryExecute:"
               " calling EventExtendedConfigurationTriggerSet(%d, %d, %s, %s, %s, %s, %s)\n",
                                                  pVar->pollSocket, 2, buffer,
                                                  "", "", "", "");
    }
    status = EventExtendedConfigurationTriggerSet(pVar->pollSocket, 2, buffer,
                                                  "", "", "", "");
    if (status != 0) {
        printMessage("Error performing EventExtendedConfigurationTriggerSet, status=%d, buffer=%s\n",
               status, buffer);
        return;
    }


    if (pVar->debugLevel > 0) {
        printMessage("XPS_trajectoryScan: trajectoryExecute:"
               " calling EventExtendedConfigurationActionSet(%d, %d, %s, %s, %s, %s, %s)\n",
                                                 pVar->pollSocket, 1,
                                                 "GatheringOneData",
                                                 "", "", "", "");
    }
    status = EventExtendedConfigurationActionSet(pVar->pollSocket, 1,
                                                 "GatheringOneData",
                                                 "", "", "", "");
    if (status != 0) {
        printMessage("Error performing EventExtendedConfigurationActionSet, status=%d\n",
               status);
        return;
    }


    if (pVar->debugLevel > 0) {
        printMessage("XPS_trajectoryScan: trajectoryExecute:"
               " calling EventExtendedStart(%d, %p)\n",
                                            pVar->pollSocket, &eventId);
    }
    status= EventExtendedStart(pVar->pollSocket, &eventId);
    if (status != 0) {
        printMessage("Error performing EventExtendedStart, status=%d\n",status);
        return;
    }

    if (pVar->debugLevel > 0) {
        printMessage("XPS_trajectoryScan: trajectoryExecute:"
               " calling MultipleAxesPVTExecution(%d, %s, %s, %d)\n",
                                      pVar->driveSocket, pVar->groupName,
                                      pVar->trajectoryFile, 1);
    }
    status = MultipleAxesPVTExecution(pVar->driveSocket, pVar->groupName,
                                      pVar->trajectoryFile, 1);

    if ((status != 0) && (status != -27))
        printMessage("Error performing MultipleAxesPVTExecution, status=%d\n", status);


    if (pVar->debugLevel > 0) {
        printMessage("XPS_trajectoryScan: trajectoryExecute:"
               " calling EventExtendedRemove(%d, %d)\n", pVar->pollSocket, eventId);
    }
    status = EventExtendedRemove(pVar->pollSocket, eventId);
    if (status != 0) {
        printMessage("Error performing ExtendedEventRemove, status=%d\n",status);
        return;
    }


    if (pVar->debugLevel > 0) {
        printMessage("XPS_trajectoryScan: trajectoryExecute:"
               " calling GatheringStop(%d)\n", pVar->pollSocket);
    }
    status = GatheringStop(pVar->pollSocket);



    if ((status != 0) && (status != -30))
        printMessage("Error performing GatheringStop, status=%d\n", status);

    return;
}



static void buildAndVerify(SS_ID ssId, struct UserVar *pVar)
{
    FILE *trajFile;
    int i, j, status;
    int npoints;
    double trajVel;
    double D0, D1, T0, T1;
    SOCKET ftpSocket;
    char fileName[100];
    double distance;
    double maxVelocity[8], maxAcceleration[8];
    double minJerkTime[8], maxJerkTime[8];
    double preTimeMax, postTimeMax;
    double preVelocity[8], postVelocity[8];
    double time;
    int dir[8];

    if (pVar->debugLevel > 0) {
        printMessage("XPS_trajectoryScan: buildAndVerify:"
               " entry\n");
    }
# 953 "../XPS_trajectoryScan.st"
    preTimeMax = 0.;
    postTimeMax = 0.;

    for (j=0; j<pVar->numAxes; j++) {
        preVelocity[j] = 0.;
        postVelocity[j] = 0.;
    }
    for (j=0; j<pVar->numAxes; j++) {
        if (!pVar->moveAxis[j]) continue;
        status = PositionerSGammaParametersGet(pVar->pollSocket, pVar->axisName[j],
                                               &maxVelocity[j], &maxAcceleration[j],
                                               &minJerkTime[j], &maxJerkTime[j]);
        if (status != 0) {
            printMessage("Error calling positionerSGammaParametersSet, status=%d\n",
                   status);
        }



        maxAcceleration[j] = 0.9 * maxAcceleration[j];



        if (pVar->moveMode == 0) {
            distance = pVar->motorTrajectory[j][0];
        } else {
            distance = pVar->motorTrajectory[j][1] - pVar->motorTrajectory[j][0];
        }
        preVelocity[j] = distance/pVar->timeTrajectory[0];
        time = fabs(preVelocity[j]) / maxAcceleration[j];
        if (time > preTimeMax) preTimeMax = time;
        if (pVar->moveMode == 0) {
            distance = pVar->motorTrajectory[j][pVar->nelements-1];
        } else {
            distance = pVar->motorTrajectory[j][pVar->nelements-1] -
                       pVar->motorTrajectory[j][pVar->nelements-2];
        }
        postVelocity[j] = distance/pVar->timeTrajectory[pVar->nelements-1];
        time = fabs(postVelocity[j]) / maxAcceleration[j];
        if (time > postTimeMax) postTimeMax = time;
    }



    for (j=0; j<pVar->numAxes; j++) {
        pVar->preDistance[j] = 0.5 * preVelocity[j] * preTimeMax;
        pVar->postDistance[j] = 0.5 * postVelocity[j] * postTimeMax;
    }


    trajFile = fopen (pVar->trajectoryFile, "w");



    for (j=0; j<pVar->numAxes; j++) {
        if (pVar->epicsMotorDir[j] == 0) dir[j]=1; else dir[j]=-1;
    }

    fprintf(trajFile,"%f", preTimeMax);
    for (j=0; j<pVar->numAxes; j++)
        fprintf(trajFile,", %f, %f", pVar->preDistance[j]*dir[j], preVelocity[j]*dir[j]);
    fprintf(trajFile,"\n");



    if (pVar->moveMode == 0)
        npoints = pVar->nelements;
    else
        npoints = pVar->nelements-1;
    for (i=0; i<npoints; i++) {
        T0 = pVar->timeTrajectory[i];
        if (i < npoints-1)
            T1 = pVar->timeTrajectory[i+1];
        else
            T1 = T0;
        for (j=0; j<pVar->numAxes; j++) {
            if (pVar->moveMode == 0) {
                D0 = pVar->motorTrajectory[j][i] * dir[j];
                if (i < npoints-1)
                    D1 = pVar->motorTrajectory[j][i+1] * dir[j];
                else
                    D1 = D0;
            } else {
                D0 = pVar->motorTrajectory[j][i+1] *dir[j] -
                           pVar->motorTrajectory[j][i] * dir[j];
                if (i < npoints-1)
                    D1 = pVar->motorTrajectory[j][i+2] * dir[j] -
                           pVar->motorTrajectory[j][i+1] * dir[j];
                else
                    D1 = D0;
            }


            trajVel = ((D0 + D1) / (T0 + T1));
            if (!(pVar->moveAxis[j])) {
                D0 = 0.0;
                trajVel = 0.0;
            }

            if (j == 0) fprintf(trajFile,"%f", pVar->timeTrajectory[i]);
            fprintf(trajFile,", %f, %f",D0,trajVel);
            if (j == (pVar->numAxes-1)) fprintf(trajFile,"\n");
        }
    }


    fprintf(trajFile,"%f", postTimeMax);
    for (j=0; j<pVar->numAxes; j++)
        fprintf(trajFile,", %f, %f", pVar->postDistance[j]*dir[j], 0.);
    fprintf(trajFile,"\n");
    fclose (trajFile);


    status = ftpConnect(pVar->xpsAddress, pVar->userName, pVar->password, &ftpSocket);
    if (status != 0) {
        printMessage("Error calling ftpConnect, status=%d\n", status);
        return;
    }
    status = ftpChangeDir(ftpSocket, "/Admin/public/Trajectories");
    if (status != 0) {
        printMessage("Error calling ftpChangeDir, status=%d\n", status);
        return;
    }
    status = ftpStoreFile(ftpSocket, pVar->trajectoryFile);
    if (status != 0) {
        printMessage("Error calling ftpStoreFile, status=%d\n", status);
        return;
    }
    status = ftpDisconnect(ftpSocket);
    if (status != 0) {
        printMessage("Error calling ftpDisconnect, status=%d\n", status);
        return;
    }


    if (pVar->debugLevel > 0) {
        printMessage("XPS_trajectoryScan: buildAndVerify:"
               " calling MultipleAxesPVTVerification(%d, %s, %s)\n",
               pVar->pollSocket, pVar->groupName, pVar->trajectoryFile);
    }
    status = MultipleAxesPVTVerification(pVar->pollSocket, pVar->groupName,
                                         pVar->trajectoryFile);

    pVar->buildStatus = 2;
    if (status == 0) {
        strcpy(pVar->buildMessage, " ");
        pVar->buildStatus = 1;
    }
    else if (status == -69)
        strcpy(pVar->buildMessage, "Acceleration Too High");
    else if (status == -68)
        strcpy(pVar->buildMessage, "Velocity Too High");
    else if (status == -70)
        strcpy(pVar->buildMessage, "Final Velocity Non Zero");
    else if (status == -75)
        strcpy(pVar->buildMessage, "Negative or Null Delta Time");
    else
        sprintf(pVar->buildMessage, "Unknown trajectory verify error=%d", status);



    if (status == 0){
        pVar->buildStatus = 1;
    }
    if (1) {
        for (j=0; j<pVar->numAxes; j++) {
            status = MultipleAxesPVTVerificationResultGet(pVar->pollSocket,
                         pVar->axisName[j], fileName, &pVar->motorMinPos[j], &pVar->motorMaxPos[j],
                         &pVar->motorMVA[j], &pVar->motorMAA[j]);
            if (status != 0) {
                printMessage("Error performing MultipleAxesPVTVerificationResultGet for axis %s, status=%d\n",
                       pVar->axisName[j], status);
            }
        }
    } else {
        for (j=0; j<pVar->numAxes; j++) {
            pVar->motorMVA[j] = 0;
            pVar->motorMAA[j] = 0;
        }
    }

    return;
}



static int currentElement(SS_ID ssId, struct UserVar *pVar)
{
    int status;
    int number;
    char fileName[100];

    status = MultipleAxesPVTParametersGet(pVar->pollSocket,
                 pVar->groupName, fileName, &number);
    if (status != 0)
        printMessage("Error performing MultipleAxesPVTParametersGet, status=%d\n",
               status);
    return (number);
}

static int getGroupStatus(SS_ID ssId, struct UserVar *pVar)
{
    int status;
    int groupStatus;



    status = GroupStatusGet(pVar->pollSocket,pVar->groupName,&groupStatus);
    if (status != 0)
        printMessage("Error performing GroupStatusGet, status=%d\n", status);
    return(groupStatus);
}





static void readGathering(SS_ID ssId, struct UserVar *pVar)
{
    char *buffer, *bptr, *tptr;
    int currentSamples, maxSamples;
    double setpointPosition, actualPosition;
    int status;
    int dir;
    int i, j;
    int nitems;
    int numRead, numInBuffer, numChars;


    if (pVar->debugLevel > 0) {
        printMessage("XPS_trajectoryScan: readGathering:"
               " entry\n");
    }

    status = GatheringCurrentNumberGet(pVar->pollSocket, &currentSamples, &maxSamples);
    if (status != 0) {
        printMessage("Error calling GatherCurrentNumberGet, status=%d\n", status);
        return;
    }
    if (currentSamples != pVar->npulses) {
        printMessage("readGathering: error, npulses=%d, currentSamples=%d\n",
            pVar->npulses, currentSamples);
        return;
    }
    buffer = (char *)calloc(65536, sizeof(char));
    numInBuffer = 0;
    for (numRead=0; numRead<currentSamples;) {


        status = -1;
        numInBuffer = currentSamples - numRead;
        while (status && (numInBuffer > 0)) {
            status = GatheringDataMultipleLinesGet(pVar->pollSocket, numRead, numInBuffer, buffer);
            if (pVar->debugLevel > 0) {
                printMessage("readGathering: GatheringDataMultipleLinesGet, status=%d, numInBuffer=%d\n", status, numInBuffer);
            }
            if (status) numInBuffer /= 2;
        }
        if (numInBuffer == 0) {
            printMessage("Error reading gathering data, numInBuffer = 0\n");
            goto done;
        }
        bptr = buffer;
        for (i=0; i<numInBuffer; i++) {

            tptr = strstr(bptr, "\n");
            if (tptr) *tptr = 0;
            for (j=0; j<pVar->numAxes; j++) {
                nitems = sscanf(bptr, "%lf;%lf%n",
                                &setpointPosition, &actualPosition, &numChars);
                bptr += numChars+1;
                if (nitems != 2) {
                    printMessage("Error reading Gathering.dat file, nitems=%d, should be %d\n",
                           nitems, 2);
                    goto done;
                }
                pVar->motorError[j][numRead] = actualPosition - setpointPosition;

                if (pVar->epicsMotorDir[j] == 0) dir=1; else dir=-1;
                pVar->motorReadbacks[j][numRead] = actualPosition * dir + pVar->epicsMotorOff[j];
            }
            numRead++;
            pVar->nactual = numRead;
            bptr = tptr + 1;
        }
    }

    done:
    free(buffer);
    if (pVar->debugLevel > 0) {
        printMessage("XPS_trajectoryScan: readGathering:"
               " exit\n");
    }

    return;
}


static int trajectoryAbort(SS_ID ssId, struct UserVar *pVar)
{
    int status;

    status = GroupMoveAbort(pVar->abortSocket,pVar->groupName);
    if (status != 0)
        printMessage("Error performing GroupMoveAbort, status=%d\n", status);

    return (0);
}

static void printMessage(const char *pformat, ...)
{
    va_list pvar;
    FILE *fp = stdout;
    epicsTimeStamp now;
    char nowText[40];

    epicsTimeGetCurrent(&now);
    nowText[0] = 0;
    epicsTimeToStrftime(nowText,sizeof(nowText),
         "%Y/%m/%d %H:%M:%S.%03f",&now);
    fprintf(fp,"%s ",nowText);
    va_start(pvar, pformat);
    vfprintf(fp,pformat,pvar);
    va_end(pvar);
    fflush(fp);
}



/* Register sequencer commands and program */
#include "epicsExport.h"
static void XPS_trajectoryScanRegistrar (void) {
    seqRegisterSequencerCommands();
    seqRegisterSequencerProgram (&XPS_trajectoryScan);
}
epicsExportRegistrar(XPS_trajectoryScanRegistrar);
