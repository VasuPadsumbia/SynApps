/* C code for program EnsembleTrajectoryScan, generated by snc from ../EnsembleTrajectoryScan.st */
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>

#include "seq_snc.h"
# line 24 "../EnsembleTrajectoryScan.st"
#include <stdlib.h>
# line 25 "../EnsembleTrajectoryScan.st"
#include <string.h>
# line 26 "../EnsembleTrajectoryScan.st"
#include <ctype.h>
# line 27 "../EnsembleTrajectoryScan.st"
#include <stdio.h>
# line 28 "../EnsembleTrajectoryScan.st"
#include <math.h>
# line 29 "../EnsembleTrajectoryScan.st"
#include <epicsString.h>
# line 30 "../EnsembleTrajectoryScan.st"
#include <epicsStdio.h>
# line 31 "../EnsembleTrajectoryScan.st"
#include <asynOctetSyncIO.h>
# line 159 "../EnsembleTrajectoryScan.h"
static const EF_ID pulsePositionsMon = 1;
# line 345 "../EnsembleTrajectoryScan.h"
static const EF_ID buildMon = 2;
# line 346 "../EnsembleTrajectoryScan.h"
static const EF_ID executeMon = 3;
# line 347 "../EnsembleTrajectoryScan.h"
static const EF_ID execStateMon = 4;
# line 348 "../EnsembleTrajectoryScan.h"
static const EF_ID abortMon = 5;
# line 349 "../EnsembleTrajectoryScan.h"
static const EF_ID readbackMon = 6;
# line 350 "../EnsembleTrajectoryScan.h"
static const EF_ID nelementsMon = 7;
# line 351 "../EnsembleTrajectoryScan.h"
static const EF_ID motorMDVSMon = 8;
# line 111 "../EnsembleTrajectoryScan.st"
epicsTimeStamp startTime;
# line 112 "../EnsembleTrajectoryScan.st"
epicsTimeStamp currTime;
# line 113 "../EnsembleTrajectoryScan.st"
epicsTimeStamp lastPollTime;
# line 115 "../EnsembleTrajectoryScan.st"
epicsTimeStamp pvtTime;
# line 116 "../EnsembleTrajectoryScan.st"
epicsTimeStamp lastPvtTime;
# line 119 "../EnsembleTrajectoryScan.st"
static int writeOnly(SS_ID ssId, struct UserVar *pVar, char *command);
# line 120 "../EnsembleTrajectoryScan.st"
static int writeRead(SS_ID ssId, struct UserVar *pVar, char *command, char *reply);
# line 121 "../EnsembleTrajectoryScan.st"
static int getMotorPositions(SS_ID ssId, struct UserVar *pVar, double *pos);
# line 122 "../EnsembleTrajectoryScan.st"
static int getMotorMoving(SS_ID ssId, struct UserVar *pVar, int movingMask);
# line 123 "../EnsembleTrajectoryScan.st"
static int getEpicsMotorMoving(SS_ID ssId, struct UserVar *pVar);
# line 124 "../EnsembleTrajectoryScan.st"
static int waitEpicsMotors(SS_ID ssId, struct UserVar *pVar);
# line 125 "../EnsembleTrajectoryScan.st"
static int buildTrajectory(SS_ID ssId, struct UserVar *pVar, double *timeTrajectory,
# line 126 "../EnsembleTrajectoryScan.st"
double *motorTrajectory, int epicsMotorDir, int moveMode, int npoints, int npulses, double motorOffset,
# line 127 "../EnsembleTrajectoryScan.st"
double motorResolution, double *velocity);
# line 128 "../EnsembleTrajectoryScan.st"
static int loadTrajectory(SS_ID ssId, struct UserVar *pVar);
# line 129 "../EnsembleTrajectoryScan.st"
static int userToRaw(double user, double off, int dir, double res);
# line 130 "../EnsembleTrajectoryScan.st"
static double rawToUser(int raw, double off, int dir, double res);
# line 131 "../EnsembleTrajectoryScan.st"
static int sendReceiveCommand(SS_ID ssId, struct UserVar *pVar, char *cmd, char *callerReply, int checkProgram);
# line 132 "../EnsembleTrajectoryScan.st"
static double trajEval(SS_ID ssId, struct UserVar *pVar, double *motorReadbacks, int scopeDataIntervalMS, int nScopeDataPoints,
# line 133 "../EnsembleTrajectoryScan.st"
double *motorTrajectory, double *realTimeTrajectory, int npoints, double *motorError);
# line 134 "../EnsembleTrajectoryScan.st"
int writeDoubleAndCheck(SS_ID ssId, struct UserVar *pVar, int n, double d);
# line 135 "../EnsembleTrajectoryScan.st"
int writeIntAndCheck(SS_ID ssId, struct UserVar *pVar, int n, int ival);
# line 170 "../EnsembleTrajectoryScan.st"
int encoder_runs_backwards=0;

/* Variable declarations */
struct seqg_vars {
# line 42 "../EnsembleTrajectoryScan.h"
	int debugLevel;
# line 44 "../EnsembleTrajectoryScan.h"
	int numAxes;
# line 46 "../EnsembleTrajectoryScan.h"
	int nelements;
# line 48 "../EnsembleTrajectoryScan.h"
	int npulses;
# line 50 "../EnsembleTrajectoryScan.h"
	int startPulses;
# line 52 "../EnsembleTrajectoryScan.h"
	int endPulses;
# line 54 "../EnsembleTrajectoryScan.h"
	int nactual;
# line 55 "../EnsembleTrajectoryScan.h"
	int moveMode;
# line 57 "../EnsembleTrajectoryScan.h"
	double time;
# line 59 "../EnsembleTrajectoryScan.h"
	double timeScale;
# line 61 "../EnsembleTrajectoryScan.h"
	int timeMode;
# line 63 "../EnsembleTrajectoryScan.h"
	double accel;
# line 65 "../EnsembleTrajectoryScan.h"
	int build;
# line 67 "../EnsembleTrajectoryScan.h"
	int buildState;
# line 68 "../EnsembleTrajectoryScan.h"
	int buildStatus;
# line 69 "../EnsembleTrajectoryScan.h"
	string buildMessage;
# line 70 "../EnsembleTrajectoryScan.h"
	int simMode;
# line 72 "../EnsembleTrajectoryScan.h"
	int execute;
# line 74 "../EnsembleTrajectoryScan.h"
	int execState;
# line 76 "../EnsembleTrajectoryScan.h"
	int execStatus;
# line 77 "../EnsembleTrajectoryScan.h"
	string execMessage;
# line 78 "../EnsembleTrajectoryScan.h"
	int abort;
# line 80 "../EnsembleTrajectoryScan.h"
	int readback;
# line 82 "../EnsembleTrajectoryScan.h"
	int readState;
# line 83 "../EnsembleTrajectoryScan.h"
	int readStatus;
# line 84 "../EnsembleTrajectoryScan.h"
	string readMessage;
# line 85 "../EnsembleTrajectoryScan.h"
	double timeTrajectory[1000];
# line 88 "../EnsembleTrajectoryScan.h"
	string trajectoryFile;
# line 94 "../EnsembleTrajectoryScan.h"
	double elapsedTime;
# line 97 "../EnsembleTrajectoryScan.h"
	double realTimeTrajectory[1000];
# line 101 "../EnsembleTrajectoryScan.h"
	double epicsMotorMres[8];
# line 106 "../EnsembleTrajectoryScan.h"
	int epicsMotorCard[8];
# line 111 "../EnsembleTrajectoryScan.h"
	double epicsMotorHLM[8];
# line 114 "../EnsembleTrajectoryScan.h"
	double epicsMotorLLM[8];
# line 118 "../EnsembleTrajectoryScan.h"
	double motorStart[8];
# line 129 "../EnsembleTrajectoryScan.h"
	int pulseDir;
# line 133 "../EnsembleTrajectoryScan.h"
	double pulseLenUS;
# line 137 "../EnsembleTrajectoryScan.h"
	int pulseSrc;
# line 149 "../EnsembleTrajectoryScan.h"
	double pulsePositions[8000];
# line 156 "../EnsembleTrajectoryScan.h"
	double newPulsePositions;
# line 162 "../EnsembleTrajectoryScan.h"
	int numPulsePositions;
# line 169 "../EnsembleTrajectoryScan.h"
	int pulseMode;
# line 175 "../EnsembleTrajectoryScan.h"
	int moveAxis[8];
# line 187 "../EnsembleTrajectoryScan.h"
	double motorTrajectory[8][1000];
# line 199 "../EnsembleTrajectoryScan.h"
	double motorReadbacks[8][8000];
# line 210 "../EnsembleTrajectoryScan.h"
	double motorError[8][8000];
# line 221 "../EnsembleTrajectoryScan.h"
	double motorCurrent[8];
# line 232 "../EnsembleTrajectoryScan.h"
	double motorMDVS[8];
# line 244 "../EnsembleTrajectoryScan.h"
	double motorMDVA[8];
# line 255 "../EnsembleTrajectoryScan.h"
	int motorMDVE[8];
# line 266 "../EnsembleTrajectoryScan.h"
	double motorMVA[8];
# line 277 "../EnsembleTrajectoryScan.h"
	int motorMVE[8];
# line 288 "../EnsembleTrajectoryScan.h"
	double motorMAA[8];
# line 299 "../EnsembleTrajectoryScan.h"
	int motorMAE[8];
# line 312 "../EnsembleTrajectoryScan.h"
	double epicsMotorPos[8];
# line 316 "../EnsembleTrajectoryScan.h"
	int epicsMotorDir[8];
# line 320 "../EnsembleTrajectoryScan.h"
	double epicsMotorOff[8];
# line 324 "../EnsembleTrajectoryScan.h"
	double epicsMotorDone[8];
# line 328 "../EnsembleTrajectoryScan.h"
	double epicsMotorVELO[8];
# line 332 "../EnsembleTrajectoryScan.h"
	double epicsMotorVMAX[8];
# line 336 "../EnsembleTrajectoryScan.h"
	double epicsMotorVMIN[8];
# line 340 "../EnsembleTrajectoryScan.h"
	double epicsMotorACCL[8];
# line 75 "../EnsembleTrajectoryScan.st"
	char stringOut[100];
# line 76 "../EnsembleTrajectoryScan.st"
	char stringIn[100];
# line 77 "../EnsembleTrajectoryScan.st"
	char stringLast[100];
# line 78 "../EnsembleTrajectoryScan.st"
	char abortCommand[100];
# line 79 "../EnsembleTrajectoryScan.st"
	char *asynPort;
# line 80 "../EnsembleTrajectoryScan.st"
	char *pasynUser;
# line 81 "../EnsembleTrajectoryScan.st"
	int status;
# line 82 "../EnsembleTrajectoryScan.st"
	int i;
# line 83 "../EnsembleTrajectoryScan.st"
	int j;
# line 84 "../EnsembleTrajectoryScan.st"
	int k;
# line 85 "../EnsembleTrajectoryScan.st"
	int n;
# line 86 "../EnsembleTrajectoryScan.st"
	int anyMoving;
# line 87 "../EnsembleTrajectoryScan.st"
	int npoints;
# line 88 "../EnsembleTrajectoryScan.st"
	double dtime;
# line 89 "../EnsembleTrajectoryScan.st"
	double dpos;
# line 90 "../EnsembleTrajectoryScan.st"
	double posActual;
# line 91 "../EnsembleTrajectoryScan.st"
	double expectedTime;
# line 92 "../EnsembleTrajectoryScan.st"
	double initialPos[8];
# line 93 "../EnsembleTrajectoryScan.st"
	char macroBuf[100];
# line 94 "../EnsembleTrajectoryScan.st"
	char motorName[100];
# line 95 "../EnsembleTrajectoryScan.st"
	int initStatus;
# line 96 "../EnsembleTrajectoryScan.st"
	int limitViolation;
# line 97 "../EnsembleTrajectoryScan.st"
	int loadingTrajectory;
# line 101 "../EnsembleTrajectoryScan.st"
	int motorCurrentIndex[8];
# line 102 "../EnsembleTrajectoryScan.st"
	int epicsMotorDoneIndex[8];
# line 103 "../EnsembleTrajectoryScan.st"
	int elapsedTimeIndex;
# line 109 "../EnsembleTrajectoryScan.st"
	int abortState;
# line 136 "../EnsembleTrajectoryScan.st"
	double position[8][1000];
# line 137 "../EnsembleTrajectoryScan.st"
	double velocity[8][1000];
# line 139 "../EnsembleTrajectoryScan.st"
	double motorCurr[8];
# line 140 "../EnsembleTrajectoryScan.st"
	double motorPosOffset[8];
# line 143 "../EnsembleTrajectoryScan.st"
	int movingMask;
# line 144 "../EnsembleTrajectoryScan.st"
	int numGlobalDoubles;
# line 145 "../EnsembleTrajectoryScan.st"
	int numGlobalIntegers;
# line 148 "../EnsembleTrajectoryScan.st"
	double vmax;
# line 149 "../EnsembleTrajectoryScan.st"
	double amax;
# line 150 "../EnsembleTrajectoryScan.st"
	double d;
# line 150 "../EnsembleTrajectoryScan.st"
	double dlast;
# line 156 "../EnsembleTrajectoryScan.st"
	int nScopeDataPoints;
# line 157 "../EnsembleTrajectoryScan.st"
	int scopeDataIntervalMS;
# line 172 "../EnsembleTrajectoryScan.st"
	int pulsePositionsLoaded;
# line 173 "../EnsembleTrajectoryScan.st"
	int numPulsePositionsLoaded;
};


/* Function declarations */

#define seqg_var (*(struct seqg_vars *const *)seqg_env)

/* Program init func */
static void seqg_init(PROG_ID seqg_env)
{
}

/****** Code for state "init" in state set "EnsembleTrajectoryScan" ******/

/* Event function for state "init" in state set "EnsembleTrajectoryScan" */
static seqBool seqg_event_EnsembleTrajectoryScan_0_init(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "init" in state set "EnsembleTrajectoryScan" */
static void seqg_action_EnsembleTrajectoryScan_0_init(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 180 "../EnsembleTrajectoryScan.st"
			if (seqg_var->debugLevel)
# line 180 "../EnsembleTrajectoryScan.st"
				printf("EnsembleTrajectoryScan:init: entry\n");
# line 181 "../EnsembleTrajectoryScan.st"
			seqg_var->initStatus = 0;
# line 183 "../EnsembleTrajectoryScan.st"
			if (seqg_var->numAxes > 8)
# line 183 "../EnsembleTrajectoryScan.st"
				seqg_var->numAxes = 8;
# line 184 "../EnsembleTrajectoryScan.st"
			for (seqg_var->i = 0; seqg_var->i < seqg_var->numAxes; seqg_var->i++)
			{
# line 185 "../EnsembleTrajectoryScan.st"
				sprintf(seqg_var->macroBuf, "M%d", seqg_var->i + 1);
# line 187 "../EnsembleTrajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.VAL", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 188 "../EnsembleTrajectoryScan.st"
				seq_pvAssign(seqg_env, 173/*epicsMotorPos*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 189 "../EnsembleTrajectoryScan.st"
				seq_pvMonitor(seqg_env, 173/*epicsMotorPos*/ + (CH_ID)(seqg_var->i));
# line 191 "../EnsembleTrajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.DIR", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 192 "../EnsembleTrajectoryScan.st"
				seq_pvAssign(seqg_env, 181/*epicsMotorDir*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 193 "../EnsembleTrajectoryScan.st"
				seq_pvMonitor(seqg_env, 181/*epicsMotorDir*/ + (CH_ID)(seqg_var->i));
# line 195 "../EnsembleTrajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.OFF", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 196 "../EnsembleTrajectoryScan.st"
				seq_pvAssign(seqg_env, 189/*epicsMotorOff*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 197 "../EnsembleTrajectoryScan.st"
				seq_pvMonitor(seqg_env, 189/*epicsMotorOff*/ + (CH_ID)(seqg_var->i));
# line 199 "../EnsembleTrajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.DMOV", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 200 "../EnsembleTrajectoryScan.st"
				seq_pvAssign(seqg_env, 197/*epicsMotorDone*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 201 "../EnsembleTrajectoryScan.st"
				seq_pvMonitor(seqg_env, 197/*epicsMotorDone*/ + (CH_ID)(seqg_var->i));
# line 203 "../EnsembleTrajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.MRES", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 204 "../EnsembleTrajectoryScan.st"
				seq_pvAssign(seqg_env, 30/*epicsMotorMres*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 205 "../EnsembleTrajectoryScan.st"
				seq_pvMonitor(seqg_env, 30/*epicsMotorMres*/ + (CH_ID)(seqg_var->i));
# line 207 "../EnsembleTrajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.CARD", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 208 "../EnsembleTrajectoryScan.st"
				seq_pvAssign(seqg_env, 38/*epicsMotorCard*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 209 "../EnsembleTrajectoryScan.st"
				seq_pvMonitor(seqg_env, 38/*epicsMotorCard*/ + (CH_ID)(seqg_var->i));
# line 211 "../EnsembleTrajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.HLM", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 212 "../EnsembleTrajectoryScan.st"
				seq_pvAssign(seqg_env, 46/*epicsMotorHLM*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 213 "../EnsembleTrajectoryScan.st"
				seq_pvMonitor(seqg_env, 46/*epicsMotorHLM*/ + (CH_ID)(seqg_var->i));
# line 215 "../EnsembleTrajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.LLM", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 216 "../EnsembleTrajectoryScan.st"
				seq_pvAssign(seqg_env, 54/*epicsMotorLLM*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 217 "../EnsembleTrajectoryScan.st"
				seq_pvMonitor(seqg_env, 54/*epicsMotorLLM*/ + (CH_ID)(seqg_var->i));
# line 219 "../EnsembleTrajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.VELO", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 220 "../EnsembleTrajectoryScan.st"
				seq_pvAssign(seqg_env, 205/*epicsMotorVELO*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 221 "../EnsembleTrajectoryScan.st"
				seq_pvMonitor(seqg_env, 205/*epicsMotorVELO*/ + (CH_ID)(seqg_var->i));
# line 223 "../EnsembleTrajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.VMAX", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 224 "../EnsembleTrajectoryScan.st"
				seq_pvAssign(seqg_env, 213/*epicsMotorVMAX*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 225 "../EnsembleTrajectoryScan.st"
				seq_pvMonitor(seqg_env, 213/*epicsMotorVMAX*/ + (CH_ID)(seqg_var->i));
# line 227 "../EnsembleTrajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.VBAS", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 228 "../EnsembleTrajectoryScan.st"
				seq_pvAssign(seqg_env, 221/*epicsMotorVMIN*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 229 "../EnsembleTrajectoryScan.st"
				seq_pvMonitor(seqg_env, 221/*epicsMotorVMIN*/ + (CH_ID)(seqg_var->i));
# line 231 "../EnsembleTrajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.ACCL", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 232 "../EnsembleTrajectoryScan.st"
				seq_pvAssign(seqg_env, 229/*epicsMotorACCL*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 233 "../EnsembleTrajectoryScan.st"
				seq_pvMonitor(seqg_env, 229/*epicsMotorACCL*/ + (CH_ID)(seqg_var->i));
			}
# line 236 "../EnsembleTrajectoryScan.st"
			seqg_var->asynPort = seq_macValueGet(seqg_env, "PORT");
			pVar->status = pasynOctetSyncIO->connect(pVar->asynPort, 0, (asynUser **)&pVar->pasynUser, NULL);
# line 238 "../EnsembleTrajectoryScan.st"
			if (seqg_var->status != 0)
			{
# line 239 "../EnsembleTrajectoryScan.st"
				printf("trajectoryScan error in pasynOctetSyncIO->connect\n");
# line 240 "../EnsembleTrajectoryScan.st"
				printf("   status=%d, port=%s\n", seqg_var->status, seqg_var->asynPort);
			}
# line 242 "../EnsembleTrajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 243 "../EnsembleTrajectoryScan.st"
				seqg_var->motorCurrentIndex[seqg_var->j] = seq_pvIndex(seqg_env, 109/*motorCurrent*/ + (CH_ID)(seqg_var->j));
# line 244 "../EnsembleTrajectoryScan.st"
				seqg_var->epicsMotorDoneIndex[seqg_var->j] = seq_pvIndex(seqg_env, 197/*epicsMotorDone*/ + (CH_ID)(seqg_var->j));
# line 245 "../EnsembleTrajectoryScan.st"
				seqg_var->motorPosOffset[seqg_var->j] = 0.;
			}
# line 247 "../EnsembleTrajectoryScan.st"
			seqg_var->elapsedTimeIndex = seq_pvIndex(seqg_env, 28/*elapsedTime*/);
# line 248 "../EnsembleTrajectoryScan.st"
			seqg_var->abortState = 0;
# line 251 "../EnsembleTrajectoryScan.st"
			seq_efClear(seqg_env, buildMon);
# line 252 "../EnsembleTrajectoryScan.st"
			seq_efClear(seqg_env, executeMon);
# line 253 "../EnsembleTrajectoryScan.st"
			seq_efClear(seqg_env, abortMon);
# line 254 "../EnsembleTrajectoryScan.st"
			seq_efClear(seqg_env, readbackMon);
# line 255 "../EnsembleTrajectoryScan.st"
			seq_efClear(seqg_env, nelementsMon);
# line 256 "../EnsembleTrajectoryScan.st"
			seq_efClear(seqg_env, motorMDVSMon);
# line 261 "../EnsembleTrajectoryScan.st"
			seq_efClear(seqg_env, pulsePositionsMon);
# line 262 "../EnsembleTrajectoryScan.st"
			seq_pvGetTmo(seqg_env, 73/*pulsePositions*/, DEFAULT, DEFAULT_TIMEOUT);
# line 263 "../EnsembleTrajectoryScan.st"
			seqg_var->pulsePositionsLoaded = 0;
# line 264 "../EnsembleTrajectoryScan.st"
			seqg_var->numPulsePositionsLoaded = 0;
# line 266 "../EnsembleTrajectoryScan.st"
			if (seqg_var->initStatus == 0)
# line 266 "../EnsembleTrajectoryScan.st"
				seqg_var->initStatus = 1;
# line 267 "../EnsembleTrajectoryScan.st"
			seqg_var->loadingTrajectory = 0;
			pVar->status = writeRead(ssId, pVar, "getparm(125)", pVar->stringIn);
# line 271 "../EnsembleTrajectoryScan.st"
			if (seqg_var->stringIn[0] == '%')
			{
# line 272 "../EnsembleTrajectoryScan.st"
				seqg_var->numGlobalDoubles = atol(&seqg_var->stringIn[1]);
			}
			else
			{
				/* C code definitions */
# line 275 "../EnsembleTrajectoryScan.st"
				pVar->status = writeRead(ssId, pVar, "getparm(@0,125)", pVar->stringIn);
# line 276 "../EnsembleTrajectoryScan.st"
				if (seqg_var->stringIn[0] == '%')
				{
# line 277 "../EnsembleTrajectoryScan.st"
					seqg_var->numGlobalDoubles = atol(&seqg_var->stringIn[1]);
				}
				else
				{
# line 279 "../EnsembleTrajectoryScan.st"
					printf("Can't read number of global doubles.  Motor controller problem?\n");
# line 280 "../EnsembleTrajectoryScan.st"
					seqg_var->numGlobalDoubles = 0;
				}
			}
			pVar->status = writeRead(ssId, pVar, "getparm(124)", pVar->stringIn);
# line 286 "../EnsembleTrajectoryScan.st"
			if (seqg_var->stringIn[0] == '%')
			{
# line 287 "../EnsembleTrajectoryScan.st"
				seqg_var->numGlobalIntegers = atol(&seqg_var->stringIn[1]);
			}
			else
			{
				/* C code definitions */
# line 290 "../EnsembleTrajectoryScan.st"
				pVar->status = writeRead(ssId, pVar, "getparm(@0,124)", pVar->stringIn);
# line 291 "../EnsembleTrajectoryScan.st"
				if (seqg_var->stringIn[0] == '%')
				{
# line 292 "../EnsembleTrajectoryScan.st"
					seqg_var->numGlobalIntegers = atol(&seqg_var->stringIn[1]);
				}
				else
				{
# line 294 "../EnsembleTrajectoryScan.st"
					printf("Can't read number of global integers.  Motor controller problem?\n");
# line 295 "../EnsembleTrajectoryScan.st"
					seqg_var->numGlobalIntegers = 0;
				}
			}
# line 298 "../EnsembleTrajectoryScan.st"
			if (seqg_var->debugLevel)
# line 298 "../EnsembleTrajectoryScan.st"
				printf("EnsembleTrajectoryScan:init: done; going to 'monitor_inputs'\n");
		}
		return;
	}
}

/****** Code for state "monitor_inputs" in state set "EnsembleTrajectoryScan" ******/

/* Entry function for state "monitor_inputs" in state set "EnsembleTrajectoryScan" */
static void seqg_entry_EnsembleTrajectoryScan_0_monitor_inputs(SS_ID seqg_env)
{
# line 306 "../EnsembleTrajectoryScan.st"
	if (seqg_var->debugLevel)
# line 306 "../EnsembleTrajectoryScan.st"
		printf("EnsembleTrajectoryScan:monitor_inputs: entry\n");
}

/* Event function for state "monitor_inputs" in state set "EnsembleTrajectoryScan" */
static seqBool seqg_event_EnsembleTrajectoryScan_0_monitor_inputs(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 308 "../EnsembleTrajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, buildMon) && (seqg_var->build == 1) && (seqg_var->initStatus == 1))
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 311 "../EnsembleTrajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, executeMon) && (seqg_var->execute == 1) && ((seqg_var->buildStatus == 1) || (seqg_var->buildStatus == 5)))
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 314 "../EnsembleTrajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, readbackMon) && (seqg_var->readback == 1))
	{
		*seqg_pnst = 5;
		*seqg_ptrn = 2;
		return TRUE;
	}
# line 318 "../EnsembleTrajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, nelementsMon) && (seqg_var->nelements >= 1))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 3;
		return TRUE;
	}
# line 333 "../EnsembleTrajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, pulsePositionsMon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 4;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "monitor_inputs" in state set "EnsembleTrajectoryScan" */
static void seqg_action_EnsembleTrajectoryScan_0_monitor_inputs(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
		}
		return;
	case 1:
		{
		}
		return;
	case 2:
		{
# line 315 "../EnsembleTrajectoryScan.st"
			if (seqg_var->debugLevel > 1)
# line 315 "../EnsembleTrajectoryScan.st"
				printf("readback command detected\n");
		}
		return;
	case 3:
		{
# line 322 "../EnsembleTrajectoryScan.st"
			if (seqg_var->nelements > (seqg_var->numGlobalDoubles / 3 - 3))
			{
# line 326 "../EnsembleTrajectoryScan.st"
				seqg_var->nelements = seqg_var->numGlobalDoubles / 3 - 3;
# line 327 "../EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 2/*nelements*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 329 "../EnsembleTrajectoryScan.st"
			seqg_var->endPulses = seqg_var->nelements;
# line 330 "../EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 5/*endPulses*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 4:
		{
# line 334 "../EnsembleTrajectoryScan.st"
			if (seqg_var->debugLevel)
# line 334 "../EnsembleTrajectoryScan.st"
				printf("EnsembleTrajectoryScan:monitor_inputs: pvGet(pulsePositions)\n");
# line 335 "../EnsembleTrajectoryScan.st"
			epicsThreadSleep(1.);
# line 336 "../EnsembleTrajectoryScan.st"
			seq_pvGetTmo(seqg_env, 73/*pulsePositions*/, DEFAULT, DEFAULT_TIMEOUT);
# line 337 "../EnsembleTrajectoryScan.st"
			if (seqg_var->debugLevel > 1)
			{
# line 338 "../EnsembleTrajectoryScan.st"
				printf("EnsembleTrajectoryScan: new pulse positions detected\n");
# line 339 "../EnsembleTrajectoryScan.st"
				printf("...%lf, %lf...\n", seqg_var->pulsePositions[0], seqg_var->pulsePositions[1]);
			}
# line 341 "../EnsembleTrajectoryScan.st"
			seqg_var->pulsePositionsLoaded = 0;
# line 342 "../EnsembleTrajectoryScan.st"
			seqg_var->numPulsePositionsLoaded = 0;
		}
		return;
	}
}

/****** Code for state "build" in state set "EnsembleTrajectoryScan" ******/

/* Event function for state "build" in state set "EnsembleTrajectoryScan" */
static seqBool seqg_event_EnsembleTrajectoryScan_0_build(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "build" in state set "EnsembleTrajectoryScan" */
static void seqg_action_EnsembleTrajectoryScan_0_build(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 350 "../EnsembleTrajectoryScan.st"
			seqg_var->buildState = 1;
# line 351 "../EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 13/*buildState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 352 "../EnsembleTrajectoryScan.st"
			seqg_var->buildStatus = 0;
# line 353 "../EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 14/*buildStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 354 "../EnsembleTrajectoryScan.st"
			epicsSnprintf(seqg_var->buildMessage, 40, "Building...");
# line 355 "../EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 15/*buildMessage*/, DEFAULT, DEFAULT_TIMEOUT);
# line 357 "../EnsembleTrajectoryScan.st"
			seqg_var->buildStatus = 1;
# line 360 "../EnsembleTrajectoryScan.st"
			if (seqg_var->timeMode == 0)
			{
# line 361 "../EnsembleTrajectoryScan.st"
				seqg_var->dtime = seqg_var->time / (seqg_var->nelements - 1);
# line 362 "../EnsembleTrajectoryScan.st"
				for (seqg_var->i = 0; seqg_var->i < seqg_var->nelements; seqg_var->i++)
# line 362 "../EnsembleTrajectoryScan.st"
					seqg_var->timeTrajectory[seqg_var->i] = seqg_var->dtime;
# line 363 "../EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 26/*timeTrajectory*/, DEFAULT, DEFAULT_TIMEOUT);
			}
			else
			{
# line 365 "../EnsembleTrajectoryScan.st"
				for (seqg_var->i = 0 , seqg_var->time = 0.; seqg_var->i < seqg_var->nelements; seqg_var->i++)
				{
# line 366 "../EnsembleTrajectoryScan.st"
					seqg_var->time += seqg_var->timeTrajectory[seqg_var->i];
				}
# line 368 "../EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 8/*time*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 371 "../EnsembleTrajectoryScan.st"
			seqg_var->npoints = seqg_var->nelements;
# line 374 "../EnsembleTrajectoryScan.st"
			seqg_var->realTimeTrajectory[0] = 0.;
# line 375 "../EnsembleTrajectoryScan.st"
			for (seqg_var->i = 1; seqg_var->i < seqg_var->npoints; seqg_var->i++)
			{
# line 376 "../EnsembleTrajectoryScan.st"
				seqg_var->realTimeTrajectory[seqg_var->i] = seqg_var->realTimeTrajectory[seqg_var->i - 1] + seqg_var->timeTrajectory[seqg_var->i];
			}
# line 378 "../EnsembleTrajectoryScan.st"
			for (seqg_var->i = 0; seqg_var->i < seqg_var->npoints; seqg_var->i++)
# line 378 "../EnsembleTrajectoryScan.st"
				seqg_var->realTimeTrajectory[seqg_var->i] *= seqg_var->timeScale;
# line 381 "../EnsembleTrajectoryScan.st"
			for (; seqg_var->i < 1000; seqg_var->i++)
# line 381 "../EnsembleTrajectoryScan.st"
				seqg_var->realTimeTrajectory[seqg_var->i] = seqg_var->realTimeTrajectory[seqg_var->i - 1];
# line 382 "../EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 29/*realTimeTrajectory*/, DEFAULT, DEFAULT_TIMEOUT);
# line 385 "../EnsembleTrajectoryScan.st"
			seqg_var->n = sprintf(seqg_var->abortCommand, "ABORT");
# line 386 "../EnsembleTrajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < 8; seqg_var->j++)
			{
# line 387 "../EnsembleTrajectoryScan.st"
				if (seqg_var->moveAxis[seqg_var->j])
				{
					/* C code definitions */
# line 388 "../EnsembleTrajectoryScan.st"
					buildTrajectory(ssId, pVar, pVar->realTimeTrajectory, pVar->motorTrajectory[pVar->j],
# line 389 "../EnsembleTrajectoryScan.st"
					pVar->epicsMotorDir[pVar->j], pVar->moveMode, pVar->npoints, pVar->npulses,
# line 390 "../EnsembleTrajectoryScan.st"
					pVar->epicsMotorOff[pVar->j], pVar->epicsMotorMres[pVar->j], pVar->velocity[pVar->j]);
# line 391 "../EnsembleTrajectoryScan.st"
					seqg_var->n += sprintf(&seqg_var->abortCommand[seqg_var->n], " @%d", seqg_var->j);
				}
			}
# line 396 "../EnsembleTrajectoryScan.st"
			seqg_var->expectedTime = seqg_var->realTimeTrajectory[seqg_var->npoints - 1];
# line 399 "../EnsembleTrajectoryScan.st"
			seqg_var->limitViolation = 0;
# line 400 "../EnsembleTrajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes && !seqg_var->limitViolation; seqg_var->j++)
			{
# line 401 "../EnsembleTrajectoryScan.st"
				if (seqg_var->moveAxis[seqg_var->j])
				{
# line 402 "../EnsembleTrajectoryScan.st"
					seqg_var->vmax = seqg_var->epicsMotorVMAX[seqg_var->j];
# line 403 "../EnsembleTrajectoryScan.st"
					if (fabs(seqg_var->vmax) < .001)
# line 403 "../EnsembleTrajectoryScan.st"
						seqg_var->vmax = seqg_var->epicsMotorVELO[seqg_var->j];
# line 404 "../EnsembleTrajectoryScan.st"
					if (seqg_var->debugLevel > 1)
# line 404 "../EnsembleTrajectoryScan.st"
						printf("vmax=%f\n", seqg_var->vmax);
# line 405 "../EnsembleTrajectoryScan.st"
					seqg_var->amax = seqg_var->vmax / seqg_var->epicsMotorACCL[seqg_var->j];
# line 406 "../EnsembleTrajectoryScan.st"
					seqg_var->motorMVA[seqg_var->j] = 0.;
# line 407 "../EnsembleTrajectoryScan.st"
					seqg_var->motorMAA[seqg_var->j] = 0.;
# line 408 "../EnsembleTrajectoryScan.st"
					for (seqg_var->k = 0; seqg_var->k < seqg_var->npoints && !seqg_var->limitViolation; seqg_var->k++)
					{
# line 409 "../EnsembleTrajectoryScan.st"
						seqg_var->posActual = seqg_var->motorTrajectory[seqg_var->j][seqg_var->k];
# line 410 "../EnsembleTrajectoryScan.st"
						if (seqg_var->moveMode != 1)
# line 410 "../EnsembleTrajectoryScan.st"
							seqg_var->posActual += seqg_var->epicsMotorPos[seqg_var->j];
# line 411 "../EnsembleTrajectoryScan.st"
						seqg_var->limitViolation |= (seqg_var->posActual > seqg_var->epicsMotorHLM[seqg_var->j]) || (seqg_var->posActual < seqg_var->epicsMotorLLM[seqg_var->j]);
# line 412 "../EnsembleTrajectoryScan.st"
						if (seqg_var->limitViolation)
						{
# line 413 "../EnsembleTrajectoryScan.st"
							epicsSnprintf(seqg_var->buildMessage, 40, "Limit: m%d at pt. %d (%f)", seqg_var->j + 1, seqg_var->k + 1, seqg_var->posActual);
						}
# line 415 "../EnsembleTrajectoryScan.st"
						if (seqg_var->velocity[seqg_var->j][seqg_var->k] > seqg_var->vmax)
						{
# line 416 "../EnsembleTrajectoryScan.st"
							seqg_var->limitViolation |= 1;
# line 418 "../EnsembleTrajectoryScan.st"
							epicsSnprintf(seqg_var->buildMessage, 40, "V limit: m%d at pt. %d (%f)", seqg_var->j + 1, seqg_var->k + 1, seqg_var->velocity[seqg_var->j][seqg_var->k]);
						}
# line 420 "../EnsembleTrajectoryScan.st"
						if (seqg_var->k > 1)
						{
# line 421 "../EnsembleTrajectoryScan.st"
							seqg_var->dtime = seqg_var->realTimeTrajectory[seqg_var->k] - seqg_var->realTimeTrajectory[seqg_var->k - 1];
# line 422 "../EnsembleTrajectoryScan.st"
							seqg_var->d = (seqg_var->velocity[seqg_var->j][seqg_var->k] - seqg_var->velocity[seqg_var->j][seqg_var->k - 1]) / seqg_var->dtime;
# line 423 "../EnsembleTrajectoryScan.st"
							if (fabs(seqg_var->d) > seqg_var->amax)
							{
# line 424 "../EnsembleTrajectoryScan.st"
								seqg_var->limitViolation |= 1;
# line 425 "../EnsembleTrajectoryScan.st"
								epicsSnprintf(seqg_var->buildMessage, 40, "A limit: m%d at pt. %d (%f)", seqg_var->j + 1, seqg_var->k + 1, seqg_var->d);
							}
# line 427 "../EnsembleTrajectoryScan.st"
							if ((seqg_var->dtime < .03) && (seqg_var->buildStatus != 5))
							{
# line 428 "../EnsembleTrajectoryScan.st"
								seqg_var->buildStatus = 5;
# line 429 "../EnsembleTrajectoryScan.st"
								epicsSnprintf(seqg_var->buildMessage, 40, "!! deltaT(=%.3f) < .03 at pt. %d", seqg_var->dtime, seqg_var->k + 1);
							}
						}
# line 432 "../EnsembleTrajectoryScan.st"
						seqg_var->motorMVA[seqg_var->j] = ((seqg_var->motorMVA[seqg_var->j]) > (fabs(seqg_var->velocity[seqg_var->j][seqg_var->k])) ? (seqg_var->motorMVA[seqg_var->j]) : (fabs(seqg_var->velocity[seqg_var->j][seqg_var->k])));
					}
# line 435 "../EnsembleTrajectoryScan.st"
					seq_pvPutTmo(seqg_env, 141/*motorMVA*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
# line 436 "../EnsembleTrajectoryScan.st"
					seq_pvPutTmo(seqg_env, 157/*motorMAA*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
				}
			}
# line 439 "../EnsembleTrajectoryScan.st"
			if (seqg_var->debugLevel > 1)
# line 439 "../EnsembleTrajectoryScan.st"
				printf("limitViolation=%d\n", seqg_var->limitViolation);
# line 440 "../EnsembleTrajectoryScan.st"
			if (seqg_var->limitViolation)
			{
# line 441 "../EnsembleTrajectoryScan.st"
				seqg_var->buildStatus = 2;
			}
# line 447 "../EnsembleTrajectoryScan.st"
			seqg_var->buildState = 0;
# line 448 "../EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 13/*buildState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 449 "../EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 14/*buildStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 450 "../EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 15/*buildMessage*/, DEFAULT, DEFAULT_TIMEOUT);
# line 453 "../EnsembleTrajectoryScan.st"
			seqg_var->build = 0;
# line 454 "../EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 12/*build*/, DEFAULT, DEFAULT_TIMEOUT);
# line 455 "../EnsembleTrajectoryScan.st"
			if (seqg_var->buildStatus == 1)
			{
# line 456 "../EnsembleTrajectoryScan.st"
				epicsSnprintf(seqg_var->buildMessage, 40, "Done");
# line 457 "../EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 15/*buildMessage*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	}
}

/****** Code for state "execute" in state set "EnsembleTrajectoryScan" ******/

/* Event function for state "execute" in state set "EnsembleTrajectoryScan" */
static seqBool seqg_event_EnsembleTrajectoryScan_0_execute(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 4;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "execute" in state set "EnsembleTrajectoryScan" */
static void seqg_action_EnsembleTrajectoryScan_0_execute(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 465 "../EnsembleTrajectoryScan.st"
			seqg_var->execState = 1;
# line 466 "../EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 18/*execState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 467 "../EnsembleTrajectoryScan.st"
			seqg_var->abortState = 0;
# line 468 "../EnsembleTrajectoryScan.st"
			seqg_var->execStatus = 0;
# line 469 "../EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 19/*execStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 471 "../EnsembleTrajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 472 "../EnsembleTrajectoryScan.st"
				for (seqg_var->i = 0; seqg_var->i < 8000; seqg_var->i++)
				{
# line 473 "../EnsembleTrajectoryScan.st"
					seqg_var->motorReadbacks[seqg_var->j][seqg_var->i] = 0.;
# line 474 "../EnsembleTrajectoryScan.st"
					seqg_var->motorError[seqg_var->j][seqg_var->i] = 0.;
				}
			}
# line 478 "../EnsembleTrajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 479 "../EnsembleTrajectoryScan.st"
				seqg_var->initialPos[seqg_var->j] = seqg_var->epicsMotorPos[seqg_var->j];
# line 480 "../EnsembleTrajectoryScan.st"
				seqg_var->motorStart[seqg_var->j] = seqg_var->motorTrajectory[seqg_var->j][0] - (seqg_var->velocity[seqg_var->j][0] * seqg_var->epicsMotorACCL[seqg_var->j]) / 2;
# line 481 "../EnsembleTrajectoryScan.st"
				if (seqg_var->moveMode != 1)
# line 481 "../EnsembleTrajectoryScan.st"
					seqg_var->motorStart[seqg_var->j] += seqg_var->epicsMotorPos[seqg_var->j];
# line 482 "../EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 62/*motorStart*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
			}
# line 485 "../EnsembleTrajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 486 "../EnsembleTrajectoryScan.st"
				if (seqg_var->moveAxis[seqg_var->j])
				{
# line 487 "../EnsembleTrajectoryScan.st"
					seqg_var->epicsMotorPos[seqg_var->j] = seqg_var->motorStart[seqg_var->j];
# line 488 "../EnsembleTrajectoryScan.st"
					seq_pvPutTmo(seqg_env, 173/*epicsMotorPos*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
# line 489 "../EnsembleTrajectoryScan.st"
					if (seqg_var->debugLevel > 0)
# line 489 "../EnsembleTrajectoryScan.st"
						printf("\nstate execute: moving motor %d to %f\n", seqg_var->j, seqg_var->epicsMotorPos[seqg_var->j]);
				}
			}
			waitEpicsMotors(ssId, pVar);
			getMotorPositions(ssId, pVar, pVar->motorCurr);
# line 496 "../EnsembleTrajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 497 "../EnsembleTrajectoryScan.st"
				if (seqg_var->moveAxis[seqg_var->j])
				{
# line 498 "../EnsembleTrajectoryScan.st"
					if (fabs(seqg_var->motorCurr[seqg_var->j] - seqg_var->motorStart[seqg_var->j]) > .01)
					{
# line 499 "../EnsembleTrajectoryScan.st"
						printf("state execute: motor %d didn't move to start\n", seqg_var->j);
# line 500 "../EnsembleTrajectoryScan.st"
						if (seqg_var->execStatus != 3)
						{
# line 501 "../EnsembleTrajectoryScan.st"
							seqg_var->execStatus = 3;
							pVar->status = writeRead(ssId, pVar, pVar->abortCommand, pVar->stringIn);
# line 503 "../EnsembleTrajectoryScan.st"
							seqg_var->abortState = 2;
# line 504 "../EnsembleTrajectoryScan.st"
							if (seqg_var->debugLevel)
# line 504 "../EnsembleTrajectoryScan.st"
								printf("abort: sent command '%s'\n", seqg_var->abortCommand);
						}
					}
				}
			}
# line 510 "../EnsembleTrajectoryScan.st"
			if (seqg_var->execStatus != 3)
			{
				/* C code definitions */
# line 512 "../EnsembleTrajectoryScan.st"
				getMotorPositions(ssId, pVar, pVar->motorStart);
# line 513 "../EnsembleTrajectoryScan.st"
				epicsTimeGetCurrent(&lastPollTime);
# line 516 "../EnsembleTrajectoryScan.st"
				seqg_var->elapsedTime = 0.;
# line 517 "../EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 28/*elapsedTime*/, DEFAULT, DEFAULT_TIMEOUT);
				epicsTimeGetCurrent(&startTime);
# line 519 "../EnsembleTrajectoryScan.st"
				seqg_var->execState = 2;
# line 520 "../EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 18/*execState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 521 "../EnsembleTrajectoryScan.st"
				for (seqg_var->j = 0 , seqg_var->movingMask = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
				{
# line 522 "../EnsembleTrajectoryScan.st"
					if (seqg_var->moveAxis[seqg_var->j])
# line 522 "../EnsembleTrajectoryScan.st"
						seqg_var->movingMask |= (1 << seqg_var->j);
				}
# line 527 "../EnsembleTrajectoryScan.st"
				for (seqg_var->i = 0; seqg_var->i < 10; seqg_var->i++)
				{
					/* C code definitions */
# line 528 "../EnsembleTrajectoryScan.st"
					pVar->status = loadTrajectory(ssId, pVar);
# line 529 "../EnsembleTrajectoryScan.st"
					if (seqg_var->status == -2)
					{
# line 530 "../EnsembleTrajectoryScan.st"
						printf("Trying trajectory again\n");
					}
					else
					{
						break;
					}
				}
			}
		}
		return;
	}
}

/****** Code for state "wait_execute" in state set "EnsembleTrajectoryScan" ******/

/* Event function for state "wait_execute" in state set "EnsembleTrajectoryScan" */
static seqBool seqg_event_EnsembleTrajectoryScan_0_wait_execute(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 542 "../EnsembleTrajectoryScan.st"
	if (seqg_var->execStatus == 3)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 554 "../EnsembleTrajectoryScan.st"
	if ((seqg_var->execState == 2) && seq_delay(seqg_env, 0.1))
	{
		*seqg_pnst = 4;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 595 "../EnsembleTrajectoryScan.st"
	if (seqg_var->execState == 3)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 2;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "wait_execute" in state set "EnsembleTrajectoryScan" */
static void seqg_action_EnsembleTrajectoryScan_0_wait_execute(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 546 "../EnsembleTrajectoryScan.st"
			seqg_var->execState = 0;
# line 547 "../EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 18/*execState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 550 "../EnsembleTrajectoryScan.st"
			seqg_var->execute = 0;
# line 551 "../EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 17/*execute*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 1:
		{
			/* C code definitions */
# line 557 "../EnsembleTrajectoryScan.st"
			epicsTimeGetCurrent(&currTime);
# line 558 "../EnsembleTrajectoryScan.st"
			pVar->dtime = epicsTimeDiffInSeconds(&currTime, &lastPollTime);
# line 559 "../EnsembleTrajectoryScan.st"
			if (seqg_var->dtime > (1 / 5.))
			{
				/* C code definitions */
# line 560 "../EnsembleTrajectoryScan.st"
				pVar->elapsedTime = epicsTimeDiffInSeconds(&currTime, &startTime);
# line 561 "../EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 28/*elapsedTime*/, DEFAULT, DEFAULT_TIMEOUT);
				epicsTimeGetCurrent(&lastPollTime);
				getMotorPositions(ssId, pVar, pVar->motorCurrent);
# line 564 "../EnsembleTrajectoryScan.st"
				for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
				{
# line 565 "../EnsembleTrajectoryScan.st"
					if (seqg_var->moveAxis[seqg_var->j])
					{
# line 566 "../EnsembleTrajectoryScan.st"
						seq_pvPutTmo(seqg_env, 109/*motorCurrent*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
					}
				}
				pVar->anyMoving = getMotorMoving(ssId, pVar, pVar->movingMask);
# line 570 "../EnsembleTrajectoryScan.st"
				if (seqg_var->anyMoving == 0)
				{
# line 571 "../EnsembleTrajectoryScan.st"
					seqg_var->execState = 3;
# line 572 "../EnsembleTrajectoryScan.st"
					seqg_var->execStatus = 1;
# line 573 "../EnsembleTrajectoryScan.st"
					strcpy(seqg_var->execMessage, " ");
				}
# line 576 "../EnsembleTrajectoryScan.st"
				if (seqg_var->elapsedTime > seqg_var->expectedTime * 2.)
				{
# line 577 "../EnsembleTrajectoryScan.st"
					seqg_var->execState = 3;
# line 578 "../EnsembleTrajectoryScan.st"
					seqg_var->execStatus = 4;
# line 579 "../EnsembleTrajectoryScan.st"
					strcpy(seqg_var->execMessage, "Timeout");
					pVar->status = writeRead(ssId, pVar, pVar->abortCommand, pVar->stringIn);
# line 583 "../EnsembleTrajectoryScan.st"
					seqg_var->abortState = 2;
# line 584 "../EnsembleTrajectoryScan.st"
					if (seqg_var->debugLevel)
# line 584 "../EnsembleTrajectoryScan.st"
						printf("timeout: sent command '%s'\n", seqg_var->abortCommand);
# line 585 "../EnsembleTrajectoryScan.st"
					strcpy(seqg_var->stringOut, "PROGRAM STOP 1");
					pVar->status = writeRead(ssId, pVar, pVar->stringOut, pVar->stringIn);
					waitEpicsMotors(ssId, pVar);
# line 589 "../EnsembleTrajectoryScan.st"
					seqg_var->abortState = 3;
				}
			}
		}
		return;
	case 2:
		{
# line 596 "../EnsembleTrajectoryScan.st"
			if (seqg_var->debugLevel > 2)
# line 596 "../EnsembleTrajectoryScan.st"
				printf("flyback.\n");
# line 597 "../EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 28/*elapsedTime*/, DEFAULT, DEFAULT_TIMEOUT);
# line 598 "../EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 18/*execState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 599 "../EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 19/*execStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 600 "../EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 20/*execMessage*/, DEFAULT, DEFAULT_TIMEOUT);
# line 602 "../EnsembleTrajectoryScan.st"
			if (seqg_var->pulseMode != 3)
			{
# line 603 "../EnsembleTrajectoryScan.st"
				strcpy(seqg_var->stringOut, "PSOCONTROL @0 OFF");
				pVar->status = writeRead(ssId, pVar, pVar->stringOut, pVar->stringIn);
			}
# line 606 "../EnsembleTrajectoryScan.st"
			seqg_var->execState = 0;
# line 607 "../EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 18/*execState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 610 "../EnsembleTrajectoryScan.st"
			seqg_var->execute = 0;
# line 611 "../EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 17/*execute*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "readback" in state set "EnsembleTrajectoryScan" ******/

/* Entry function for state "readback" in state set "EnsembleTrajectoryScan" */
static void seqg_entry_EnsembleTrajectoryScan_0_readback(SS_ID seqg_env)
{
# line 618 "../EnsembleTrajectoryScan.st"
	if (seqg_var->debugLevel)
# line 618 "../EnsembleTrajectoryScan.st"
		printf("readback: entry\n");
}

/* Event function for state "readback" in state set "EnsembleTrajectoryScan" */
static seqBool seqg_event_EnsembleTrajectoryScan_0_readback(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "readback" in state set "EnsembleTrajectoryScan" */
static void seqg_action_EnsembleTrajectoryScan_0_readback(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 622 "../EnsembleTrajectoryScan.st"
			seqg_var->readState = 1;
# line 623 "../EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 23/*readState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 624 "../EnsembleTrajectoryScan.st"
			seqg_var->readStatus = 0;
# line 625 "../EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 24/*readStatus*/, DEFAULT, DEFAULT_TIMEOUT);
			pVar->status = sendReceiveCommand(ssId, pVar, "SCOPETRIG STOP", pVar->stringIn, 1);
# line 629 "../EnsembleTrajectoryScan.st"
			strcpy(seqg_var->stringLast, "");
# line 630 "../EnsembleTrajectoryScan.st"
			if (seqg_var->debugLevel)
# line 630 "../EnsembleTrajectoryScan.st"
				printf("state readback: motorPosOffset[0]=%f\n", seqg_var->motorPosOffset[0]);
# line 631 "../EnsembleTrajectoryScan.st"
			for (seqg_var->i = 0; seqg_var->i < seqg_var->nScopeDataPoints; seqg_var->i++)
			{
# line 632 "../EnsembleTrajectoryScan.st"
				if (seqg_var->execStatus == 3)
					break;
# line 633 "../EnsembleTrajectoryScan.st"
				sprintf(seqg_var->stringOut, "SCOPEDATA %d %d", 1, seqg_var->i);
				pVar->status = sendReceiveCommand(ssId, pVar, pVar->stringOut, pVar->stringIn, 0);
# line 635 "../EnsembleTrajectoryScan.st"
				sprintf(seqg_var->stringOut, "DGLOBAL(%d)", 1);
				pVar->status = writeRead(ssId, pVar, pVar->stringOut, pVar->stringIn);
# line 637 "../EnsembleTrajectoryScan.st"
				if (seqg_var->stringIn[0] == '%')
				{
# line 638 "../EnsembleTrajectoryScan.st"
					if (seqg_var->i == 0)
					{
# line 640 "../EnsembleTrajectoryScan.st"
						for (seqg_var->j = 0; seqg_var->j < 10; seqg_var->j++)
						{
# line 641 "../EnsembleTrajectoryScan.st"
							strcpy(seqg_var->stringLast, seqg_var->stringIn);
# line 642 "../EnsembleTrajectoryScan.st"
							sprintf(seqg_var->stringOut, "SCOPEDATA %d %d", 1, seqg_var->i);
							pVar->status = sendReceiveCommand(ssId, pVar, pVar->stringOut, pVar->stringIn, 0);
# line 644 "../EnsembleTrajectoryScan.st"
							sprintf(seqg_var->stringOut, "DGLOBAL(%d)", 1);
							pVar->status = writeRead(ssId, pVar, pVar->stringOut, pVar->stringIn);
# line 646 "../EnsembleTrajectoryScan.st"
							if (strcmp(seqg_var->stringIn, seqg_var->stringLast) == 0)
								break;
# line 647 "../EnsembleTrajectoryScan.st"
							if (seqg_var->debugLevel)
# line 647 "../EnsembleTrajectoryScan.st"
								printf("**%d\n", seqg_var->i);
						}
# line 649 "../EnsembleTrajectoryScan.st"
						if (seqg_var->j == 10)
# line 649 "../EnsembleTrajectoryScan.st"
							printf("abandoned read of point %d\n", seqg_var->i);
					}
					else
					{
# line 652 "../EnsembleTrajectoryScan.st"
						for (seqg_var->j = 0; seqg_var->j < 10 && (strcmp(seqg_var->stringIn, seqg_var->stringLast) == 0); seqg_var->j++)
						{
# line 653 "../EnsembleTrajectoryScan.st"
							if (seqg_var->debugLevel)
# line 653 "../EnsembleTrajectoryScan.st"
								printf("**%d\n", seqg_var->i);
# line 654 "../EnsembleTrajectoryScan.st"
							sprintf(seqg_var->stringOut, "SCOPEDATA %d %d", 1, seqg_var->i);
							pVar->status = sendReceiveCommand(ssId, pVar, pVar->stringOut, pVar->stringIn, 0);
# line 656 "../EnsembleTrajectoryScan.st"
							sprintf(seqg_var->stringOut, "DGLOBAL(%d)", 1);
							pVar->status = writeRead(ssId, pVar, pVar->stringOut, pVar->stringIn);
						}
# line 659 "../EnsembleTrajectoryScan.st"
						strcpy(seqg_var->stringLast, seqg_var->stringIn);
# line 660 "../EnsembleTrajectoryScan.st"
						if (seqg_var->j == 10)
# line 660 "../EnsembleTrajectoryScan.st"
							printf("abandoned read of point %d\n", seqg_var->i);
					}
# line 662 "../EnsembleTrajectoryScan.st"
					seqg_var->k = atoi(&seqg_var->stringIn[1]);
					if (encoder_runs_backwards) pVar->k *= -1;
# line 664 "../EnsembleTrajectoryScan.st"
					seqg_var->motorReadbacks[0][seqg_var->i] = seqg_var->k * seqg_var->epicsMotorMres[0] + seqg_var->motorPosOffset[0];
# line 665 "../EnsembleTrajectoryScan.st"
					seqg_var->motorError[0][seqg_var->i] = seqg_var->motorReadbacks[0][seqg_var->i] - seqg_var->motorTrajectory[0][seqg_var->i];
				}
			}
# line 668 "../EnsembleTrajectoryScan.st"
			for (; seqg_var->i < 8000; seqg_var->i++)
			{
# line 669 "../EnsembleTrajectoryScan.st"
				seqg_var->motorReadbacks[0][seqg_var->i] = 0;
# line 670 "../EnsembleTrajectoryScan.st"
				seqg_var->motorError[0][seqg_var->i] = 0;
			}
			pVar->d = trajEval(ssId, pVar, pVar->motorReadbacks[0], pVar->scopeDataIntervalMS, pVar->nScopeDataPoints,
			pVar->motorTrajectory[0], pVar->realTimeTrajectory, pVar->npoints, pVar->motorError[0]);
# line 697 "../EnsembleTrajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < 8; seqg_var->j++)
			{
# line 698 "../EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 93/*motorReadbacks*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
# line 699 "../EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 101/*motorError*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
			}
# line 702 "../EnsembleTrajectoryScan.st"
			seqg_var->readState = 0;
# line 703 "../EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 23/*readState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 705 "../EnsembleTrajectoryScan.st"
			seqg_var->readStatus = 1;
# line 706 "../EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 24/*readStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 707 "../EnsembleTrajectoryScan.st"
			strcpy(seqg_var->readMessage, " ");
# line 708 "../EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 25/*readMessage*/, DEFAULT, DEFAULT_TIMEOUT);
# line 711 "../EnsembleTrajectoryScan.st"
			seqg_var->readback = 0;
# line 712 "../EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 22/*readback*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "monitorAbort" in state set "trajectoryAbort" ******/

/* Event function for state "monitorAbort" in state set "trajectoryAbort" */
static seqBool seqg_event_trajectoryAbort_1_monitorAbort(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 723 "../EnsembleTrajectoryScan.st"
	if (seq_efTest(seqg_env, abortMon) && (seqg_var->abort == 1) && seq_delay(seqg_env, 0.1))
	{
		*seqg_pnst = 0;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "monitorAbort" in state set "trajectoryAbort" */
static void seqg_action_trajectoryAbort_1_monitorAbort(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 724 "../EnsembleTrajectoryScan.st"
			if (seqg_var->debugLevel)
# line 724 "../EnsembleTrajectoryScan.st"
				printf("trajectoryAbort: loadingTrajectory=%d\n", seqg_var->loadingTrajectory);
# line 725 "../EnsembleTrajectoryScan.st"
			seqg_var->abortState = 1;
# line 726 "../EnsembleTrajectoryScan.st"
			if (!seqg_var->loadingTrajectory)
			{
# line 727 "../EnsembleTrajectoryScan.st"
				seq_efClear(seqg_env, abortMon);
				pVar->status = writeRead(ssId, pVar, pVar->abortCommand, pVar->stringIn);
# line 729 "../EnsembleTrajectoryScan.st"
				if (seqg_var->debugLevel)
# line 729 "../EnsembleTrajectoryScan.st"
					printf("trajectoryAbort: sent command '%s'\n", seqg_var->abortCommand);
# line 730 "../EnsembleTrajectoryScan.st"
				seqg_var->abortState = 2;
# line 732 "../EnsembleTrajectoryScan.st"
				seqg_var->execStatus = 3;
# line 733 "../EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 19/*execStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 734 "../EnsembleTrajectoryScan.st"
				strcpy(seqg_var->execMessage, "Abort command sent");
# line 735 "../EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 20/*execMessage*/, DEFAULT, DEFAULT_TIMEOUT);
# line 736 "../EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 28/*elapsedTime*/, DEFAULT, DEFAULT_TIMEOUT);
# line 739 "../EnsembleTrajectoryScan.st"
				seqg_var->abort = 0;
# line 740 "../EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 21/*abort*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	}
}

#undef seqg_var

/************************ Tables ************************/

/* Channel table */
static seqChan seqg_chans[] = {
	/* chName, offset, varName, varType, count, eventNum, efId, monitored, queueSize, queueIndex */
	{"{P}{R}DebugLevel.VAL", offsetof(struct seqg_vars, debugLevel), "debugLevel", P_INT, 1, 9, 0, 1, 0, 0},
	{"{P}{R}NumAxes.VAL", offsetof(struct seqg_vars, numAxes), "numAxes", P_INT, 1, 10, 0, 1, 0, 0},
	{"{P}{R}Nelements.VAL", offsetof(struct seqg_vars, nelements), "nelements", P_INT, 1, 11, 7, 1, 0, 0},
	{"{P}{R}Npulses.VAL", offsetof(struct seqg_vars, npulses), "npulses", P_INT, 1, 12, 0, 1, 0, 0},
	{"{P}{R}StartPulses.VAL", offsetof(struct seqg_vars, startPulses), "startPulses", P_INT, 1, 13, 0, 1, 0, 0},
	{"{P}{R}EndPulses.VAL", offsetof(struct seqg_vars, endPulses), "endPulses", P_INT, 1, 14, 0, 1, 0, 0},
	{"{P}{R}Nactual.VAL", offsetof(struct seqg_vars, nactual), "nactual", P_INT, 1, 15, 0, 0, 0, 0},
	{"{P}{R}MoveMode.VAL", offsetof(struct seqg_vars, moveMode), "moveMode", P_INT, 1, 16, 0, 1, 0, 0},
	{"{P}{R}Time.VAL", offsetof(struct seqg_vars, time), "time", P_DOUBLE, 1, 17, 0, 1, 0, 0},
	{"{P}{R}TimeScale.VAL", offsetof(struct seqg_vars, timeScale), "timeScale", P_DOUBLE, 1, 18, 0, 1, 0, 0},
	{"{P}{R}TimeMode.VAL", offsetof(struct seqg_vars, timeMode), "timeMode", P_INT, 1, 19, 0, 1, 0, 0},
	{"{P}{R}Accel.VAL", offsetof(struct seqg_vars, accel), "accel", P_DOUBLE, 1, 20, 0, 1, 0, 0},
	{"{P}{R}Build.VAL", offsetof(struct seqg_vars, build), "build", P_INT, 1, 21, 2, 1, 0, 0},
	{"{P}{R}BuildState.VAL", offsetof(struct seqg_vars, buildState), "buildState", P_INT, 1, 22, 0, 0, 0, 0},
	{"{P}{R}BuildStatus.VAL", offsetof(struct seqg_vars, buildStatus), "buildStatus", P_INT, 1, 23, 0, 0, 0, 0},
	{"{P}{R}BuildMessage.VAL", offsetof(struct seqg_vars, buildMessage), "buildMessage", P_STRING, 1, 24, 0, 0, 0, 0},
	{"{P}{R}SimMode.VAL", offsetof(struct seqg_vars, simMode), "simMode", P_INT, 1, 25, 0, 1, 0, 0},
	{"{P}{R}Execute.VAL", offsetof(struct seqg_vars, execute), "execute", P_INT, 1, 26, 3, 1, 0, 0},
	{"{P}{R}ExecState.VAL", offsetof(struct seqg_vars, execState), "execState", P_INT, 1, 27, 4, 1, 0, 0},
	{"{P}{R}ExecStatus.VAL", offsetof(struct seqg_vars, execStatus), "execStatus", P_INT, 1, 28, 0, 0, 0, 0},
	{"{P}{R}ExecMessage.VAL", offsetof(struct seqg_vars, execMessage), "execMessage", P_STRING, 1, 29, 0, 0, 0, 0},
	{"{P}{R}Abort.VAL", offsetof(struct seqg_vars, abort), "abort", P_INT, 1, 30, 5, 1, 0, 0},
	{"{P}{R}Readback.VAL", offsetof(struct seqg_vars, readback), "readback", P_INT, 1, 31, 6, 1, 0, 0},
	{"{P}{R}ReadState.VAL", offsetof(struct seqg_vars, readState), "readState", P_INT, 1, 32, 0, 0, 0, 0},
	{"{P}{R}ReadStatus.VAL", offsetof(struct seqg_vars, readStatus), "readStatus", P_INT, 1, 33, 0, 0, 0, 0},
	{"{P}{R}ReadMessage.VAL", offsetof(struct seqg_vars, readMessage), "readMessage", P_STRING, 1, 34, 0, 0, 0, 0},
	{"{P}{R}TimeTraj.VAL", offsetof(struct seqg_vars, timeTrajectory), "timeTrajectory", P_DOUBLE, 1000, 35, 0, 1, 0, 0},
	{"{P}{R}TrajectoryFile.VAL", offsetof(struct seqg_vars, trajectoryFile), "trajectoryFile", P_STRING, 1, 36, 0, 1, 0, 0},
	{"{P}{R}ElapsedTime.VAL", offsetof(struct seqg_vars, elapsedTime), "elapsedTime", P_DOUBLE, 1, 37, 0, 0, 0, 0},
	{"{P}{R}realTimeTrajectory.VAL", offsetof(struct seqg_vars, realTimeTrajectory), "realTimeTrajectory", P_DOUBLE, 1000, 38, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorMres[0]), "epicsMotorMres[0]", P_DOUBLE, 1, 39, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorMres[1]), "epicsMotorMres[1]", P_DOUBLE, 1, 40, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorMres[2]), "epicsMotorMres[2]", P_DOUBLE, 1, 41, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorMres[3]), "epicsMotorMres[3]", P_DOUBLE, 1, 42, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorMres[4]), "epicsMotorMres[4]", P_DOUBLE, 1, 43, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorMres[5]), "epicsMotorMres[5]", P_DOUBLE, 1, 44, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorMres[6]), "epicsMotorMres[6]", P_DOUBLE, 1, 45, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorMres[7]), "epicsMotorMres[7]", P_DOUBLE, 1, 46, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorCard[0]), "epicsMotorCard[0]", P_INT, 1, 47, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorCard[1]), "epicsMotorCard[1]", P_INT, 1, 48, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorCard[2]), "epicsMotorCard[2]", P_INT, 1, 49, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorCard[3]), "epicsMotorCard[3]", P_INT, 1, 50, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorCard[4]), "epicsMotorCard[4]", P_INT, 1, 51, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorCard[5]), "epicsMotorCard[5]", P_INT, 1, 52, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorCard[6]), "epicsMotorCard[6]", P_INT, 1, 53, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorCard[7]), "epicsMotorCard[7]", P_INT, 1, 54, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorHLM[0]), "epicsMotorHLM[0]", P_DOUBLE, 1, 55, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorHLM[1]), "epicsMotorHLM[1]", P_DOUBLE, 1, 56, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorHLM[2]), "epicsMotorHLM[2]", P_DOUBLE, 1, 57, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorHLM[3]), "epicsMotorHLM[3]", P_DOUBLE, 1, 58, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorHLM[4]), "epicsMotorHLM[4]", P_DOUBLE, 1, 59, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorHLM[5]), "epicsMotorHLM[5]", P_DOUBLE, 1, 60, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorHLM[6]), "epicsMotorHLM[6]", P_DOUBLE, 1, 61, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorHLM[7]), "epicsMotorHLM[7]", P_DOUBLE, 1, 62, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorLLM[0]), "epicsMotorLLM[0]", P_DOUBLE, 1, 63, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorLLM[1]), "epicsMotorLLM[1]", P_DOUBLE, 1, 64, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorLLM[2]), "epicsMotorLLM[2]", P_DOUBLE, 1, 65, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorLLM[3]), "epicsMotorLLM[3]", P_DOUBLE, 1, 66, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorLLM[4]), "epicsMotorLLM[4]", P_DOUBLE, 1, 67, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorLLM[5]), "epicsMotorLLM[5]", P_DOUBLE, 1, 68, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorLLM[6]), "epicsMotorLLM[6]", P_DOUBLE, 1, 69, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorLLM[7]), "epicsMotorLLM[7]", P_DOUBLE, 1, 70, 0, 1, 0, 0},
	{"{P}{R}M1Start.VAL", offsetof(struct seqg_vars, motorStart[0]), "motorStart[0]", P_DOUBLE, 1, 71, 0, 0, 0, 0},
	{"{P}{R}M2Start.VAL", offsetof(struct seqg_vars, motorStart[1]), "motorStart[1]", P_DOUBLE, 1, 72, 0, 0, 0, 0},
	{"{P}{R}M3Start.VAL", offsetof(struct seqg_vars, motorStart[2]), "motorStart[2]", P_DOUBLE, 1, 73, 0, 0, 0, 0},
	{"{P}{R}M4Start.VAL", offsetof(struct seqg_vars, motorStart[3]), "motorStart[3]", P_DOUBLE, 1, 74, 0, 0, 0, 0},
	{"{P}{R}M5Start.VAL", offsetof(struct seqg_vars, motorStart[4]), "motorStart[4]", P_DOUBLE, 1, 75, 0, 0, 0, 0},
	{"{P}{R}M6Start.VAL", offsetof(struct seqg_vars, motorStart[5]), "motorStart[5]", P_DOUBLE, 1, 76, 0, 0, 0, 0},
	{"{P}{R}M7Start.VAL", offsetof(struct seqg_vars, motorStart[6]), "motorStart[6]", P_DOUBLE, 1, 77, 0, 0, 0, 0},
	{"{P}{R}M8Start.VAL", offsetof(struct seqg_vars, motorStart[7]), "motorStart[7]", P_DOUBLE, 1, 78, 0, 0, 0, 0},
	{"{P}{R}PulseDir", offsetof(struct seqg_vars, pulseDir), "pulseDir", P_INT, 1, 79, 0, 1, 0, 0},
	{"{P}{R}PulseLenUS", offsetof(struct seqg_vars, pulseLenUS), "pulseLenUS", P_DOUBLE, 1, 80, 0, 1, 0, 0},
	{"{P}{R}PulseSrc", offsetof(struct seqg_vars, pulseSrc), "pulseSrc", P_INT, 1, 81, 0, 1, 0, 0},
	{"{P}{R}PulsePositions.VAL", offsetof(struct seqg_vars, pulsePositions), "pulsePositions", P_DOUBLE, 8000, 82, 0, 0, 0, 0},
	{"{P}{R}NewPulsePositions.VAL", offsetof(struct seqg_vars, newPulsePositions), "newPulsePositions", P_DOUBLE, 1, 83, 1, 1, 0, 0},
	{"{P}{R}NumPulsePositions", offsetof(struct seqg_vars, numPulsePositions), "numPulsePositions", P_INT, 1, 84, 0, 1, 0, 0},
	{"{P}{R}PulseMode.VAL", offsetof(struct seqg_vars, pulseMode), "pulseMode", P_INT, 1, 85, 0, 1, 0, 0},
	{"{P}{R}M1Move.VAL", offsetof(struct seqg_vars, moveAxis[0]), "moveAxis[0]", P_INT, 1, 86, 0, 1, 0, 0},
	{"{P}{R}M2Move.VAL", offsetof(struct seqg_vars, moveAxis[1]), "moveAxis[1]", P_INT, 1, 87, 0, 1, 0, 0},
	{"{P}{R}M3Move.VAL", offsetof(struct seqg_vars, moveAxis[2]), "moveAxis[2]", P_INT, 1, 88, 0, 1, 0, 0},
	{"{P}{R}M4Move.VAL", offsetof(struct seqg_vars, moveAxis[3]), "moveAxis[3]", P_INT, 1, 89, 0, 1, 0, 0},
	{"{P}{R}M5Move.VAL", offsetof(struct seqg_vars, moveAxis[4]), "moveAxis[4]", P_INT, 1, 90, 0, 1, 0, 0},
	{"{P}{R}M6Move.VAL", offsetof(struct seqg_vars, moveAxis[5]), "moveAxis[5]", P_INT, 1, 91, 0, 1, 0, 0},
	{"{P}{R}M7Move.VAL", offsetof(struct seqg_vars, moveAxis[6]), "moveAxis[6]", P_INT, 1, 92, 0, 1, 0, 0},
	{"{P}{R}M8Move.VAL", offsetof(struct seqg_vars, moveAxis[7]), "moveAxis[7]", P_INT, 1, 93, 0, 1, 0, 0},
	{"{P}{R}M1Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[0]), "motorTrajectory[0]", P_DOUBLE, 1000, 94, 0, 1, 0, 0},
	{"{P}{R}M2Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[1]), "motorTrajectory[1]", P_DOUBLE, 1000, 95, 0, 1, 0, 0},
	{"{P}{R}M3Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[2]), "motorTrajectory[2]", P_DOUBLE, 1000, 96, 0, 1, 0, 0},
	{"{P}{R}M4Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[3]), "motorTrajectory[3]", P_DOUBLE, 1000, 97, 0, 1, 0, 0},
	{"{P}{R}M5Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[4]), "motorTrajectory[4]", P_DOUBLE, 1000, 98, 0, 1, 0, 0},
	{"{P}{R}M6Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[5]), "motorTrajectory[5]", P_DOUBLE, 1000, 99, 0, 1, 0, 0},
	{"{P}{R}M7Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[6]), "motorTrajectory[6]", P_DOUBLE, 1000, 100, 0, 1, 0, 0},
	{"{P}{R}M8Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[7]), "motorTrajectory[7]", P_DOUBLE, 1000, 101, 0, 1, 0, 0},
	{"{P}{R}M1Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[0]), "motorReadbacks[0]", P_DOUBLE, 8000, 102, 0, 0, 0, 0},
	{"{P}{R}M2Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[1]), "motorReadbacks[1]", P_DOUBLE, 8000, 103, 0, 0, 0, 0},
	{"{P}{R}M3Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[2]), "motorReadbacks[2]", P_DOUBLE, 8000, 104, 0, 0, 0, 0},
	{"{P}{R}M4Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[3]), "motorReadbacks[3]", P_DOUBLE, 8000, 105, 0, 0, 0, 0},
	{"{P}{R}M5Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[4]), "motorReadbacks[4]", P_DOUBLE, 8000, 106, 0, 0, 0, 0},
	{"{P}{R}M6Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[5]), "motorReadbacks[5]", P_DOUBLE, 8000, 107, 0, 0, 0, 0},
	{"{P}{R}M7Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[6]), "motorReadbacks[6]", P_DOUBLE, 8000, 108, 0, 0, 0, 0},
	{"{P}{R}M8Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[7]), "motorReadbacks[7]", P_DOUBLE, 8000, 109, 0, 0, 0, 0},
	{"{P}{R}M1Error.VAL", offsetof(struct seqg_vars, motorError[0]), "motorError[0]", P_DOUBLE, 8000, 110, 0, 0, 0, 0},
	{"{P}{R}M2Error.VAL", offsetof(struct seqg_vars, motorError[1]), "motorError[1]", P_DOUBLE, 8000, 111, 0, 0, 0, 0},
	{"{P}{R}M3Error.VAL", offsetof(struct seqg_vars, motorError[2]), "motorError[2]", P_DOUBLE, 8000, 112, 0, 0, 0, 0},
	{"{P}{R}M4Error.VAL", offsetof(struct seqg_vars, motorError[3]), "motorError[3]", P_DOUBLE, 8000, 113, 0, 0, 0, 0},
	{"{P}{R}M5Error.VAL", offsetof(struct seqg_vars, motorError[4]), "motorError[4]", P_DOUBLE, 8000, 114, 0, 0, 0, 0},
	{"{P}{R}M6Error.VAL", offsetof(struct seqg_vars, motorError[5]), "motorError[5]", P_DOUBLE, 8000, 115, 0, 0, 0, 0},
	{"{P}{R}M7Error.VAL", offsetof(struct seqg_vars, motorError[6]), "motorError[6]", P_DOUBLE, 8000, 116, 0, 0, 0, 0},
	{"{P}{R}M8Error.VAL", offsetof(struct seqg_vars, motorError[7]), "motorError[7]", P_DOUBLE, 8000, 117, 0, 0, 0, 0},
	{"{P}{R}M1Current.VAL", offsetof(struct seqg_vars, motorCurrent[0]), "motorCurrent[0]", P_DOUBLE, 1, 118, 0, 0, 0, 0},
	{"{P}{R}M2Current.VAL", offsetof(struct seqg_vars, motorCurrent[1]), "motorCurrent[1]", P_DOUBLE, 1, 119, 0, 0, 0, 0},
	{"{P}{R}M3Current.VAL", offsetof(struct seqg_vars, motorCurrent[2]), "motorCurrent[2]", P_DOUBLE, 1, 120, 0, 0, 0, 0},
	{"{P}{R}M4Current.VAL", offsetof(struct seqg_vars, motorCurrent[3]), "motorCurrent[3]", P_DOUBLE, 1, 121, 0, 0, 0, 0},
	{"{P}{R}M5Current.VAL", offsetof(struct seqg_vars, motorCurrent[4]), "motorCurrent[4]", P_DOUBLE, 1, 122, 0, 0, 0, 0},
	{"{P}{R}M6Current.VAL", offsetof(struct seqg_vars, motorCurrent[5]), "motorCurrent[5]", P_DOUBLE, 1, 123, 0, 0, 0, 0},
	{"{P}{R}M7Current.VAL", offsetof(struct seqg_vars, motorCurrent[6]), "motorCurrent[6]", P_DOUBLE, 1, 124, 0, 0, 0, 0},
	{"{P}{R}M8Current.VAL", offsetof(struct seqg_vars, motorCurrent[7]), "motorCurrent[7]", P_DOUBLE, 1, 125, 0, 0, 0, 0},
	{"{P}{R}M1MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[0]), "motorMDVS[0]", P_DOUBLE, 1, 126, 8, 1, 0, 0},
	{"{P}{R}M2MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[1]), "motorMDVS[1]", P_DOUBLE, 1, 127, 8, 1, 0, 0},
	{"{P}{R}M3MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[2]), "motorMDVS[2]", P_DOUBLE, 1, 128, 8, 1, 0, 0},
	{"{P}{R}M4MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[3]), "motorMDVS[3]", P_DOUBLE, 1, 129, 8, 1, 0, 0},
	{"{P}{R}M5MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[4]), "motorMDVS[4]", P_DOUBLE, 1, 130, 8, 1, 0, 0},
	{"{P}{R}M6MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[5]), "motorMDVS[5]", P_DOUBLE, 1, 131, 8, 1, 0, 0},
	{"{P}{R}M7MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[6]), "motorMDVS[6]", P_DOUBLE, 1, 132, 8, 1, 0, 0},
	{"{P}{R}M8MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[7]), "motorMDVS[7]", P_DOUBLE, 1, 133, 8, 1, 0, 0},
	{"{P}{R}M1MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[0]), "motorMDVA[0]", P_DOUBLE, 1, 134, 0, 0, 0, 0},
	{"{P}{R}M2MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[1]), "motorMDVA[1]", P_DOUBLE, 1, 135, 0, 0, 0, 0},
	{"{P}{R}M3MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[2]), "motorMDVA[2]", P_DOUBLE, 1, 136, 0, 0, 0, 0},
	{"{P}{R}M4MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[3]), "motorMDVA[3]", P_DOUBLE, 1, 137, 0, 0, 0, 0},
	{"{P}{R}M5MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[4]), "motorMDVA[4]", P_DOUBLE, 1, 138, 0, 0, 0, 0},
	{"{P}{R}M6MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[5]), "motorMDVA[5]", P_DOUBLE, 1, 139, 0, 0, 0, 0},
	{"{P}{R}M7MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[6]), "motorMDVA[6]", P_DOUBLE, 1, 140, 0, 0, 0, 0},
	{"{P}{R}M8MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[7]), "motorMDVA[7]", P_DOUBLE, 1, 141, 0, 0, 0, 0},
	{"{P}{R}M1MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[0]), "motorMDVE[0]", P_INT, 1, 142, 0, 0, 0, 0},
	{"{P}{R}M2MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[1]), "motorMDVE[1]", P_INT, 1, 143, 0, 0, 0, 0},
	{"{P}{R}M3MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[2]), "motorMDVE[2]", P_INT, 1, 144, 0, 0, 0, 0},
	{"{P}{R}M4MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[3]), "motorMDVE[3]", P_INT, 1, 145, 0, 0, 0, 0},
	{"{P}{R}M5MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[4]), "motorMDVE[4]", P_INT, 1, 146, 0, 0, 0, 0},
	{"{P}{R}M6MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[5]), "motorMDVE[5]", P_INT, 1, 147, 0, 0, 0, 0},
	{"{P}{R}M7MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[6]), "motorMDVE[6]", P_INT, 1, 148, 0, 0, 0, 0},
	{"{P}{R}M8MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[7]), "motorMDVE[7]", P_INT, 1, 149, 0, 0, 0, 0},
	{"{P}{R}M1MVA.VAL", offsetof(struct seqg_vars, motorMVA[0]), "motorMVA[0]", P_DOUBLE, 1, 150, 0, 0, 0, 0},
	{"{P}{R}M2MVA.VAL", offsetof(struct seqg_vars, motorMVA[1]), "motorMVA[1]", P_DOUBLE, 1, 151, 0, 0, 0, 0},
	{"{P}{R}M3MVA.VAL", offsetof(struct seqg_vars, motorMVA[2]), "motorMVA[2]", P_DOUBLE, 1, 152, 0, 0, 0, 0},
	{"{P}{R}M4MVA.VAL", offsetof(struct seqg_vars, motorMVA[3]), "motorMVA[3]", P_DOUBLE, 1, 153, 0, 0, 0, 0},
	{"{P}{R}M5MVA.VAL", offsetof(struct seqg_vars, motorMVA[4]), "motorMVA[4]", P_DOUBLE, 1, 154, 0, 0, 0, 0},
	{"{P}{R}M6MVA.VAL", offsetof(struct seqg_vars, motorMVA[5]), "motorMVA[5]", P_DOUBLE, 1, 155, 0, 0, 0, 0},
	{"{P}{R}M7MVA.VAL", offsetof(struct seqg_vars, motorMVA[6]), "motorMVA[6]", P_DOUBLE, 1, 156, 0, 0, 0, 0},
	{"{P}{R}M8MVA.VAL", offsetof(struct seqg_vars, motorMVA[7]), "motorMVA[7]", P_DOUBLE, 1, 157, 0, 0, 0, 0},
	{"{P}{R}M1MVE.VAL", offsetof(struct seqg_vars, motorMVE[0]), "motorMVE[0]", P_INT, 1, 158, 0, 0, 0, 0},
	{"{P}{R}M2MVE.VAL", offsetof(struct seqg_vars, motorMVE[1]), "motorMVE[1]", P_INT, 1, 159, 0, 0, 0, 0},
	{"{P}{R}M3MVE.VAL", offsetof(struct seqg_vars, motorMVE[2]), "motorMVE[2]", P_INT, 1, 160, 0, 0, 0, 0},
	{"{P}{R}M4MVE.VAL", offsetof(struct seqg_vars, motorMVE[3]), "motorMVE[3]", P_INT, 1, 161, 0, 0, 0, 0},
	{"{P}{R}M5MVE.VAL", offsetof(struct seqg_vars, motorMVE[4]), "motorMVE[4]", P_INT, 1, 162, 0, 0, 0, 0},
	{"{P}{R}M6MVE.VAL", offsetof(struct seqg_vars, motorMVE[5]), "motorMVE[5]", P_INT, 1, 163, 0, 0, 0, 0},
	{"{P}{R}M7MVE.VAL", offsetof(struct seqg_vars, motorMVE[6]), "motorMVE[6]", P_INT, 1, 164, 0, 0, 0, 0},
	{"{P}{R}M8MVE.VAL", offsetof(struct seqg_vars, motorMVE[7]), "motorMVE[7]", P_INT, 1, 165, 0, 0, 0, 0},
	{"{P}{R}M1MAA.VAL", offsetof(struct seqg_vars, motorMAA[0]), "motorMAA[0]", P_DOUBLE, 1, 166, 0, 0, 0, 0},
	{"{P}{R}M2MAA.VAL", offsetof(struct seqg_vars, motorMAA[1]), "motorMAA[1]", P_DOUBLE, 1, 167, 0, 0, 0, 0},
	{"{P}{R}M3MAA.VAL", offsetof(struct seqg_vars, motorMAA[2]), "motorMAA[2]", P_DOUBLE, 1, 168, 0, 0, 0, 0},
	{"{P}{R}M4MAA.VAL", offsetof(struct seqg_vars, motorMAA[3]), "motorMAA[3]", P_DOUBLE, 1, 169, 0, 0, 0, 0},
	{"{P}{R}M5MAA.VAL", offsetof(struct seqg_vars, motorMAA[4]), "motorMAA[4]", P_DOUBLE, 1, 170, 0, 0, 0, 0},
	{"{P}{R}M6MAA.VAL", offsetof(struct seqg_vars, motorMAA[5]), "motorMAA[5]", P_DOUBLE, 1, 171, 0, 0, 0, 0},
	{"{P}{R}M7MAA.VAL", offsetof(struct seqg_vars, motorMAA[6]), "motorMAA[6]", P_DOUBLE, 1, 172, 0, 0, 0, 0},
	{"{P}{R}M8MAA.VAL", offsetof(struct seqg_vars, motorMAA[7]), "motorMAA[7]", P_DOUBLE, 1, 173, 0, 0, 0, 0},
	{"{P}{R}M1MAE.VAL", offsetof(struct seqg_vars, motorMAE[0]), "motorMAE[0]", P_INT, 1, 174, 0, 0, 0, 0},
	{"{P}{R}M2MAE.VAL", offsetof(struct seqg_vars, motorMAE[1]), "motorMAE[1]", P_INT, 1, 175, 0, 0, 0, 0},
	{"{P}{R}M3MAE.VAL", offsetof(struct seqg_vars, motorMAE[2]), "motorMAE[2]", P_INT, 1, 176, 0, 0, 0, 0},
	{"{P}{R}M4MAE.VAL", offsetof(struct seqg_vars, motorMAE[3]), "motorMAE[3]", P_INT, 1, 177, 0, 0, 0, 0},
	{"{P}{R}M5MAE.VAL", offsetof(struct seqg_vars, motorMAE[4]), "motorMAE[4]", P_INT, 1, 178, 0, 0, 0, 0},
	{"{P}{R}M6MAE.VAL", offsetof(struct seqg_vars, motorMAE[5]), "motorMAE[5]", P_INT, 1, 179, 0, 0, 0, 0},
	{"{P}{R}M7MAE.VAL", offsetof(struct seqg_vars, motorMAE[6]), "motorMAE[6]", P_INT, 1, 180, 0, 0, 0, 0},
	{"{P}{R}M8MAE.VAL", offsetof(struct seqg_vars, motorMAE[7]), "motorMAE[7]", P_INT, 1, 181, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[0]), "epicsMotorPos[0]", P_DOUBLE, 1, 182, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[1]), "epicsMotorPos[1]", P_DOUBLE, 1, 183, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[2]), "epicsMotorPos[2]", P_DOUBLE, 1, 184, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[3]), "epicsMotorPos[3]", P_DOUBLE, 1, 185, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[4]), "epicsMotorPos[4]", P_DOUBLE, 1, 186, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[5]), "epicsMotorPos[5]", P_DOUBLE, 1, 187, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[6]), "epicsMotorPos[6]", P_DOUBLE, 1, 188, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[7]), "epicsMotorPos[7]", P_DOUBLE, 1, 189, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[0]), "epicsMotorDir[0]", P_INT, 1, 190, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[1]), "epicsMotorDir[1]", P_INT, 1, 191, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[2]), "epicsMotorDir[2]", P_INT, 1, 192, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[3]), "epicsMotorDir[3]", P_INT, 1, 193, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[4]), "epicsMotorDir[4]", P_INT, 1, 194, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[5]), "epicsMotorDir[5]", P_INT, 1, 195, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[6]), "epicsMotorDir[6]", P_INT, 1, 196, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[7]), "epicsMotorDir[7]", P_INT, 1, 197, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[0]), "epicsMotorOff[0]", P_DOUBLE, 1, 198, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[1]), "epicsMotorOff[1]", P_DOUBLE, 1, 199, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[2]), "epicsMotorOff[2]", P_DOUBLE, 1, 200, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[3]), "epicsMotorOff[3]", P_DOUBLE, 1, 201, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[4]), "epicsMotorOff[4]", P_DOUBLE, 1, 202, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[5]), "epicsMotorOff[5]", P_DOUBLE, 1, 203, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[6]), "epicsMotorOff[6]", P_DOUBLE, 1, 204, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[7]), "epicsMotorOff[7]", P_DOUBLE, 1, 205, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[0]), "epicsMotorDone[0]", P_DOUBLE, 1, 206, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[1]), "epicsMotorDone[1]", P_DOUBLE, 1, 207, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[2]), "epicsMotorDone[2]", P_DOUBLE, 1, 208, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[3]), "epicsMotorDone[3]", P_DOUBLE, 1, 209, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[4]), "epicsMotorDone[4]", P_DOUBLE, 1, 210, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[5]), "epicsMotorDone[5]", P_DOUBLE, 1, 211, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[6]), "epicsMotorDone[6]", P_DOUBLE, 1, 212, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[7]), "epicsMotorDone[7]", P_DOUBLE, 1, 213, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVELO[0]), "epicsMotorVELO[0]", P_DOUBLE, 1, 214, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVELO[1]), "epicsMotorVELO[1]", P_DOUBLE, 1, 215, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVELO[2]), "epicsMotorVELO[2]", P_DOUBLE, 1, 216, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVELO[3]), "epicsMotorVELO[3]", P_DOUBLE, 1, 217, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVELO[4]), "epicsMotorVELO[4]", P_DOUBLE, 1, 218, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVELO[5]), "epicsMotorVELO[5]", P_DOUBLE, 1, 219, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVELO[6]), "epicsMotorVELO[6]", P_DOUBLE, 1, 220, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVELO[7]), "epicsMotorVELO[7]", P_DOUBLE, 1, 221, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMAX[0]), "epicsMotorVMAX[0]", P_DOUBLE, 1, 222, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMAX[1]), "epicsMotorVMAX[1]", P_DOUBLE, 1, 223, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMAX[2]), "epicsMotorVMAX[2]", P_DOUBLE, 1, 224, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMAX[3]), "epicsMotorVMAX[3]", P_DOUBLE, 1, 225, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMAX[4]), "epicsMotorVMAX[4]", P_DOUBLE, 1, 226, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMAX[5]), "epicsMotorVMAX[5]", P_DOUBLE, 1, 227, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMAX[6]), "epicsMotorVMAX[6]", P_DOUBLE, 1, 228, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMAX[7]), "epicsMotorVMAX[7]", P_DOUBLE, 1, 229, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMIN[0]), "epicsMotorVMIN[0]", P_DOUBLE, 1, 230, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMIN[1]), "epicsMotorVMIN[1]", P_DOUBLE, 1, 231, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMIN[2]), "epicsMotorVMIN[2]", P_DOUBLE, 1, 232, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMIN[3]), "epicsMotorVMIN[3]", P_DOUBLE, 1, 233, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMIN[4]), "epicsMotorVMIN[4]", P_DOUBLE, 1, 234, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMIN[5]), "epicsMotorVMIN[5]", P_DOUBLE, 1, 235, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMIN[6]), "epicsMotorVMIN[6]", P_DOUBLE, 1, 236, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMIN[7]), "epicsMotorVMIN[7]", P_DOUBLE, 1, 237, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorACCL[0]), "epicsMotorACCL[0]", P_DOUBLE, 1, 238, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorACCL[1]), "epicsMotorACCL[1]", P_DOUBLE, 1, 239, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorACCL[2]), "epicsMotorACCL[2]", P_DOUBLE, 1, 240, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorACCL[3]), "epicsMotorACCL[3]", P_DOUBLE, 1, 241, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorACCL[4]), "epicsMotorACCL[4]", P_DOUBLE, 1, 242, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorACCL[5]), "epicsMotorACCL[5]", P_DOUBLE, 1, 243, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorACCL[6]), "epicsMotorACCL[6]", P_DOUBLE, 1, 244, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorACCL[7]), "epicsMotorACCL[7]", P_DOUBLE, 1, 245, 0, 1, 0, 0},
};

/* Event masks for state set "EnsembleTrajectoryScan" */
static const seqMask seqg_mask_EnsembleTrajectoryScan_0_init[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_EnsembleTrajectoryScan_0_monitor_inputs[] = {
	0x84a008ce,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_EnsembleTrajectoryScan_0_build[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_EnsembleTrajectoryScan_0_execute[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_EnsembleTrajectoryScan_0_wait_execute[] = {
	0x18000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_EnsembleTrajectoryScan_0_readback[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};

/* State table for state set "EnsembleTrajectoryScan" */
static seqState seqg_states_EnsembleTrajectoryScan[] = {
	{
	/* state name */        "init",
	/* action function */   seqg_action_EnsembleTrajectoryScan_0_init,
	/* event function */    seqg_event_EnsembleTrajectoryScan_0_init,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_EnsembleTrajectoryScan_0_init,
	/* state options */     (0)
	},
	{
	/* state name */        "monitor_inputs",
	/* action function */   seqg_action_EnsembleTrajectoryScan_0_monitor_inputs,
	/* event function */    seqg_event_EnsembleTrajectoryScan_0_monitor_inputs,
	/* entry function */    seqg_entry_EnsembleTrajectoryScan_0_monitor_inputs,
	/* exit function */     0,
	/* event mask array */  seqg_mask_EnsembleTrajectoryScan_0_monitor_inputs,
	/* state options */     (0)
	},
	{
	/* state name */        "build",
	/* action function */   seqg_action_EnsembleTrajectoryScan_0_build,
	/* event function */    seqg_event_EnsembleTrajectoryScan_0_build,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_EnsembleTrajectoryScan_0_build,
	/* state options */     (0)
	},
	{
	/* state name */        "execute",
	/* action function */   seqg_action_EnsembleTrajectoryScan_0_execute,
	/* event function */    seqg_event_EnsembleTrajectoryScan_0_execute,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_EnsembleTrajectoryScan_0_execute,
	/* state options */     (0)
	},
	{
	/* state name */        "wait_execute",
	/* action function */   seqg_action_EnsembleTrajectoryScan_0_wait_execute,
	/* event function */    seqg_event_EnsembleTrajectoryScan_0_wait_execute,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_EnsembleTrajectoryScan_0_wait_execute,
	/* state options */     (0)
	},
	{
	/* state name */        "readback",
	/* action function */   seqg_action_EnsembleTrajectoryScan_0_readback,
	/* event function */    seqg_event_EnsembleTrajectoryScan_0_readback,
	/* entry function */    seqg_entry_EnsembleTrajectoryScan_0_readback,
	/* exit function */     0,
	/* event mask array */  seqg_mask_EnsembleTrajectoryScan_0_readback,
	/* state options */     (0)
	},
};

/* Event masks for state set "trajectoryAbort" */
static const seqMask seqg_mask_trajectoryAbort_1_monitorAbort[] = {
	0x40000020,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};

/* State table for state set "trajectoryAbort" */
static seqState seqg_states_trajectoryAbort[] = {
	{
	/* state name */        "monitorAbort",
	/* action function */   seqg_action_trajectoryAbort_1_monitorAbort,
	/* event function */    seqg_event_trajectoryAbort_1_monitorAbort,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_trajectoryAbort_1_monitorAbort,
	/* state options */     (0)
	},
};

/* State set table */
static seqSS seqg_statesets[] = {
	{
	/* state set name */    "EnsembleTrajectoryScan",
	/* states */            seqg_states_EnsembleTrajectoryScan,
	/* number of states */  6
	},

	{
	/* state set name */    "trajectoryAbort",
	/* states */            seqg_states_trajectoryAbort,
	/* number of states */  1
	},
};

/* Program table (global) */
seqProgram EnsembleTrajectoryScan = {
	/* magic number */      2002005,
	/* program name */      "EnsembleTrajectoryScan",
	/* channels */          seqg_chans,
	/* num. channels */     237,
	/* state sets */        seqg_statesets,
	/* num. state sets */   2,
	/* user var size */     sizeof(struct seqg_vars),
	/* param */             "P=13IDC:,R=traj1,M1=M1,M2=M2,M3=M3,M4=M4,M5=M5,M6=M6,M7=M7,M8=M8,PORT=serial1",
	/* num. event flags */  8,
	/* encoded options */   (0 | OPT_CONN | OPT_NEWEF | OPT_REENT),
	/* init func */         seqg_init,
	/* entry func */        0,
	/* exit func */         0,
	/* num. queues */       0
};
# line 748 "../EnsembleTrajectoryScan.st"



static int writeOnly(SS_ID ssId, struct UserVar *pVar, char *command)
{
 asynStatus status=0;
 int debug_out=0;
 size_t nwrite;
 char buffer[100];


 strncpy(buffer, command, 100 -3);
 strcat(buffer, "\n");
 if (!(pVar->simMode)) {
  status = pasynOctetSyncIO->write((asynUser *)pVar->pasynUser, buffer,
          strlen(buffer), 1.0, &nwrite);
 }
 if (pVar->execState==2)
  debug_out = (pVar->debugLevel >= 7);
 else
  debug_out = (pVar->debugLevel >= 2);
 if (pVar->simMode || debug_out) printf("    writeOnly:command='%s'\n", command);
 return(status);
}





static int writeRead(SS_ID ssId, struct UserVar *pVar, char *command, char *reply)
{
 asynStatus status=0;
 char buffer[100];
 size_t nwrite, nread;
 int eomReason;

 strncpy(buffer, command, 100 -3);



 if (!(pVar->simMode)) {
  status = pasynOctetSyncIO->writeRead((asynUser *)pVar->pasynUser, buffer,
          strlen(buffer), reply, 100,
          30.0, &nwrite, &nread, &eomReason);
  if (status) printf("writeRead: pasynOctetSyncIO->writeRead returned %d\n", status);
 }
 if (pVar->simMode || (pVar->debugLevel >= 3)) {
  if (buffer[strlen(buffer)-1] == '\n') buffer[strlen(buffer)-1] = '\0';
  printf("    writeRead:command='%s', reply='%s'\n", buffer, reply);
 }
 return(status);
}




static int getMotorPositions(SS_ID ssId, struct UserVar *pVar, double *pos)
{
    int j, status;
    int dir, rawP;
 double rawF;
    char inputBuff[100], outputBuff[100];
 size_t nwrite, nread;
 int eomReason;

 for (j=0; j<pVar->numAxes; j++) {
  sprintf(outputBuff, "PFBKPROG(@%d)", j);
  status = pasynOctetSyncIO->writeRead((asynUser *)pVar->pasynUser, outputBuff,
          strlen(outputBuff), inputBuff, 100,
          30.0, &nwrite, &nread, &eomReason);
  if (status) printf("getMotorPositions: pasynOctetSyncIO->writeRead returned %d\n", status);
  if (inputBuff[0] != '%')
   rawF = 0;
  else
   rawF = atof(&inputBuff[1]);
  rawP = rawF / fabs(pVar->epicsMotorMres[j]);
        if (pVar->epicsMotorDir[j] == 0) dir=1; else dir=-1;
  pos[j] = rawToUser(rawP, pVar->epicsMotorOff[j], dir, pVar->epicsMotorMres[j]);
    }

 if (pVar->debugLevel > 2) {
  printf("pos[0]=%.2f\n", pos[0]);
 }

 return(0);
}




static int getMotorMoving(SS_ID ssId, struct UserVar *pVar, int movingMask)
{
    char inputBuff[100], outputBuff[100];
 size_t nwrite, nread;
 int eomReason;
 int move_active;
 int i, count, status;

 sprintf(outputBuff, "PLANESTATUS(0)");

 for (i=0, count=0; i<1; i++) {
  status = pasynOctetSyncIO->writeRead((asynUser *)pVar->pasynUser, outputBuff,
          strlen(outputBuff), inputBuff, 100,
          30.0, &nwrite, &nread, &eomReason);
  if (status) printf("getMotorMoving: pasynOctetSyncIO->writeRead returned %d\n", status);
  if (strlen(inputBuff) > 3) printf("getMotorMoving: PLANESTATUS(0) returned '%s'\n", inputBuff);
  if (pVar->debugLevel > 2) {
   printf("getMotorMoving: inputBuff='%s'\n", inputBuff);
  }
  move_active = atoi(&inputBuff[1]);
  if (move_active) {
   return(1);
  } else {
   count++;
   if (count>2) break;
  }
 }

 return(0);
}





static int getEpicsMotorMoving(SS_ID ssId, struct UserVar *pVar)
{
 int j;
 int result=0, mask=0x01;

 for (j=0; j<pVar->numAxes; j++) {
  seq_pvGet(ssId, pVar->epicsMotorDoneIndex[j], 0);
  if (pVar->epicsMotorDone[j] == 0) result |= mask;
  mask = mask << 1;
 }
 return(result);
}



static int waitEpicsMotors(SS_ID ssId, struct UserVar *pVar)
{
 int j;



 while (getEpicsMotorMoving(ssId, pVar)) {

  for (j=0; j<pVar->numAxes; j++) {
   pVar->motorCurrent[j] = pVar->epicsMotorPos[j];
   seq_pvPut(ssId, pVar->motorCurrentIndex[j], 0);
  }
  epicsThreadSleep((1/5.));
 }
 for (j=0; j<pVar->numAxes; j++) {
  pVar->motorCurrent[j] = pVar->epicsMotorPos[j];
  seq_pvPut(ssId, pVar->motorCurrentIndex[j], 0);
 }
 return(0);
}






static int buildTrajectory(SS_ID ssId, struct UserVar *pVar, double *realTimeTrajectory,
 double *motorTrajectory, int epicsMotorDir, int moveMode, int npoints, int npulses, double motorOffset,
 double motorResolution, double *velocity)
{
 double dp, dt, maxV=0;
 int i, status;
 char stringOut[100], reply[100];

 sprintf(stringOut, "GETPARM(%d)", 35);
 status = writeRead(ssId, pVar, stringOut, reply);

 if (reply[0] == '%') {
  maxV = atof(&reply[1]);
 } else {
  printf("buildTrajectory: Can't read velocityCommandThreshold parameter\n");
  return(-1);
 }



 for (i=0; i<npoints; i++) {
  if (i==0) {
   dp = motorTrajectory[1] - motorTrajectory[0];
   dt = realTimeTrajectory[1] - realTimeTrajectory[0];
   velocity[i] = dp/dt;
  } else {
   dp = motorTrajectory[i] - motorTrajectory[i-1];
   dt = realTimeTrajectory[i] - realTimeTrajectory[i-1];
   velocity[i] = 2*dp/dt - velocity[i-1];
  }
  if (pVar->debugLevel > 2) {
   printf("point %d: pos=%f, vel=%f, time=%f\n", i, motorTrajectory[i], velocity[i], realTimeTrajectory[i]);
  }
 }
# 969 "../EnsembleTrajectoryScan.st"
 for (i=0; i<npoints; i++) {
  if (fabs(velocity[i]) > maxV) {
   printf("velocity > limit %f at point %d: vel=%f\n", maxV, i, velocity[i]);
   return(-1);
  }
 }

 return(0);
}

static int userToRaw(double user, double off, int dir, double res) {
 return ((int)(((user-off)*dir/res)>0 ? ((user-off)*dir/res)+0.5 : ((user-off)*dir/res)-0.5));
}

static double rawToUser(int raw, double off, int dir, double res) {

 return (raw*res*dir+off);
}
# 999 "../EnsembleTrajectoryScan.st"
int sendReceiveCommand(SS_ID ssId, struct UserVar *pVar, char *cmd, char *callerReply, int checkProgram) {
 int i, i1, i2, i3, i4, cmdNum;
 double d1, d2, d3;
 char stringOut[100], reply[100];
 int status, saveDebug;

 if (pVar->debugLevel > 1) {
  printf("sendReceiveCommand: command='%s'\n", cmd);
 }
 if (checkProgram) {

  strcpy(stringOut, "TASKSTATE(1)");
  status = writeRead(ssId, pVar, stringOut, reply);
  status = atoi(&reply[1]);
  if (reply[0] == '!') {
   printf("sendReceiveCommand: 'TASKSTATE(1)' returned error.\n");
   return(-1);
  }
  switch (status) {
  case 0:
   if (strlen(reply) == 1) {
    printf("sendReceiveCommand: TASKSTATE(1)' returned '%s', which I'm ignoring\n", reply);
   } else {
    printf("sendReceiveCommand: TASKSTATE(1)' returned '%s'\n", reply);
    return(-1);
   }
   break;
  case 3:
   break;
  case 1:
  case 2:
  case 4:
  case 5:
   strcpy(stringOut, "PROGRAM RUN 1, \"doCommand.bcx\"");
   status = writeRead(ssId, pVar, stringOut, reply);
   epicsThreadSleep(.1);
   break;
  case 6:
   strcpy(stringOut, "PROGRAM STOP 1");
   status = writeRead(ssId, pVar, stringOut, reply);
   epicsThreadSleep(.1);
   strcpy(stringOut, "PROGRAM RUN 1, \"doCommand.bcx\"");
   status = writeRead(ssId, pVar, stringOut, reply);
   epicsThreadSleep(.1);
   break;
  default:

   break;
  }
 }


 saveDebug = pVar->debugLevel;
 pVar->debugLevel = ((0) > (pVar->debugLevel - 1) ? (0) : (pVar->debugLevel - 1));

 cmdNum = 0;
 if (strncmp(cmd, "VELOCITY ON", strlen("VELOCITY ON")) == 0) {
  cmdNum = 1;
  sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 1);
  status = writeRead(ssId, pVar, stringOut, reply);
 } else if (strncmp(cmd, "DOTRAJECTORY", strlen("DOTRAJECTORY")) == 0) {
  cmdNum = 25;
  sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 25);
  status = writeRead(ssId, pVar, stringOut, reply);
 } else if (strncmp(cmd, "VELOCITY OFF", strlen("VELOCITY OFF")) == 0) {
  cmdNum = 2;
  sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 2);
  status = writeRead(ssId, pVar, stringOut, reply);
 } else if (strncmp(cmd, "HALT", strlen("HALT")) == 0) {
  cmdNum = 3;
  sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 3);
  status = writeRead(ssId, pVar, stringOut, reply);
 } else if (strncmp(cmd, "STARTABORT", strlen("STARTABORT")) == 0) {
  cmdNum = 12;
  sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 12);
  status = writeRead(ssId, pVar, stringOut, reply);
 } else if (strncmp(cmd, "START", strlen("START")) == 0) {
  cmdNum = 4;
  sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 4);
  if (callerReply != NULL) {
   status = writeRead(ssId, pVar, stringOut, reply);
  } else {
   status = writeOnly(ssId, pVar, stringOut);
  }
 } else if (strncmp(cmd, "PVT INIT TIME ABS", strlen("PVT INIT TIME ABS")) == 0) {
  cmdNum = 5;
  sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 5);
  status = writeRead(ssId, pVar, stringOut, reply);
 } else if (strncmp(cmd, "PVT INIT TIME INC", strlen("PVT INIT TIME INC")) == 0) {
  cmdNum = 6;
  sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 6);
  status = writeRead(ssId, pVar, stringOut, reply);
 } else if (strncmp(cmd, "PVT1", strlen("PVT1")) == 0) {
  cmdNum = 7;
  sscanf(cmd, "PVT1 %d %lf,%lf TIME %lf", &i1, &d1, &d2, &d3);
  status = writeIntAndCheck(ssId, pVar, 46, i1);
  status = writeDoubleAndCheck(ssId, pVar, 1, d1);
  status = writeDoubleAndCheck(ssId, pVar, 2, d2);
  status = writeDoubleAndCheck(ssId, pVar, 3, d3);
  sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 7);
  status = writeRead(ssId, pVar, stringOut, reply);
 } else if (strncmp(cmd, "ABORT", strlen("ABORT")) == 0) {
  cmdNum = 11;
  i1 = i2 = i3 = i4 = -1;
  i = sscanf(cmd, "ABORT @%d @%d @%d @%d", &i1, &i2, &i3, &i4);
  status = writeIntAndCheck(ssId, pVar, 44, i);
  status = writeIntAndCheck(ssId, pVar, 46, i1);
  status = writeIntAndCheck(ssId, pVar, 47, i2);
  status = writeIntAndCheck(ssId, pVar, 48, i3);
  status = writeIntAndCheck(ssId, pVar, 49, i4);
  sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 11);
  status = writeRead(ssId, pVar, stringOut, reply);
 } else if (strncmp(cmd, "SCOPEBUFFER", strlen("SCOPEBUFFER")) == 0) {
  cmdNum = 13;
  i1 = 0;
  i = sscanf(cmd, "SCOPEBUFFER %d", &i1);
  status = writeIntAndCheck(ssId, pVar, 46, i1);
  sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 13);
  status = writeRead(ssId, pVar, stringOut, reply);
 } else if (strncmp(cmd, "SCOPEDATA", strlen("SCOPEDATA")) == 0) {
  cmdNum = 14;
  i1 = i2 = 0;
  i = sscanf(cmd, "SCOPEDATA %d %d", &i1, &i2);
  status = writeIntAndCheck(ssId, pVar, 46, i1);
  status = writeIntAndCheck(ssId, pVar, 47, i2);
  sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 14);
  status = writeRead(ssId, pVar, stringOut, reply);
 } else if (strncmp(cmd, "SCOPESTATUS", strlen("SCOPESTATUS")) == 0) {
  cmdNum = 15;
  sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 15);
  status = writeRead(ssId, pVar, stringOut, reply);

 } else if (strncmp(cmd, "SCOPETRIG STOP", strlen("SCOPETRIG STOP")) == 0) {
  cmdNum = 16;
  status = writeIntAndCheck(ssId, pVar, 46, 1);
  sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 16);
  status = writeRead(ssId, pVar, stringOut, reply);
 } else if (strncmp(cmd, "SCOPETRIGPERIOD", strlen("SCOPETRIGPERIOD")) == 0) {
  cmdNum = 17;

  i1 = 0;
  i = sscanf(cmd, "SCOPETRIGPERIOD %d", &i1);
  status = writeIntAndCheck(ssId, pVar, 46, i1);
  sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 17);
  status = writeRead(ssId, pVar, stringOut, reply);
 } else if (strncmp(cmd, "SCOPETRIG", strlen("SCOPETRIG")) == 0) {
  cmdNum = 16;
  status = writeIntAndCheck(ssId, pVar, 46, 0);
  sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 16);
  status = writeRead(ssId, pVar, stringOut, reply);
 } else if (strncmp(cmd, "LINEAR", strlen("LINEAR")) == 0) {
  cmdNum = 19;
  i1 = 0;
  d1 = d2 = 0;
  i = sscanf(cmd, "LINEAR @%d %lf F%lf", &i1, &d1, &d2);
  status = writeIntAndCheck(ssId, pVar, 46, i1);
  status = writeDoubleAndCheck(ssId, pVar, 1, d1);
  status = writeDoubleAndCheck(ssId, pVar, 2, d2);
  sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 19);
  status = writeRead(ssId, pVar, stringOut, reply);
 } else if (strncmp(cmd, "DATAACQ", strlen("DATAACQ")) == 0) {
  if (strncmp(cmd, "DATAACQ_TRIG", strlen("DATAACQ_TRIG")) == 0) {
   cmdNum = 20;
   i1 = i2 = 0;
   i = sscanf(cmd, "DATAACQ_TRIG @%d %d", &i1, &i2);
   status = writeIntAndCheck(ssId, pVar, 46, i1);
   status = writeIntAndCheck(ssId, pVar, 47, i2);
   sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 20);
   status = writeRead(ssId, pVar, stringOut, reply);
  } else if (strncmp(cmd, "DATAACQ_INP", strlen("DATAACQ_INP")) == 0) {
   cmdNum = 21;
   i1 = i2 = 0;
   i = sscanf(cmd, "DATAACQ_INP @%d %d", &i1, &i2);
   status = writeIntAndCheck(ssId, pVar, 46, i1);
   status = writeIntAndCheck(ssId, pVar, 47, i2);
   sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 21);
   status = writeRead(ssId, pVar, stringOut, reply);
  } else if (strncmp(cmd, "DATAACQ_ON", strlen("DATAACQ_ON")) == 0) {
   cmdNum = 22;
   i1 = i2 = 0;
   i = sscanf(cmd, "DATAACQ_ON @%d %d", &i1, &i2);
   status = writeIntAndCheck(ssId, pVar, 46, i1);
   status = writeIntAndCheck(ssId, pVar, 47, i2);
   sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 22);
   status = writeRead(ssId, pVar, stringOut, reply);
  } else if (strncmp(cmd, "DATAACQ_OFF", strlen("DATAACQ_OFF")) == 0) {
   cmdNum = 23;
   i1 = 0;
   i = sscanf(cmd, "DATAACQ_OFF @%d", &i1);
   status = writeIntAndCheck(ssId, pVar, 46, i1);
   sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 23);
   status = writeRead(ssId, pVar, stringOut, reply);
  } else if (strncmp(cmd, "DATAACQ_READ", strlen("DATAACQ_READ")) == 0) {
   cmdNum = 24;
   i1 = i2 = i3 = 0;
   i = sscanf(cmd, "DATAACQ_READ @%d %d %d", &i1, &i2, &i3);
   status = writeIntAndCheck(ssId, pVar, 46, i1);
   status = writeIntAndCheck(ssId, pVar, 47, i2);
   status = writeIntAndCheck(ssId, pVar, 48, i3);
   sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 24);
   status = writeRead(ssId, pVar, stringOut, reply);
  } else {
   cmdNum = -1;
   printf("sendReceiveCommand: unexpected command: '%s'\n", cmd);
   return(-1);
  }
 }




 i = 0;
 if (cmdNum != 25) {
  sprintf(stringOut, "IGLOBAL(%d)", 45);
  for (i=0; i<300; i++) {
   status = writeRead(ssId, pVar, stringOut, reply);
   if (reply[0] == '%') {
    if (atoi(&reply[1]) == -cmdNum) break;
   }
   epicsThreadSleep(0.01);
  }
 }
 pVar->debugLevel = saveDebug;

 if (i>300 -1) {
  printf("sendReceiveCommand: timeout (%.2f s) executing '%s'; reply='%s'\n",
   300*0.01, cmd, reply);
  if (callerReply != NULL) {
   printf("... reply='%s'\n", reply);
  }

  status = writeIntAndCheck(ssId, pVar, 45, 0);
  return(-1);
 }
 return(0);
}

int writeDoubleAndCheck(SS_ID ssId, struct UserVar *pVar, int n, double d) {
 char stringOut[100], reply[100];
 double dCheck = -d;
 int i, status;

 for (i=0; i<10; i++) {
  sprintf(stringOut, "DGLOBAL(%d) = %f", n, d);
  status = writeRead(ssId, pVar, stringOut, reply);
  if (status) return(-1);
  sprintf(stringOut, "DGLOBAL(%d)", n);
  status = writeRead(ssId, pVar, stringOut, reply);
  if (status) return(-1);
  dCheck = atof(&reply[1]);
  if (fabs(d-dCheck) < .0001) break;
  printf("writeDoubleAndCheck: fix dglobal %d (%f != %f)\n", n, d, dCheck);
 }
 if (i==10) return(-1);
 return(0);
}

int writeIntAndCheck(SS_ID ssId, struct UserVar *pVar, int n, int ival) {
 char stringOut[100], reply[100];
 int iCheck = -ival;
 int i, status;

 for (i=0; i<10; i++) {
  sprintf(stringOut, "IGLOBAL(%d) = %d", n, ival);
  status = writeRead(ssId, pVar, stringOut, reply);
  if (status) return(-1);
  sprintf(stringOut, "IGLOBAL(%d)", n);
  status = writeRead(ssId, pVar, stringOut, reply);
  if (status) return(-1);
  iCheck = atol(&reply[1]);
  if (ival == iCheck) break;
  printf("writeIntAndCheck: fix iglobal %d (%d != %d)\n", n, ival, iCheck);
 }
 if (i==10) return(-1);
 return(0);
}
# 1284 "../EnsembleTrajectoryScan.st"
static int loadTrajectory(SS_ID ssId, struct UserVar *pVar) {
 int i, j, n, status;
 char stringOut[100], reply[100];
 double position, p, v, t, dp, dtime;
 int iGlobalIndex;
 int intPosition;
 double accelDist, accelTime, decelDist, decelTime, positionLast;
 double home_position_set=0.;
 double posfbkprog, posfbkcal;

 pVar->loadingTrajectory = 1;

 sprintf(stringOut, "getparm(@0,%d)", 1);
 status = writeRead(ssId, pVar, stringOut, reply);
 encoder_runs_backwards = atoi(&reply[1]);
 if (pVar->debugLevel > 2) printf("loadTrajectory: encoder_runs_backwards=%d\n", encoder_runs_backwards);

 sprintf(stringOut, "getparm(@0,%d)", 166);
 status = writeRead(ssId, pVar, stringOut, reply);
 home_position_set = atof(&reply[1]);
 if (pVar->debugLevel > 2) printf("loadTrajectory: home_position_set=%f\n", home_position_set);

 status = writeIntAndCheck(ssId, pVar, 42, 50);



 for (j=0; j<8; j++) {
  sprintf(stringOut, "pfbkprog(@%d)", j);
  status = writeRead(ssId, pVar, stringOut, reply);
  posfbkprog = atof(&reply[1]);
  sprintf(stringOut, "pfbkcal(@%d)", j);
  status = writeRead(ssId, pVar, stringOut, reply);
  posfbkcal = atof(&reply[1]);
  pVar->motorPosOffset[j] = posfbkprog - posfbkcal;
 }


 if (pVar->pulseMode != 3) {

  strcpy(stringOut, "PSOCONTROL @0 RESET");
  status = writeRead(ssId, pVar, stringOut, reply);
 }
# 1335 "../EnsembleTrajectoryScan.st"
 if ((pVar->pulseMode == 1) || (pVar->pulseMode == 2)) {

  int np;
  int maxArrayPulses = ((8192) > (pVar->numGlobalIntegers - 50) ? (pVar->numGlobalIntegers - 50) : (8192));



  if ((pVar->pulseMode == 1) &&
   (pVar->pulsePositionsLoaded != 1)) {
   if (pVar->debugLevel > 2) printf("loadTrajectory: load PULSE_MODE_ARRAY array\n");
   j = 0;

   positionLast = pVar->motorStart[j];
   iGlobalIndex = 50;
   if (pVar->numGlobalIntegers < (pVar->numPulsePositions + 50)) {
    printf("EnsembleTrajectoryScan: The Ensemble only has enough global integers for %d pulses\n",
     pVar->numGlobalIntegers - 50);
    pVar->numPulsePositions = pVar->numGlobalIntegers - 50;
   }
   if (pVar->numPulsePositions > 8192) {
    printf("EnsembleTrajectoryScan: The Ensemble can't load more than %d PSOARRAY pulses\n",
     8192);
    pVar->numPulsePositions = 8192;
   }
   for (i=0, np=0; i<pVar->numPulsePositions && np<maxArrayPulses; i++) {

    np++;
    position = pVar->pulsePositions[i];
    intPosition = (int)(((position - positionLast)/pVar->epicsMotorMres[j])>0 ? ((position - positionLast)/pVar->epicsMotorMres[j])+0.5 : ((position - positionLast)/pVar->epicsMotorMres[j])-0.5);
    status = writeIntAndCheck(ssId, pVar, iGlobalIndex++, abs(intPosition));
    positionLast += intPosition*pVar->epicsMotorMres[j];
   }
   pVar->pulsePositionsLoaded = 1;
   pVar->numPulsePositionsLoaded = np;
  } else if ((pVar->pulseMode == 2) &&
    (pVar->pulsePositionsLoaded != 2)) {

   if (pVar->debugLevel > 2) printf("loadTrajectory: load PULSE_MODE_TRAJPTS array\n");
   j = 0;
   positionLast = pVar->motorStart[j];
   iGlobalIndex = 50;
   if (pVar->numGlobalIntegers < (pVar->nelements + 50)) {
    printf("EnsembleTrajectoryScan: The Ensemble only has enough global integers for %d pulses\n",
     pVar->numGlobalIntegers - 50);
   }
   if (pVar->nelements > 8192) {
    printf("EnsembleTrajectoryScan: The Ensemble can't load more than %d PSOARRAY pulses\n",
     8192);
   }
   for (i=0, np=0; i<pVar->nelements && np<maxArrayPulses; i++) {

    if (i >= pVar->startPulses && i <= pVar->endPulses) {

     np++;
     position = pVar->motorTrajectory[j][i];
     intPosition = (int)(((position - positionLast)/pVar->epicsMotorMres[j])>0 ? ((position - positionLast)/pVar->epicsMotorMres[j])+0.5 : ((position - positionLast)/pVar->epicsMotorMres[j])-0.5);
     status = writeIntAndCheck(ssId, pVar, iGlobalIndex++, abs(intPosition));
     positionLast += intPosition*pVar->epicsMotorMres[j];
    }
   }
   pVar->pulsePositionsLoaded = 2;
   pVar->numPulsePositionsLoaded = np;
  }


  sprintf(stringOut, "PSOARRAY @0,%d,%d", 50, pVar->numPulsePositionsLoaded);
  status = writeRead(ssId, pVar, stringOut, reply);

  strcpy(stringOut, "PSODISTANCE @0 ARRAY");
  status = writeRead(ssId, pVar, stringOut, reply);
 }






 if (pVar->pulseMode != 3) {


  sprintf(stringOut, "PSOPULSE @0 TIME %f,%f", pVar->pulseLenUS*1.5, pVar->pulseLenUS);
  status = writeRead(ssId, pVar, stringOut, reply);
  strcpy(stringOut, "PSOOUTPUT @0 PULSE");
  status = writeRead(ssId, pVar, stringOut, reply);



  sprintf(stringOut, "PSOTRACK @0 INPUT %d", pVar->pulseSrc);
  status = writeRead(ssId, pVar, stringOut, reply);


  sprintf(stringOut, "PSOTRACK @0 DIRECTION %d", pVar->pulseDir);
  status = writeRead(ssId, pVar, stringOut, reply);

  if ((pVar->pulseMode == 1) || (pVar->pulseMode == 2)) {

   strcpy(stringOut, "PSODISTANCE @0 ARRAY");
   status = writeRead(ssId, pVar, stringOut, reply);
  } else if (pVar->pulseMode == 0) {

   dp = fabs(pVar->motorTrajectory[0][pVar->npoints-1] - pVar->motorTrajectory[0][0]) / pVar->npulses;
   sprintf(stringOut, "PSODISTANCE @0 FIXED %f UNITS", dp);
   status = writeRead(ssId, pVar, stringOut, reply);
  }
  strcpy(stringOut, "PSOCONTROL @0 ARM");
  status = writeRead(ssId, pVar, stringOut, reply);
 }



 getMotorPositions(ssId, pVar, pVar->motorCurrent);

 strcpy(stringOut, "TASKSTATE(1)");
 status = writeRead(ssId, pVar, stringOut, reply);
 status = atoi(&reply[1]);
 if ((reply[0] == '!') || ((status != 1) && (status != 3) && (status != 5))) {
  strcpy(stringOut, "PROGRAM STOP 1");
  status = writeRead(ssId, pVar, stringOut, reply);
  strcpy(stringOut, "TASKSTATE(1)");
  status = writeRead(ssId, pVar, stringOut, reply);
 }

 status = writeIntAndCheck(ssId, pVar, 45, 0);
 strcpy(stringOut, "PROGRAM RUN 1, \"doCommand.bcx\"");
 status = writeRead(ssId, pVar, stringOut, reply);
 epicsThreadSleep(.1);



 pVar->nScopeDataPoints = pVar->npoints * 2.2;
 if (pVar->nScopeDataPoints > 8000) pVar->nScopeDataPoints = 8000;
 pVar->scopeDataIntervalMS = (int)((1000 * (pVar->time*1.1)/pVar->nScopeDataPoints)>0 ? (1000 * (pVar->time*1.1)/pVar->nScopeDataPoints)+0.5 : (1000 * (pVar->time*1.1)/pVar->nScopeDataPoints)-0.5);
 if (pVar->scopeDataIntervalMS < 1) pVar->scopeDataIntervalMS = 1;
 sprintf(stringOut, "SCOPEBUFFER %d", pVar->nScopeDataPoints);
 status = sendReceiveCommand(ssId, pVar, stringOut, reply, 1);
 sprintf(stringOut, "SCOPETRIGPERIOD %d", pVar->scopeDataIntervalMS);
 status = sendReceiveCommand(ssId, pVar, stringOut, reply, 0);
# 1485 "../EnsembleTrajectoryScan.st"
 for (j=0; j<8; j++) {
  if (pVar->moveAxis[j]) break;
 }
 status = writeIntAndCheck(ssId, pVar, 46, j);


 accelTime = pVar->epicsMotorACCL[j];
 accelDist = (pVar->velocity[j][0] * pVar->epicsMotorACCL[j]) / 2;

 decelTime = pVar->epicsMotorACCL[j];
 decelDist = (pVar->velocity[j][pVar->npoints - 1] * pVar->epicsMotorACCL[j]) / 2;

 n = 0;
 status = 0;
 status += writeDoubleAndCheck(ssId, pVar, n++, pVar->motorTrajectory[j][0]);
 status += writeDoubleAndCheck(ssId, pVar, n++, pVar->velocity[j][0]);
 status += writeDoubleAndCheck(ssId, pVar, n++, accelTime);
 if (status) goto bad;

 for (i=1; i<pVar->npoints; i++) {
  p = pVar->motorTrajectory[j][i];
  v = pVar->velocity[j][i];
  t = accelTime + pVar->realTimeTrajectory[i];
  status += writeDoubleAndCheck(ssId, pVar, n++, p);
  status += writeDoubleAndCheck(ssId, pVar, n++, v);
  status += writeDoubleAndCheck(ssId, pVar, n++, t);
  if (status) goto bad;
 }


 p = 2*pVar->motorTrajectory[j][pVar->npoints-1] - pVar->motorTrajectory[j][pVar->npoints-2];
 v = pVar->velocity[j][pVar->npoints-1];
 t = accelTime + 2*pVar->realTimeTrajectory[pVar->npoints-1] - pVar->realTimeTrajectory[pVar->npoints-2];
 status += writeDoubleAndCheck(ssId, pVar, n++, p);
 status += writeDoubleAndCheck(ssId, pVar, n++, v);
 status += writeDoubleAndCheck(ssId, pVar, n++, t);
 if (status) goto bad;

 p = p + decelDist*.9;
 v = pVar->velocity[j][pVar->npoints-1]*.1;
 t = t + decelTime*.9;
 status += writeDoubleAndCheck(ssId, pVar, n++, p);
 status += writeDoubleAndCheck(ssId, pVar, n++, v);
 status += writeDoubleAndCheck(ssId, pVar, n++, t);
 if (status) goto bad;

 p = p + decelDist*.1;
 v = 0.;
 t = t + decelTime*.1;
 status += writeDoubleAndCheck(ssId, pVar, n++, p);
 status += writeDoubleAndCheck(ssId, pVar, n++, v);
 status += writeDoubleAndCheck(ssId, pVar, n++, t);
 if (status) goto bad;


 status = writeIntAndCheck(ssId, pVar, 47, n/3);


 status = sendReceiveCommand(ssId, pVar, "SCOPETRIG", reply, 0);


 epicsTimeGetCurrent(&startTime);
 sprintf(stringOut, "DOTRAJECTORY");
 status = sendReceiveCommand(ssId, pVar, stringOut, reply, 0);
# 1690 "../EnsembleTrajectoryScan.st"
 if (pVar->abortState != 0) goto abort;

 strcpy(stringOut, "TASKSTATE(1)");
 status = writeRead(ssId, pVar, stringOut, reply);
 if (pVar->debugLevel) printf("TASKSTATE = '%s', ", reply);
 strcpy(stringOut, "TASKERROR(1)");
 status = writeRead(ssId, pVar, stringOut, reply);
 if (pVar->debugLevel) printf("TASKERROR = '%s', ", reply);
 for (i=0; i<50; i++) {
  strcpy(stringOut, "PLANESTATUS(0)");
  status = writeRead(ssId, pVar, stringOut, reply);
  if (reply[1] == '3') break;
  epicsThreadSleep(.1);
 }
 if (i>=50) {
  printf("loadTrajectory: trajectory didn't start. (PLANESTATUS = '%s')\n", reply);
  strcpy(stringOut, "VELOCITY OFF");
  status = sendReceiveCommand(ssId, pVar, stringOut, reply, 1);


  status = writeRead(ssId, pVar, pVar->abortCommand, pVar->stringIn);
  return(-2);
 }
 if (pVar->debugLevel) printf("PLANESTATUS = '%s'\n", reply);
 pVar->loadingTrajectory = 0;
 if (pVar->debugLevel) printf("loadTrajectory: normal exit after %.1f s wait\n", i/10.);
 return(0);

bad:
 printf("loadTrajectory: error\n");

 strcpy(stringOut, "TASKSTATE(1)");
 status = writeRead(ssId, pVar, stringOut, reply);
 printf("TASKSTATE(1) returns '%s'\n", reply);
 strcpy(stringOut, "TASKERROR(1)");
 status = writeRead(ssId, pVar, stringOut, reply);
 printf("TASKERROR(1) returns '%s'\n", reply);
 strcpy(stringOut, "PLANESTATUS(0)");
 status = writeRead(ssId, pVar, stringOut, reply);
 printf("PLANESTATUS(0) returns '%s'\n", reply);
 strcpy(stringOut, "AXISSTATUS(@0)");
 status = writeRead(ssId, pVar, stringOut, reply);
 printf("AXISSTATUS(@0) returns '%s' (%x)\n", reply, atoi(&reply[1]));
 pVar->loadingTrajectory = 0;

 printf("loadTrajectory: aborting because of error\n");

abort:
 printf("loadTrajectory: aborted\n");
 strcpy(stringOut, "VELOCITY OFF");
 status = sendReceiveCommand(ssId, pVar, stringOut, reply, 1);
 strcpy(stringOut, "STARTABORT");
 status = sendReceiveCommand(ssId, pVar, stringOut, reply, 1);
 status = writeRead(ssId, pVar, pVar->abortCommand, pVar->stringIn);
 pVar->abortState = 2;
 pVar->loadingTrajectory = 0;
 if (pVar->pulseMode != 3) {
  strcpy(stringOut, "PSOCONTROL @0 OFF");
  status = writeRead(ssId, pVar, stringOut, reply);
 }
 return(-1);
}

double eval_fStart(double fStart, double *motorReadbacks, double scopeDataInterval, int nScopeDataPoints,
 double *motorTrajectory, double *realTimeTrajectory, int npoints);
int parabola(double *x, double *y, int npts, double *xFit);

static double trajEval(SS_ID ssId, struct UserVar *pVar, double *motorReadbacks, int scopeDataIntervalMS, int nScopeDataPoints,
 double *motorTrajectory, double *realTimeTrajectory, int npoints, double *motorError) {

 int i, rStart, lower, iThis;
 double fStart, fThis, frac, interp, scopeDataInterval = scopeDataIntervalMS*.001;
 double p;


 double fTry, x[10], y[10];
 int nTry;


 lower = motorReadbacks[0] < motorTrajectory[0];
 for (rStart=0; rStart < nScopeDataPoints/2; rStart++) {
  if (pVar->debugLevel>5) printf("trajEval: motorReadbacks[rStart]=%f, motorTrajectory[0]=%f\n", motorReadbacks[rStart], motorTrajectory[0]);
  if ((motorReadbacks[rStart] > motorTrajectory[0]) == lower) break;
 }
 if (rStart>1 && fabs(motorReadbacks[rStart] - motorReadbacks[rStart-1]) > 1.e-3) {
  frac = (motorTrajectory[0] - motorReadbacks[rStart-1]) / (motorReadbacks[rStart] - motorReadbacks[rStart-1]);
 } else {
  frac = 0.;
 }
 fStart = 0.;
 frac = 0.;
 if (rStart>0) {
  fStart = (rStart-1) + frac;
 }
 if (pVar->debugLevel>5) printf("trajEval: rStart=%d, frac=%f, fStart=%f\n", rStart, frac, fStart);


 fTry = ((0) > (fStart-2) ? (0) : (fStart-2));
 nTry = 5;
 for (i=0; i<nTry; i++, fTry += 1) {
  x[i] = fTry;
  y[i] = eval_fStart(fTry, motorReadbacks, scopeDataInterval, nScopeDataPoints, motorTrajectory, realTimeTrajectory, npoints);
 }
 i = parabola(x, y, nTry, &fTry);
 if (i==0) fStart = fTry;
 if (pVar->debugLevel>5) printf("trajEval: fStart=%f\n", fStart);


 for (i=0; i<npoints; i++) {
  fThis = fStart + (realTimeTrajectory[i] - realTimeTrajectory[0])/scopeDataInterval;
  iThis = floor(fThis);
  if (iThis+1 < nScopeDataPoints) {
   if (pVar->debugLevel>5) printf("trajEval: iThis=%d, motorReadbacks[iThis]=%f\n", iThis, motorReadbacks[iThis]);
   p = fThis-iThis;
   if ((iThis > 0) && (iThis+2 < nScopeDataPoints)) {

    interp = (-p*(p-1)*(p-2)/6)*motorReadbacks[iThis-1] +
      ((p*p-1)*(p-2)/2)*motorReadbacks[iThis] +
      (-p*(p+1)*(p-2)/2)*motorReadbacks[iThis+1] +
      (p*(p*p-1)/6)*motorReadbacks[iThis+2];
   } else if ((iThis > 0) && (iThis+1 < nScopeDataPoints)) {

    interp = (p*(p-1)/2)*motorReadbacks[iThis-1] + (1-p*p)*motorReadbacks[iThis] + (p*(p+1)/2)*motorReadbacks[iThis+1];
   } else {

    interp = motorReadbacks[iThis] + (motorReadbacks[iThis+1] - motorReadbacks[iThis])*p;
   }
   if (pVar->debugLevel>5) printf("trajEval: fThis=%f, interp=%f, motorTrajectory[%d]=%f, \n", fThis, interp, i, motorTrajectory[i]);
   motorReadbacks[i] = interp;
   motorError[i] = interp - motorTrajectory[i];
  } else {
   motorReadbacks[i] = 0;
   motorError[i] = 0;
  }
 }
 for(; i<nScopeDataPoints; i++) {
  motorReadbacks[i] = 0;
  motorError[i] = 0;
 }
 return(0.);
}

double eval_fStart(double fStart, double *motorReadbacks, double scopeDataInterval, int nScopeDataPoints,
 double *motorTrajectory, double *realTimeTrajectory, int npoints) {

 double fThis, p, interp, chisq = 0;
 int i, iThis, numChi = 0;


 for (i=0; i<npoints; i++) {
  fThis = fStart + (realTimeTrajectory[i] - realTimeTrajectory[0])/scopeDataInterval;
  iThis = floor(fThis);
  if (iThis+1 < nScopeDataPoints) {

   p = fThis-iThis;
   if ((iThis > 0) && (iThis+2 < nScopeDataPoints)) {

    interp = (-p*(p-1)*(p-2)/6)*motorReadbacks[iThis-1] +
      ((p*p-1)*(p-2)/2)*motorReadbacks[iThis] +
      (-p*(p+1)*(p-2)/2)*motorReadbacks[iThis+1] +
      (p*(p*p-1)/6)*motorReadbacks[iThis+2];
   } else if ((iThis > 0) && (iThis+1 < nScopeDataPoints)) {

    interp = (p*(p-1)/2)*motorReadbacks[iThis-1] + (1-p*p)*motorReadbacks[iThis] + (p*(p+1)/2)*motorReadbacks[iThis+1];
   } else {

    interp = motorReadbacks[iThis] + (motorReadbacks[iThis+1] - motorReadbacks[iThis])*p;
   }

   chisq += (interp - motorTrajectory[i]) * (interp - motorTrajectory[i]);
   numChi++;
  }
 }
 return(chisq/numChi);
}



int parabola(double *x, double *y, int npts, double *xFit) {

 double xf, yf;
 double xx, yy, xi, xi2, xi3, xi4, yi, yixi, yixi2;
 int i;
 double numer, denom;
 double xmin=1e10, xmax=-1e10;


 xi = yi = yixi = xi2 = yixi2 = xi3 = xi4 = 0.0;
 for (i=0; i<npts; i++) {
  xmin = ((xmin) > (x[i]) ? (x[i]) : (xmin));
  xmax = ((xmax) > (x[i]) ? (xmax) : (x[i]));
  xi += (xx = x[i]);
  yi += (yy = y[i]);
  yixi += yy * xx;
  xi2 += (xx *=x[i]);
  yixi2 += yy * xx;
  xi3 += (xx *= x[i]);
  xi4 += xx * x[i];
 }


 xi /= npts;
 xi2 /= npts;
 xi3 /= npts;
 xi4 /= npts;
 yi /= npts;
 yixi /= npts;
 yixi2 /= npts;


 numer = yi*(xi2*xi3 - xi*xi4) + yixi*(xi4 - xi2*xi2) + yixi2*(xi*xi2 - xi3);
 denom = 2*(yi*(xi2*xi2 - xi*xi3) + yixi*(xi3 - xi*xi2) + yixi2*(xi*xi - xi2));

 if (fabs(denom) < 1e-8) return(-1);
 xf = numer / denom;
 if ((xf < xmin) || (xf > xmax)) return(-1);

 numer = (xf*xf - 2*xf*xi + xi2) * (yixi2 - yi*xi2);
 denom = 2*xf*(xi*xi2 - xi3) - xi2*xi2 + xi4;
 yf = yi - numer/denom;
 if (fabs(denom) < 1e-8) return(-1);

 *xFit = xf;
 return(0);
}



/* Register sequencer commands and program */
#include "epicsExport.h"
static void EnsembleTrajectoryScanRegistrar (void) {
    seqRegisterSequencerCommands();
    seqRegisterSequencerProgram (&EnsembleTrajectoryScan);
}
epicsExportRegistrar(EnsembleTrajectoryScanRegistrar);
