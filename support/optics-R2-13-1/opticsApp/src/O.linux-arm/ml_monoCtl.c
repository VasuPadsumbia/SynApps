/* C code for program ml_monoCtl, generated by snc from ../ml_monoCtl.st */
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>

#include "seq_snc.h"
# line 76 "../ml_monoCtl.st"
static const EF_ID Order_mon = 1;
# line 82 "../ml_monoCtl.st"
static const EF_ID D_mon = 2;
# line 91 "../ml_monoCtl.st"
static const EF_ID E_mon = 3;
# line 106 "../ml_monoCtl.st"
static const EF_ID lambda_mon = 4;
# line 121 "../ml_monoCtl.st"
static const EF_ID theta_mon = 5;
# line 205 "../ml_monoCtl.st"
static const EF_ID thetaDmov_mon = 6;
# line 211 "../ml_monoCtl.st"
static const EF_ID theta2Dmov_mon = 7;
# line 217 "../ml_monoCtl.st"
static const EF_ID zDmov_mon = 8;
# line 260 "../ml_monoCtl.st"
static const EF_ID thetaMotHiLim_mon = 9;
# line 266 "../ml_monoCtl.st"
static const EF_ID thetaMotLoLim_mon = 10;
# line 272 "../ml_monoCtl.st"
static const EF_ID theta2MotHiLim_mon = 11;
# line 278 "../ml_monoCtl.st"
static const EF_ID theta2MotLoLim_mon = 12;
# line 301 "../ml_monoCtl.st"
static const EF_ID thetaMotCmdMon_mon = 13;
# line 307 "../ml_monoCtl.st"
static const EF_ID theta2MotCmdMon_mon = 14;
# line 313 "../ml_monoCtl.st"
static const EF_ID zMotCmdMon_mon = 15;
# line 323 "../ml_monoCtl.st"
static const EF_ID thetaMotVel_mon = 16;
# line 332 "../ml_monoCtl.st"
static const EF_ID theta2MotVel_mon = 17;
# line 341 "../ml_monoCtl.st"
static const EF_ID zMotVel_mon = 18;
# line 347 "../ml_monoCtl.st"
static const EF_ID thetaMotRdbk_mon = 19;
# line 349 "../ml_monoCtl.st"
static const EF_ID thetaMotRdbkPseudo_mon = 20;
# line 354 "../ml_monoCtl.st"
static const EF_ID theta2MotRdbk_mon = 21;
# line 356 "../ml_monoCtl.st"
static const EF_ID theta2MotRdbkPseudo_mon = 22;
# line 361 "../ml_monoCtl.st"
static const EF_ID zMotRdbk_mon = 23;
# line 367 "../ml_monoCtl.st"
static const EF_ID yMotRdbk_mon = 24;
# line 374 "../ml_monoCtl.st"
static const EF_ID useSetMode_mon = 25;
# line 380 "../ml_monoCtl.st"
static const EF_ID thetaMotSet_mon = 26;
# line 386 "../ml_monoCtl.st"
static const EF_ID theta2MotSet_mon = 27;
# line 392 "../ml_monoCtl.st"
static const EF_ID zMotSet_mon = 28;
# line 436 "../ml_monoCtl.st"
static const EF_ID yOffset_mon = 29;
# line 445 "../ml_monoCtl.st"
#include <string.h>
# line 446 "../ml_monoCtl.st"
#include <math.h>
# line 447 "../ml_monoCtl.st"
#include <stdlib.h>
# line 449 "../ml_monoCtl.st"
double ml_monoCtl_calc2dSpacing();
# line 450 "../ml_monoCtl.st"
char *ml_monoCtl_pmacP;
# line 451 "../ml_monoCtl.st"
char *ml_monoCtl_pmacM;
# line 452 "../ml_monoCtl.st"
char *ml_monoCtl_pmacGEOM;
# line 453 "../ml_monoCtl.st"
char *ml_monoCtl_pmacY_OFF;

/* Variable declarations */
# line 26 "../ml_monoCtl.st"
static	short ml_monoCtlDebug;
# line 30 "../ml_monoCtl.st"
static	string seqMsg1;
# line 33 "../ml_monoCtl.st"
static	string seqMsg2;
# line 36 "../ml_monoCtl.st"
static	short opAlert;
# line 39 "../ml_monoCtl.st"
static	short opAck;
# line 47 "../ml_monoCtl.st"
static	short putVals;
# line 55 "../ml_monoCtl.st"
static	short autoMode;
# line 62 "../ml_monoCtl.st"
static	short ccMode;
# line 66 "../ml_monoCtl.st"
static	short ml_monoMoving;
# line 70 "../ml_monoCtl.st"
static	short ml_monoDone;
# line 73 "../ml_monoCtl.st"
static	double Order;
# line 79 "../ml_monoCtl.st"
static	double D;
# line 85 "../ml_monoCtl.st"
static	double TwoD;
# line 88 "../ml_monoCtl.st"
static	double E;
# line 94 "../ml_monoCtl.st"
static	double EHi;
# line 97 "../ml_monoCtl.st"
static	double ELo;
# line 100 "../ml_monoCtl.st"
static	double ERdbk;
# line 103 "../ml_monoCtl.st"
static	double lambda;
# line 109 "../ml_monoCtl.st"
static	double lambdaHi;
# line 112 "../ml_monoCtl.st"
static	double lambdaLo;
# line 115 "../ml_monoCtl.st"
static	double lambdaRdbk;
# line 118 "../ml_monoCtl.st"
static	double theta;
# line 124 "../ml_monoCtl.st"
static	double thetaHi;
# line 127 "../ml_monoCtl.st"
static	double thetaLo;
# line 130 "../ml_monoCtl.st"
static	double thetaRdbk;
# line 139 "../ml_monoCtl.st"
static	string thetaMotName;
# line 142 "../ml_monoCtl.st"
static	string theta2MotName;
# line 145 "../ml_monoCtl.st"
static	string zMotName;
# line 148 "../ml_monoCtl.st"
static	string yMotName;
# line 151 "../ml_monoCtl.st"
static	double thetaMotCmdEcho;
# line 154 "../ml_monoCtl.st"
static	double theta2MotCmdEcho;
# line 157 "../ml_monoCtl.st"
static	double zMotCmdEcho;
# line 160 "../ml_monoCtl.st"
static	double thetaMotRdbkEcho;
# line 163 "../ml_monoCtl.st"
static	double theta2MotRdbkEcho;
# line 166 "../ml_monoCtl.st"
static	double zMotRdbkEcho;
# line 169 "../ml_monoCtl.st"
static	double thetaMotVelEcho;
# line 172 "../ml_monoCtl.st"
static	double theta2MotVelEcho;
# line 175 "../ml_monoCtl.st"
static	double zMotVelEcho;
# line 178 "../ml_monoCtl.st"
static	short thetaDmovEcho;
# line 181 "../ml_monoCtl.st"
static	short theta2DmovEcho;
# line 184 "../ml_monoCtl.st"
static	short zDmovEcho;
# line 193 "../ml_monoCtl.st"
static	short thetaMotStop;
# line 196 "../ml_monoCtl.st"
static	short theta2MotStop;
# line 199 "../ml_monoCtl.st"
static	short zStop;
# line 202 "../ml_monoCtl.st"
static	short thetaDmov;
# line 208 "../ml_monoCtl.st"
static	short theta2Dmov;
# line 214 "../ml_monoCtl.st"
static	short zDmov;
# line 221 "../ml_monoCtl.st"
static	short thetaHls;
# line 225 "../ml_monoCtl.st"
static	short thetaLls;
# line 229 "../ml_monoCtl.st"
static	short theta2Hls;
# line 233 "../ml_monoCtl.st"
static	short theta2Lls;
# line 237 "../ml_monoCtl.st"
static	short zHls;
# line 241 "../ml_monoCtl.st"
static	short zLls;
# line 245 "../ml_monoCtl.st"
static	double thetaMotDesired;
# line 249 "../ml_monoCtl.st"
static	double theta2MotDesired;
# line 253 "../ml_monoCtl.st"
static	double zMotDesired;
# line 257 "../ml_monoCtl.st"
static	double thetaMotHiLim;
# line 263 "../ml_monoCtl.st"
static	double thetaMotLoLim;
# line 269 "../ml_monoCtl.st"
static	double theta2MotHiLim;
# line 275 "../ml_monoCtl.st"
static	double theta2MotLoLim;
# line 281 "../ml_monoCtl.st"
static	double zMotHiLim;
# line 285 "../ml_monoCtl.st"
static	double zMotLoLim;
# line 289 "../ml_monoCtl.st"
static	double thetaMotCmd;
# line 292 "../ml_monoCtl.st"
static	double theta2MotCmd;
# line 295 "../ml_monoCtl.st"
static	double zMotCmd;
# line 298 "../ml_monoCtl.st"
static	double thetaMotCmdMon;
# line 304 "../ml_monoCtl.st"
static	double theta2MotCmdMon;
# line 310 "../ml_monoCtl.st"
static	double zMotCmdMon;
# line 317 "../ml_monoCtl.st"
static	double thTime;
# line 318 "../ml_monoCtl.st"
static	double oldThSpeed;
# line 319 "../ml_monoCtl.st"
static	double newThSpeed;
# line 320 "../ml_monoCtl.st"
static	double thSpeed;
# line 327 "../ml_monoCtl.st"
static	double oldTh2Speed;
# line 328 "../ml_monoCtl.st"
static	double newTh2Speed;
# line 329 "../ml_monoCtl.st"
static	double th2Speed;
# line 335 "../ml_monoCtl.st"
static	double zTime;
# line 336 "../ml_monoCtl.st"
static	double oldZSpeed;
# line 337 "../ml_monoCtl.st"
static	double newZSpeed;
# line 338 "../ml_monoCtl.st"
static	double zSpeed;
# line 344 "../ml_monoCtl.st"
static	double thetaMotRdbk;
# line 351 "../ml_monoCtl.st"
static	double theta2MotRdbk;
# line 358 "../ml_monoCtl.st"
static	double zMotRdbk;
# line 364 "../ml_monoCtl.st"
static	double yMotRdbk;
# line 371 "../ml_monoCtl.st"
static	short useSetMode;
# line 377 "../ml_monoCtl.st"
static	short thetaMotSet;
# line 383 "../ml_monoCtl.st"
static	short theta2MotSet;
# line 389 "../ml_monoCtl.st"
static	short zMotSet;
# line 396 "../ml_monoCtl.st"
static	double ETweakVal;
# line 400 "../ml_monoCtl.st"
static	short ETweakInc;
# line 404 "../ml_monoCtl.st"
static	short ETweakDec;
# line 408 "../ml_monoCtl.st"
static	double LTweakVal;
# line 412 "../ml_monoCtl.st"
static	short LTweakInc;
# line 416 "../ml_monoCtl.st"
static	short LTweakDec;
# line 420 "../ml_monoCtl.st"
static	double thTweakVal;
# line 424 "../ml_monoCtl.st"
static	short thTweakInc;
# line 428 "../ml_monoCtl.st"
static	short thTweakDec;
# line 433 "../ml_monoCtl.st"
static	double yOffset;
# line 439 "../ml_monoCtl.st"
static	double yOffsetHi;
# line 442 "../ml_monoCtl.st"
static	double yOffsetLo;
# line 454 "../ml_monoCtl.st"
static	short geom;
# line 456 "../ml_monoCtl.st"
static	short causedMove;
# line 457 "../ml_monoCtl.st"
static	short initSeq;
# line 458 "../ml_monoCtl.st"
static	short initSeqDone;
# line 460 "../ml_monoCtl.st"
static	double hc;
# line 461 "../ml_monoCtl.st"
static	double radConv;
# line 462 "../ml_monoCtl.st"
static	double temp;


/* Function declarations */

#define seqg_var (*(struct seqg_vars *const *)seqg_env)

/* Program init func */
static void seqg_init(PROG_ID seqg_env)
{
}

/****** Code for state "init" in state set "ml_monoCtl" ******/

/* Event function for state "init" in state set "ml_monoCtl" */
static seqBool seqg_event_ml_monoCtl_0_init(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "init" in state set "ml_monoCtl" */
static void seqg_action_ml_monoCtl_0_init(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 467 "../ml_monoCtl.st"
			initSeq = 0;
# line 468 "../ml_monoCtl.st"
			hc = 12.3984244;
# line 469 "../ml_monoCtl.st"
			radConv = 57.2958;
		}
		return;
	}
}

/****** Code for state "initSequence" in state set "ml_monoCtl" ******/

/* Event function for state "initSequence" in state set "ml_monoCtl" */
static seqBool seqg_event_ml_monoCtl_0_initSequence(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 475 "../ml_monoCtl.st"
	if (initSeq == 0)
	{
		*seqg_pnst = 5;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 542 "../ml_monoCtl.st"
	if (initSeq == 1)
	{
		*seqg_pnst = 15;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 547 "../ml_monoCtl.st"
	if (initSeq == 2)
	{
		*seqg_pnst = 13;
		*seqg_ptrn = 2;
		return TRUE;
	}
# line 552 "../ml_monoCtl.st"
	if ((initSeq == 3) && seq_delay(seqg_env, 1.))
	{
		*seqg_pnst = 9;
		*seqg_ptrn = 3;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "initSequence" in state set "ml_monoCtl" */
static void seqg_action_ml_monoCtl_0_initSequence(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 476 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:initSequence:initSeq=0\n");
# line 477 "../ml_monoCtl.st"
			thetaMotStop = 1;
# line 478 "../ml_monoCtl.st"
			theta2MotStop = 1;
# line 479 "../ml_monoCtl.st"
			zStop = 1;
# line 480 "../ml_monoCtl.st"
			putVals = 0;
# line 481 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 5/*putVals*/, DEFAULT, DEFAULT_TIMEOUT);
# line 482 "../ml_monoCtl.st"
			autoMode = 0;
# line 483 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 6/*autoMode*/, DEFAULT, DEFAULT_TIMEOUT);
# line 484 "../ml_monoCtl.st"
			opAck = 0;
# line 485 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 4/*opAck*/, DEFAULT, DEFAULT_TIMEOUT);
			
  ml_monoCtl_pmacP = seq_macValueGet(ssId,"P");
  ml_monoCtl_pmacM = seq_macValueGet(ssId,"M_THETA");
  if (ml_monoCtl_pmacP == 0 || ml_monoCtl_pmacM == 0) {
   sprintf(thetaMotName,"None");
  } else {
   strcpy(thetaMotName, ml_monoCtl_pmacP);
   strcat(thetaMotName, ml_monoCtl_pmacM);
  }

  ml_monoCtl_pmacM = seq_macValueGet(ssId,"M_THETA2");
  if (ml_monoCtl_pmacP == 0 || ml_monoCtl_pmacM == 0) {
   sprintf(theta2MotName,"None");
  } else {
   strcpy(theta2MotName, ml_monoCtl_pmacP);
   strcat(theta2MotName, ml_monoCtl_pmacM);
  }

  ml_monoCtl_pmacM = seq_macValueGet(ssId,"M_Z");
  if (ml_monoCtl_pmacP == 0 || ml_monoCtl_pmacM == 0) {
   sprintf(zMotName,"None");
  } else {
   strcpy(zMotName, ml_monoCtl_pmacP);
   strcat(zMotName, ml_monoCtl_pmacM);
  }

  ml_monoCtl_pmacM = seq_macValueGet(ssId,"M_Y");
  if (ml_monoCtl_pmacP == 0 || ml_monoCtl_pmacM == 0) {
   sprintf(yMotName,"None");
  } else {
   strcpy(yMotName, ml_monoCtl_pmacP);
   strcat(yMotName, ml_monoCtl_pmacM);
  }


  ml_monoCtl_pmacY_OFF = seq_macValueGet(ssId,"Y_OFF");
  yOffset = atof(ml_monoCtl_pmacY_OFF);
  if ((yOffset < 1) || (yOffset > 60.))
   yOffset = 35.;

  ml_monoCtl_pmacGEOM = seq_macValueGet(ssId,"GEOM");
  geom = 1;


# line 532 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 86/*yOffset*/, DEFAULT, DEFAULT_TIMEOUT);
# line 533 "../ml_monoCtl.st"
			if (geom == 1)
			{
			}
# line 535 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 23/*thetaMotName*/, DEFAULT, DEFAULT_TIMEOUT);
# line 536 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 24/*theta2MotName*/, DEFAULT, DEFAULT_TIMEOUT);
# line 537 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 25/*zMotName*/, DEFAULT, DEFAULT_TIMEOUT);
# line 538 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 26/*yMotName*/, DEFAULT, DEFAULT_TIMEOUT);
# line 539 "../ml_monoCtl.st"
			initSeq = 1;
		}
		return;
	case 1:
		{
# line 543 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:initSequence:initSeq=1\n");
# line 544 "../ml_monoCtl.st"
			initSeq = 2;
		}
		return;
	case 2:
		{
# line 548 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:initSequence:initSeq=2\n");
# line 549 "../ml_monoCtl.st"
			initSeq = 3;
		}
		return;
	case 3:
		{
# line 553 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:initSequence:initSeq=3\n");
# line 554 "../ml_monoCtl.st"
			sprintf(seqMsg1, "ml_mono Control Ready");
# line 555 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 556 "../ml_monoCtl.st"
			sprintf(seqMsg2, " ");
# line 557 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
# line 558 "../ml_monoCtl.st"
			initSeqDone = 1;
# line 559 "../ml_monoCtl.st"
			theta = thetaMotRdbk;
# line 560 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 19/*theta*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "waitForCmndEnter" in state set "ml_monoCtl" ******/

/* Event function for state "waitForCmndEnter" in state set "ml_monoCtl" */
static seqBool seqg_event_ml_monoCtl_0_waitForCmndEnter(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 565 "../ml_monoCtl.st"
	if (initSeqDone && seq_delay(seqg_env, .1))
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 620 "../ml_monoCtl.st"
	if (!initSeqDone)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 1;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "waitForCmndEnter" in state set "ml_monoCtl" */
static void seqg_action_ml_monoCtl_0_waitForCmndEnter(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 566 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:waitForCmndEnter:initSeqDone\n");
# line 567 "../ml_monoCtl.st"
			seq_efClear(seqg_env, Order_mon);
# line 568 "../ml_monoCtl.st"
			seq_efClear(seqg_env, D_mon);
# line 569 "../ml_monoCtl.st"
			seq_efClear(seqg_env, E_mon);
# line 570 "../ml_monoCtl.st"
			seq_efClear(seqg_env, lambda_mon);
# line 571 "../ml_monoCtl.st"
			seq_efClear(seqg_env, theta_mon);
# line 573 "../ml_monoCtl.st"
			thetaMotRdbkEcho = thetaMotRdbk;
# line 574 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 30/*thetaMotRdbkEcho*/, DEFAULT, DEFAULT_TIMEOUT);
# line 575 "../ml_monoCtl.st"
			theta2MotRdbkEcho = theta2MotRdbk;
# line 576 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 31/*theta2MotRdbkEcho*/, DEFAULT, DEFAULT_TIMEOUT);
# line 577 "../ml_monoCtl.st"
			zMotRdbkEcho = zMotRdbk;
# line 578 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 32/*zMotRdbkEcho*/, DEFAULT, DEFAULT_TIMEOUT);
# line 579 "../ml_monoCtl.st"
			yOffset = yMotRdbk;
# line 580 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 86/*yOffset*/, DEFAULT, DEFAULT_TIMEOUT);
# line 581 "../ml_monoCtl.st"
			thetaMotVelEcho = thSpeed;
# line 582 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 33/*thetaMotVelEcho*/, DEFAULT, DEFAULT_TIMEOUT);
# line 583 "../ml_monoCtl.st"
			theta2MotVelEcho = th2Speed;
# line 584 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 34/*theta2MotVelEcho*/, DEFAULT, DEFAULT_TIMEOUT);
# line 585 "../ml_monoCtl.st"
			zMotVelEcho = zSpeed;
# line 586 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 35/*zMotVelEcho*/, DEFAULT, DEFAULT_TIMEOUT);
# line 587 "../ml_monoCtl.st"
			thetaMotCmdEcho = thetaMotCmdMon;
# line 588 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 27/*thetaMotCmdEcho*/, DEFAULT, DEFAULT_TIMEOUT);
# line 589 "../ml_monoCtl.st"
			theta2MotCmdEcho = theta2MotCmdMon;
# line 590 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 28/*theta2MotCmdEcho*/, DEFAULT, DEFAULT_TIMEOUT);
# line 591 "../ml_monoCtl.st"
			zMotCmdEcho = zMotCmdMon;
# line 592 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 29/*zMotCmdEcho*/, DEFAULT, DEFAULT_TIMEOUT);
# line 593 "../ml_monoCtl.st"
			thetaDmovEcho = thetaDmov;
# line 594 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 36/*thetaDmovEcho*/, DEFAULT, DEFAULT_TIMEOUT);
# line 595 "../ml_monoCtl.st"
			theta2DmovEcho = theta2Dmov;
# line 596 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 37/*theta2DmovEcho*/, DEFAULT, DEFAULT_TIMEOUT);
# line 597 "../ml_monoCtl.st"
			zDmovEcho = zDmov;
# line 598 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 38/*zDmovEcho*/, DEFAULT, DEFAULT_TIMEOUT);
# line 599 "../ml_monoCtl.st"
			if (autoMode || useSetMode)
			{
# line 600 "../ml_monoCtl.st"
				thetaRdbk = thetaMotRdbk;
# line 601 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 22/*thetaRdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 602 "../ml_monoCtl.st"
				lambdaRdbk = TwoD * sin(thetaRdbk / radConv);
# line 603 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 18/*lambdaRdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 604 "../ml_monoCtl.st"
				ERdbk = hc / lambdaRdbk;
# line 605 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 14/*ERdbk*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 607 "../ml_monoCtl.st"
			opAck = 0;
# line 608 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 4/*opAck*/, DEFAULT, DEFAULT_TIMEOUT);
# line 609 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
			{
				/* C code definitions */
# line 610 "../ml_monoCtl.st"
				printf("ml_monoCtl:waitForCmndEnter: ml_monoMoving=%d; ml_monoDone=%d\n",
# line 611 "../ml_monoCtl.st"
				ml_monoMoving, ml_monoDone);
			}
# line 613 "../ml_monoCtl.st"
			if (ml_monoMoving && ml_monoDone)
			{
# line 614 "../ml_monoCtl.st"
				if (ml_monoCtlDebug)
					printf("ml_monoCtl:waitForCmndEnter: asserting 'done'.\n");
# line 615 "../ml_monoCtl.st"
				ml_monoMoving = 0;
# line 615 "../ml_monoCtl.st"
				ml_monoDone = 0;
# line 616 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 8/*ml_monoMoving*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	case 1:
		{
		}
		return;
	}
}

/****** Code for state "waitForCmnd" in state set "ml_monoCtl" ******/

/* Event function for state "waitForCmnd" in state set "ml_monoCtl" */
static seqBool seqg_event_ml_monoCtl_0_waitForCmnd(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 625 "../ml_monoCtl.st"
	if (seq_efTest(seqg_env, Order_mon) || seq_efTest(seqg_env, D_mon))
	{
		*seqg_pnst = 5;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 635 "../ml_monoCtl.st"
	if (seq_efTest(seqg_env, thetaMotHiLim_mon) || seq_efTest(seqg_env, thetaMotLoLim_mon))
	{
		*seqg_pnst = 6;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 645 "../ml_monoCtl.st"
	if (seq_efTest(seqg_env, theta2MotHiLim_mon) || seq_efTest(seqg_env, theta2MotLoLim_mon))
	{
		*seqg_pnst = 6;
		*seqg_ptrn = 2;
		return TRUE;
	}
# line 655 "../ml_monoCtl.st"
	if (seq_efTestAndClear(seqg_env, thetaMotRdbk_mon))
	{
		*seqg_pnst = 13;
		*seqg_ptrn = 3;
		return TRUE;
	}
# line 662 "../ml_monoCtl.st"
	if (seq_efTestAndClear(seqg_env, theta2MotRdbk_mon))
	{
		*seqg_pnst = 13;
		*seqg_ptrn = 4;
		return TRUE;
	}
# line 669 "../ml_monoCtl.st"
	if (seq_efTestAndClear(seqg_env, E_mon))
	{
		*seqg_pnst = 7;
		*seqg_ptrn = 5;
		return TRUE;
	}
# line 673 "../ml_monoCtl.st"
	if (seq_efTestAndClear(seqg_env, lambda_mon))
	{
		*seqg_pnst = 8;
		*seqg_ptrn = 6;
		return TRUE;
	}
# line 677 "../ml_monoCtl.st"
	if (seq_efTestAndClear(seqg_env, theta_mon))
	{
		*seqg_pnst = 9;
		*seqg_ptrn = 7;
		return TRUE;
	}
# line 681 "../ml_monoCtl.st"
	if (putVals && seq_delay(seqg_env, .1))
	{
		*seqg_pnst = 11;
		*seqg_ptrn = 8;
		return TRUE;
	}
# line 685 "../ml_monoCtl.st"
	if (ETweakInc || ETweakDec || LTweakInc || LTweakDec || thTweakInc || thTweakDec)
	{
		*seqg_pnst = 4;
		*seqg_ptrn = 9;
		return TRUE;
	}
# line 689 "../ml_monoCtl.st"
	if (seq_efTestAndClear(seqg_env, yOffset_mon) && initSeqDone)
	{
		*seqg_pnst = 10;
		*seqg_ptrn = 10;
		return TRUE;
	}
# line 699 "../ml_monoCtl.st"
	if (opAck)
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 11;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "waitForCmnd" in state set "ml_monoCtl" */
static void seqg_action_ml_monoCtl_0_waitForCmnd(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 626 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:waitForCmnd:Order/D_mon\n");
# line 627 "../ml_monoCtl.st"
			sprintf(seqMsg1, "Layer Spacing Changed");
# line 628 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 629 "../ml_monoCtl.st"
			sprintf(seqMsg2, " ");
# line 630 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
# line 631 "../ml_monoCtl.st"
			seq_efClear(seqg_env, Order_mon);
# line 632 "../ml_monoCtl.st"
			seq_efClear(seqg_env, D_mon);
		}
		return;
	case 1:
		{
# line 636 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:waitForCmnd:thetaMotXxLim_mon\n");
# line 637 "../ml_monoCtl.st"
			sprintf(seqMsg1, "Theta Motor Soft Limits Changed");
# line 638 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 639 "../ml_monoCtl.st"
			sprintf(seqMsg2, " ");
# line 640 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
# line 641 "../ml_monoCtl.st"
			seq_efClear(seqg_env, thetaMotHiLim_mon);
# line 642 "../ml_monoCtl.st"
			seq_efClear(seqg_env, thetaMotLoLim_mon);
		}
		return;
	case 2:
		{
# line 646 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:waitForCmnd:theta2MotXxLim_mon\n");
# line 647 "../ml_monoCtl.st"
			sprintf(seqMsg1, "Theta2 Motor Soft Limits Changed");
# line 648 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 649 "../ml_monoCtl.st"
			sprintf(seqMsg2, " ");
# line 650 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
# line 651 "../ml_monoCtl.st"
			seq_efClear(seqg_env, theta2MotHiLim_mon);
# line 652 "../ml_monoCtl.st"
			seq_efClear(seqg_env, theta2MotLoLim_mon);
		}
		return;
	case 3:
		{
# line 656 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:waitForCmnd:thetaMotRdbk_mon\n");
# line 657 "../ml_monoCtl.st"
			thetaMotRdbkEcho = thetaMotRdbk;
# line 658 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 30/*thetaMotRdbkEcho*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 4:
		{
# line 663 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:waitForCmnd:theta2MotRdbk_mon\n");
# line 664 "../ml_monoCtl.st"
			theta2MotRdbkEcho = theta2MotRdbk;
# line 665 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 31/*theta2MotRdbkEcho*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 5:
		{
# line 670 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:waitForCmnd:E_mon\n");
		}
		return;
	case 6:
		{
# line 674 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:waitForCmnd:lambda_mon\n");
		}
		return;
	case 7:
		{
# line 678 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:waitForCmnd:theta_mon\n");
		}
		return;
	case 8:
		{
# line 682 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:waitForCmnd:putVals\n");
		}
		return;
	case 9:
		{
# line 686 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:waitForCmnd:Tweak\n");
		}
		return;
	case 10:
		{
# line 690 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:waitForCmnd:yOffset_mon\n");
# line 691 "../ml_monoCtl.st"
			autoMode = 0;
# line 692 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 6/*autoMode*/, DEFAULT, DEFAULT_TIMEOUT);
# line 693 "../ml_monoCtl.st"
			sprintf(seqMsg1, "y offset changed to %f", yOffset);
# line 694 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 695 "../ml_monoCtl.st"
			sprintf(seqMsg2, "Set to Manual Mode");
# line 696 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 11:
		{
# line 700 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:waitForCmnd:opAck\n");
# line 701 "../ml_monoCtl.st"
			opAlert = 0;
# line 702 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
# line 703 "../ml_monoCtl.st"
			sprintf(seqMsg1, " ");
# line 704 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 705 "../ml_monoCtl.st"
			sprintf(seqMsg2, " ");
# line 706 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "tweak" in state set "ml_monoCtl" ******/

/* Event function for state "tweak" in state set "ml_monoCtl" */
static seqBool seqg_event_ml_monoCtl_0_tweak(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 711 "../ml_monoCtl.st"
	if (ETweakInc || ETweakDec)
	{
		*seqg_pnst = 7;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 732 "../ml_monoCtl.st"
	if (LTweakInc || LTweakDec)
	{
		*seqg_pnst = 8;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 753 "../ml_monoCtl.st"
	if (thTweakInc || thTweakDec)
	{
		*seqg_pnst = 9;
		*seqg_ptrn = 2;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "tweak" in state set "ml_monoCtl" */
static void seqg_action_ml_monoCtl_0_tweak(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 712 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:tweak:E+\n");
# line 713 "../ml_monoCtl.st"
			temp = E + ETweakVal * (ETweakInc ? 1 : -1);
# line 714 "../ml_monoCtl.st"
			if ((temp >= ELo) && (temp <= EHi))
			{
# line 715 "../ml_monoCtl.st"
				E = temp;
# line 716 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 11/*E*/, DEFAULT, DEFAULT_TIMEOUT);
			}
			else
			{
# line 718 "../ml_monoCtl.st"
				sprintf(seqMsg1, "E tweak exceeds limit");
# line 719 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 720 "../ml_monoCtl.st"
				opAlert = 1;
# line 721 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 723 "../ml_monoCtl.st"
			if (ETweakInc)
			{
# line 724 "../ml_monoCtl.st"
				ETweakInc = 0;
# line 725 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 78/*ETweakInc*/, DEFAULT, DEFAULT_TIMEOUT);
			}
			else
			{
# line 727 "../ml_monoCtl.st"
				ETweakDec = 0;
# line 728 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 79/*ETweakDec*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	case 1:
		{
# line 733 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:tweak:L\n");
# line 734 "../ml_monoCtl.st"
			temp = lambda + LTweakVal * (LTweakInc ? 1 : -1);
# line 735 "../ml_monoCtl.st"
			if ((temp >= lambdaLo) && (temp <= lambdaHi))
			{
# line 736 "../ml_monoCtl.st"
				lambda = temp;
# line 737 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 15/*lambda*/, DEFAULT, DEFAULT_TIMEOUT);
			}
			else
			{
# line 739 "../ml_monoCtl.st"
				sprintf(seqMsg1, "Lambda tweak exceeds limit");
# line 740 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 741 "../ml_monoCtl.st"
				opAlert = 1;
# line 742 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 744 "../ml_monoCtl.st"
			if (LTweakInc)
			{
# line 745 "../ml_monoCtl.st"
				LTweakInc = 0;
# line 746 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 81/*LTweakInc*/, DEFAULT, DEFAULT_TIMEOUT);
			}
			else
			{
# line 748 "../ml_monoCtl.st"
				LTweakDec = 0;
# line 749 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 82/*LTweakDec*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	case 2:
		{
# line 754 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:tweak:th\n");
# line 755 "../ml_monoCtl.st"
			temp = theta + thTweakVal * (thTweakInc ? 1 : -1);
# line 756 "../ml_monoCtl.st"
			if ((temp >= thetaLo) && (temp <= thetaHi))
			{
# line 757 "../ml_monoCtl.st"
				theta = temp;
# line 758 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 19/*theta*/, DEFAULT, DEFAULT_TIMEOUT);
			}
			else
			{
# line 760 "../ml_monoCtl.st"
				sprintf(seqMsg1, "Theta tweak exceeds limit");
# line 761 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 762 "../ml_monoCtl.st"
				opAlert = 1;
# line 763 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 765 "../ml_monoCtl.st"
			if (thTweakInc)
			{
# line 766 "../ml_monoCtl.st"
				thTweakInc = 0;
# line 767 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 84/*thTweakInc*/, DEFAULT, DEFAULT_TIMEOUT);
			}
			else
			{
# line 769 "../ml_monoCtl.st"
				thTweakDec = 0;
# line 770 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 85/*thTweakDec*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	}
}

/****** Code for state "dInputChanged" in state set "ml_monoCtl" ******/

/* Event function for state "dInputChanged" in state set "ml_monoCtl" */
static seqBool seqg_event_ml_monoCtl_0_dInputChanged(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 9;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "dInputChanged" in state set "ml_monoCtl" */
static void seqg_action_ml_monoCtl_0_dInputChanged(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 777 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:dInputChanged\n");
# line 778 "../ml_monoCtl.st"
			autoMode = 0;
# line 779 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 6/*autoMode*/, DEFAULT, DEFAULT_TIMEOUT);
# line 780 "../ml_monoCtl.st"
			sprintf(seqMsg2, "Set to Manual Mode");
# line 781 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
# line 782 "../ml_monoCtl.st"
			TwoD = ml_monoCtl_calc2dSpacing();
# line 783 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 784 "../ml_monoCtl.st"
			lambdaHi = TwoD * sin(thetaHi / radConv);
# line 785 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 16/*lambdaHi*/, DEFAULT, DEFAULT_TIMEOUT);
# line 786 "../ml_monoCtl.st"
			lambdaLo = TwoD * sin(thetaLo / radConv);
# line 787 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 17/*lambdaLo*/, DEFAULT, DEFAULT_TIMEOUT);
# line 788 "../ml_monoCtl.st"
			EHi = hc / lambdaLo;
# line 789 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 12/*EHi*/, DEFAULT, DEFAULT_TIMEOUT);
# line 790 "../ml_monoCtl.st"
			ELo = hc / lambdaHi;
# line 791 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 13/*ELo*/, DEFAULT, DEFAULT_TIMEOUT);
# line 792 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "thetaLimits" in state set "ml_monoCtl" ******/

/* Event function for state "thetaLimits" in state set "ml_monoCtl" */
static seqBool seqg_event_ml_monoCtl_0_thetaLimits(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 12;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "thetaLimits" in state set "ml_monoCtl" */
static void seqg_action_ml_monoCtl_0_thetaLimits(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 798 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:thetaLimits\n");
# line 799 "../ml_monoCtl.st"
			thetaHi = thetaMotHiLim;
# line 800 "../ml_monoCtl.st"
			thetaLo = thetaMotLoLim;
# line 801 "../ml_monoCtl.st"
			if (thetaHi > 89.0)
			{
# line 802 "../ml_monoCtl.st"
				thetaHi = 89.0;
# line 803 "../ml_monoCtl.st"
				sprintf(seqMsg2, "ThetaHiLim > 89 deg. (Using 89 deg.)");
# line 804 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 806 "../ml_monoCtl.st"
			if (thetaLo < 0.1)
			{
# line 807 "../ml_monoCtl.st"
				thetaLo = 0.1;
# line 808 "../ml_monoCtl.st"
				sprintf(seqMsg2, "ThetaLoLim < 0.1 deg. (Using 0.1 deg.)");
# line 809 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 811 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 20/*thetaHi*/, DEFAULT, DEFAULT_TIMEOUT);
# line 812 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 21/*thetaLo*/, DEFAULT, DEFAULT_TIMEOUT);
# line 813 "../ml_monoCtl.st"
			lambdaHi = TwoD * sin(thetaHi / radConv);
# line 814 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 16/*lambdaHi*/, DEFAULT, DEFAULT_TIMEOUT);
# line 815 "../ml_monoCtl.st"
			lambdaLo = TwoD * sin(thetaLo / radConv);
# line 816 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 17/*lambdaLo*/, DEFAULT, DEFAULT_TIMEOUT);
# line 817 "../ml_monoCtl.st"
			EHi = hc / lambdaLo;
# line 818 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 12/*EHi*/, DEFAULT, DEFAULT_TIMEOUT);
# line 819 "../ml_monoCtl.st"
			ELo = hc / lambdaHi;
# line 820 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 13/*ELo*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "eChanged" in state set "ml_monoCtl" ******/

/* Event function for state "eChanged" in state set "ml_monoCtl" */
static seqBool seqg_event_ml_monoCtl_0_eChanged(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 8;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "eChanged" in state set "ml_monoCtl" */
static void seqg_action_ml_monoCtl_0_eChanged(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 826 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:eChanged\n");
# line 827 "../ml_monoCtl.st"
			lambda = hc / E;
# line 828 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 15/*lambda*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "lChanged" in state set "ml_monoCtl" ******/

/* Event function for state "lChanged" in state set "ml_monoCtl" */
static seqBool seqg_event_ml_monoCtl_0_lChanged(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 833 "../ml_monoCtl.st"
	if (lambda > TwoD)
	{
		*seqg_pnst = 9;
		*seqg_ptrn = 0;
		return TRUE;
	}
	if (TRUE)
	{
		*seqg_pnst = 9;
		*seqg_ptrn = 1;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "lChanged" in state set "ml_monoCtl" */
static void seqg_action_ml_monoCtl_0_lChanged(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 834 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:lChanged: lambda>2*D\n");
# line 836 "../ml_monoCtl.st"
			sprintf(seqMsg1, "Wavelength > 2d spacing.");
# line 837 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 838 "../ml_monoCtl.st"
			opAlert = 1;
# line 839 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 1:
		{
# line 843 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:lChanged\n");
# line 844 "../ml_monoCtl.st"
			theta = radConv * asin(lambda / TwoD);
# line 845 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 19/*theta*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "thChanged" in state set "ml_monoCtl" ******/

/* Event function for state "thChanged" in state set "ml_monoCtl" */
static seqBool seqg_event_ml_monoCtl_0_thChanged(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 10;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "thChanged" in state set "ml_monoCtl" */
static void seqg_action_ml_monoCtl_0_thChanged(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 851 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:thChanged\n");
# line 852 "../ml_monoCtl.st"
			if ((theta <= thetaLo) || (theta >= thetaHi))
			{
# line 853 "../ml_monoCtl.st"
				sprintf(seqMsg1, "Theta constrained to LIMIT");
# line 854 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 855 "../ml_monoCtl.st"
				opAlert = 1;
# line 856 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
# line 857 "../ml_monoCtl.st"
				autoMode = 0;
# line 858 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 6/*autoMode*/, DEFAULT, DEFAULT_TIMEOUT);
# line 859 "../ml_monoCtl.st"
				sprintf(seqMsg2, "Set to Manual Mode");
# line 860 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 862 "../ml_monoCtl.st"
			lambda = TwoD * sin(theta / radConv);
# line 863 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 15/*lambda*/, DEFAULT, DEFAULT_TIMEOUT);
# line 864 "../ml_monoCtl.st"
			E = hc / lambda;
# line 865 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 11/*E*/, DEFAULT, DEFAULT_TIMEOUT);
# line 868 "../ml_monoCtl.st"
			thetaRdbk = thetaMotRdbk;
# line 869 "../ml_monoCtl.st"
			lambdaRdbk = TwoD * sin(thetaRdbk / radConv);
# line 870 "../ml_monoCtl.st"
			ERdbk = hc / lambdaRdbk;
# line 871 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 22/*thetaRdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 872 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 18/*lambdaRdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 873 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 14/*ERdbk*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "calcMovements" in state set "ml_monoCtl" ******/

/* Event function for state "calcMovements" in state set "ml_monoCtl" */
static seqBool seqg_event_ml_monoCtl_0_calcMovements(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 11;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "calcMovements" in state set "ml_monoCtl" */
static void seqg_action_ml_monoCtl_0_calcMovements(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 879 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:calcMovements\n");
# line 882 "../ml_monoCtl.st"
			thetaMotDesired = theta;
# line 883 "../ml_monoCtl.st"
			theta2MotDesired = theta;
# line 884 "../ml_monoCtl.st"
			if (geom == 1)
			{
# line 885 "../ml_monoCtl.st"
				zMotDesired = yOffset / tan(2 * theta / radConv);
			}
			else
			{
# line 887 "../ml_monoCtl.st"
				printf("ml_mono:calcMovements: unimplemented geom=%d\n", geom);
			}
# line 889 "../ml_monoCtl.st"
			if (ccMode != 1 && ((zMotDesired < zMotLoLim) || (zMotDesired > zMotHiLim)))
			{
# line 891 "../ml_monoCtl.st"
				sprintf(seqMsg1, "Z will exceed soft limits");
# line 892 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 893 "../ml_monoCtl.st"
				sprintf(seqMsg2, "Setting to Manual Mode");
# line 894 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
# line 895 "../ml_monoCtl.st"
				opAlert = 1;
# line 896 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
# line 897 "../ml_monoCtl.st"
				autoMode = 0;
# line 898 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 6/*autoMode*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 900 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 51/*thetaMotDesired*/, DEFAULT, DEFAULT_TIMEOUT);
# line 901 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 52/*theta2MotDesired*/, DEFAULT, DEFAULT_TIMEOUT);
# line 902 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 53/*zMotDesired*/, DEFAULT, DEFAULT_TIMEOUT);
# line 905 "../ml_monoCtl.st"
			oldThSpeed = thSpeed;
# line 906 "../ml_monoCtl.st"
			oldTh2Speed = th2Speed;
# line 907 "../ml_monoCtl.st"
			oldZSpeed = zSpeed;
# line 908 "../ml_monoCtl.st"
			zTime = fabs(zMotDesired - zMotRdbk) / zSpeed;
# line 909 "../ml_monoCtl.st"
			thTime = fabs(theta - thetaMotRdbk) / thSpeed;
# line 911 "../ml_monoCtl.st"
			if (ccMode == 1)
			{
# line 913 "../ml_monoCtl.st"
				zTime = 0.0;
			}
# line 916 "../ml_monoCtl.st"
			if (thTime >= zTime)
			{
# line 917 "../ml_monoCtl.st"
				newThSpeed = thSpeed;
# line 918 "../ml_monoCtl.st"
				newTh2Speed = th2Speed;
# line 919 "../ml_monoCtl.st"
				newZSpeed = fabs(zMotDesired - zMotRdbk) / thTime;
			}
			else
			{
# line 921 "../ml_monoCtl.st"
				newThSpeed = fabs(theta - thetaMotRdbk) / zTime;
# line 922 "../ml_monoCtl.st"
				newTh2Speed = newThSpeed;
# line 923 "../ml_monoCtl.st"
				newZSpeed = zSpeed;
			}
		}
		return;
	}
}

/****** Code for state "move_ml_mono" in state set "ml_monoCtl" ******/

/* Event function for state "move_ml_mono" in state set "ml_monoCtl" */
static seqBool seqg_event_ml_monoCtl_0_move_ml_mono(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 930 "../ml_monoCtl.st"
	if (autoMode || putVals || useSetMode)
	{
		*seqg_pnst = 13;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 953 "../ml_monoCtl.st"
	if (1)
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 1;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "move_ml_mono" in state set "ml_monoCtl" */
static void seqg_action_ml_monoCtl_0_move_ml_mono(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 931 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:move_ml_mono:auto|put\n");
# line 932 "../ml_monoCtl.st"
			thSpeed = newThSpeed;
# line 933 "../ml_monoCtl.st"
			th2Speed = newThSpeed;
# line 934 "../ml_monoCtl.st"
			zSpeed = newZSpeed;
# line 935 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 66/*thSpeed*/, DEFAULT, DEFAULT_TIMEOUT);
# line 936 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 67/*th2Speed*/, DEFAULT, DEFAULT_TIMEOUT);
# line 937 "../ml_monoCtl.st"
			if (ccMode == 0)
			{
# line 938 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 68/*zSpeed*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 940 "../ml_monoCtl.st"
			thetaMotCmd = thetaMotDesired;
# line 941 "../ml_monoCtl.st"
			theta2MotCmd = theta2MotDesired;
# line 942 "../ml_monoCtl.st"
			zMotCmd = zMotDesired;
# line 943 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 60/*thetaMotCmd*/, DEFAULT, DEFAULT_TIMEOUT);
# line 944 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 61/*theta2MotCmd*/, DEFAULT, DEFAULT_TIMEOUT);
# line 945 "../ml_monoCtl.st"
			if (ccMode == 0)
			{
# line 946 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 62/*zMotCmd*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 948 "../ml_monoCtl.st"
			putVals = 0;
# line 949 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 5/*putVals*/, DEFAULT, DEFAULT_TIMEOUT);
# line 950 "../ml_monoCtl.st"
			causedMove = 1;
		}
		return;
	case 1:
		{
# line 954 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:move_ml_mono\n");
		}
		return;
	}
}

/****** Code for state "checkDone" in state set "ml_monoCtl" ******/

/* Event function for state "checkDone" in state set "ml_monoCtl" */
static seqBool seqg_event_ml_monoCtl_0_checkDone(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 959 "../ml_monoCtl.st"
	if (thetaDmov && theta2Dmov && zDmov)
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 964 "../ml_monoCtl.st"
	if (!thetaDmov || !theta2Dmov || !zDmov)
	{
		*seqg_pnst = 13;
		*seqg_ptrn = 1;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "checkDone" in state set "ml_monoCtl" */
static void seqg_action_ml_monoCtl_0_checkDone(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 960 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:checkDone: done\n");
# line 961 "../ml_monoCtl.st"
			ml_monoDone = 1;
		}
		return;
	case 1:
		{
# line 965 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:checkDone: not done\n");
		}
		return;
	}
}

/****** Code for state "updateRdbk" in state set "ml_monoCtl" ******/

/* Event function for state "updateRdbk" in state set "ml_monoCtl" */
static seqBool seqg_event_ml_monoCtl_0_updateRdbk(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 971 "../ml_monoCtl.st"
	if (thetaMotRdbk == 0 || theta2MotRdbk == 0)
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 981 "../ml_monoCtl.st"
	if (thetaDmov && theta2Dmov && zDmov)
	{
		*seqg_pnst = 14;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 1001 "../ml_monoCtl.st"
	if (thetaHls || thetaLls || theta2Hls || theta2Lls)
	{
		*seqg_pnst = 17;
		*seqg_ptrn = 2;
		return TRUE;
	}
# line 1014 "../ml_monoCtl.st"
	if ((ccMode != 1) && (zHls || zLls))
	{
		*seqg_pnst = 17;
		*seqg_ptrn = 3;
		return TRUE;
	}
# line 1026 "../ml_monoCtl.st"
	if ((!thetaDmov || !theta2Dmov || !zDmov) && seq_delay(seqg_env, .1))
	{
		*seqg_pnst = 13;
		*seqg_ptrn = 4;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "updateRdbk" in state set "ml_monoCtl" */
static void seqg_action_ml_monoCtl_0_updateRdbk(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 972 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:updateRdbk:thetaMotRdbk==0\n");
# line 973 "../ml_monoCtl.st"
			sprintf(seqMsg1, "Theta Motor Readback is 0 !");
# line 974 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 975 "../ml_monoCtl.st"
			sprintf(seqMsg2, " ");
# line 976 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
# line 977 "../ml_monoCtl.st"
			opAlert = 1;
# line 978 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 1:
		{
# line 982 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
			{
				/* C code definitions */
# line 983 "../ml_monoCtl.st"
				printf("ml_monoCtl:updateRdbk:*Dmov (done=%d,moving=%d)\n",
# line 984 "../ml_monoCtl.st"
				ml_monoDone, ml_monoMoving);
			}
# line 986 "../ml_monoCtl.st"
			thetaRdbk = thetaMotRdbk;
# line 987 "../ml_monoCtl.st"
			lambdaRdbk = TwoD * sin(thetaRdbk / radConv);
# line 988 "../ml_monoCtl.st"
			ERdbk = hc / lambdaRdbk;
# line 989 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 22/*thetaRdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 990 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 18/*lambdaRdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 991 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 14/*ERdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 992 "../ml_monoCtl.st"
			ml_monoDone = 1;
# line 993 "../ml_monoCtl.st"
			seq_efSet(seqg_env, thetaMotRdbkPseudo_mon);
# line 994 "../ml_monoCtl.st"
			seq_efClear(seqg_env, thetaMotRdbk_mon);
# line 995 "../ml_monoCtl.st"
			seq_efSet(seqg_env, theta2MotRdbkPseudo_mon);
# line 996 "../ml_monoCtl.st"
			seq_efClear(seqg_env, theta2MotRdbk_mon);
# line 997 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:updateRdbk: done\n");
		}
		return;
	case 2:
		{
# line 1002 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:updateRdbk: Th limit switch\n");
# line 1003 "../ml_monoCtl.st"
			sprintf(seqMsg1, "Theta Motor hit a limit switch!");
# line 1004 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1005 "../ml_monoCtl.st"
			opAlert = 1;
# line 1006 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1007 "../ml_monoCtl.st"
			autoMode = 0;
# line 1008 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 6/*autoMode*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1009 "../ml_monoCtl.st"
			sprintf(seqMsg2, "Setting to Manual Mode");
# line 1010 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 3:
		{
# line 1015 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:updateRdbk: Z limit switch\n");
# line 1016 "../ml_monoCtl.st"
			sprintf(seqMsg1, "Z Motor hit a limit switch!");
# line 1017 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1018 "../ml_monoCtl.st"
			opAlert = 1;
# line 1019 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1020 "../ml_monoCtl.st"
			autoMode = 0;
# line 1021 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 6/*autoMode*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1022 "../ml_monoCtl.st"
			sprintf(seqMsg2, "Setting to Manual Mode");
# line 1023 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 4:
		{
# line 1027 "../ml_monoCtl.st"
			if (ml_monoCtlDebug > 1)
				printf("ml_monoCtl:updateRdbk:moving\n");
# line 1028 "../ml_monoCtl.st"
			thetaRdbk = thetaMotRdbk;
# line 1029 "../ml_monoCtl.st"
			lambdaRdbk = TwoD * sin(thetaRdbk / radConv);
# line 1030 "../ml_monoCtl.st"
			ERdbk = hc / lambdaRdbk;
# line 1031 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 22/*thetaRdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1032 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 18/*lambdaRdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1033 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 14/*ERdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1035 "../ml_monoCtl.st"
			thetaMotRdbkEcho = thetaMotRdbk;
# line 1036 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 30/*thetaMotRdbkEcho*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1037 "../ml_monoCtl.st"
			theta2MotRdbkEcho = theta2MotRdbk;
# line 1038 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 31/*theta2MotRdbkEcho*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "thetaMotStopped" in state set "ml_monoCtl" ******/

/* Event function for state "thetaMotStopped" in state set "ml_monoCtl" */
static seqBool seqg_event_ml_monoCtl_0_thetaMotStopped(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 1044 "../ml_monoCtl.st"
	if (causedMove)
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 1059 "../ml_monoCtl.st"
	if (!causedMove)
	{
		*seqg_pnst = 9;
		*seqg_ptrn = 1;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "thetaMotStopped" in state set "ml_monoCtl" */
static void seqg_action_ml_monoCtl_0_thetaMotStopped(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 1045 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
			{
				/* C code definitions */
# line 1046 "../ml_monoCtl.st"
				printf("ml_monoCtl:thetaMotStopped:causedMove (done=%d,moving=%d)\n",
# line 1047 "../ml_monoCtl.st"
				ml_monoDone, ml_monoMoving);
			}
# line 1049 "../ml_monoCtl.st"
			thSpeed = oldThSpeed;
# line 1050 "../ml_monoCtl.st"
			th2Speed = oldTh2Speed;
# line 1051 "../ml_monoCtl.st"
			zSpeed = oldZSpeed;
# line 1052 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 66/*thSpeed*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1053 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 67/*th2Speed*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1054 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 68/*zSpeed*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1055 "../ml_monoCtl.st"
			causedMove = 0;
		}
		return;
	case 1:
		{
# line 1060 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
			{
				/* C code definitions */
# line 1061 "../ml_monoCtl.st"
				printf("ml_monoCtl:thetaMotStopped:!causedMove (done=%d,moving=%d)\n",
# line 1062 "../ml_monoCtl.st"
				ml_monoDone, ml_monoMoving);
			}
# line 1064 "../ml_monoCtl.st"
			if (initSeqDone)
			{
# line 1065 "../ml_monoCtl.st"
				opAlert = 1;
# line 1066 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1067 "../ml_monoCtl.st"
				sprintf(seqMsg1, "Only Theta Motor Moved");
# line 1068 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1069 "../ml_monoCtl.st"
				sprintf(seqMsg2, "Hit MOVE to Adjust Z");
# line 1070 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1071 "../ml_monoCtl.st"
				autoMode = 0;
# line 1072 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 6/*autoMode*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 1074 "../ml_monoCtl.st"
			theta = thetaMotRdbk;
# line 1075 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 19/*theta*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1076 "../ml_monoCtl.st"
			lambda = TwoD * sin(theta / radConv);
# line 1077 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 15/*lambda*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1078 "../ml_monoCtl.st"
			E = hc / lambda;
# line 1079 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 11/*E*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "chkMotorLimits" in state set "ml_monoCtl" ******/

/* Event function for state "chkMotorLimits" in state set "ml_monoCtl" */
static seqBool seqg_event_ml_monoCtl_0_chkMotorLimits(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 16;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "chkMotorLimits" in state set "ml_monoCtl" */
static void seqg_action_ml_monoCtl_0_chkMotorLimits(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 1085 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:chkMotorLimits\n");
# line 1086 "../ml_monoCtl.st"
			opAlert = 0;
# line 1087 "../ml_monoCtl.st"
			thetaRdbk = thetaMotRdbk;
# line 1088 "../ml_monoCtl.st"
			lambdaRdbk = TwoD * sin(thetaRdbk / radConv);
# line 1089 "../ml_monoCtl.st"
			ERdbk = hc / lambdaRdbk;
# line 1090 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 22/*thetaRdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1091 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 18/*lambdaRdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1092 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 14/*ERdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1094 "../ml_monoCtl.st"
			if (ccMode != 1)
			{
# line 1095 "../ml_monoCtl.st"
				if (zMotRdbk == 0)
				{
# line 1096 "../ml_monoCtl.st"
					sprintf(seqMsg1, "Z Readback of 0 not reasonable");
# line 1097 "../ml_monoCtl.st"
					seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1098 "../ml_monoCtl.st"
					opAlert = 1;
				}
# line 1100 "../ml_monoCtl.st"
				if ((zMotRdbk < zMotLoLim) || (zMotRdbk > zMotHiLim))
				{
# line 1101 "../ml_monoCtl.st"
					sprintf(seqMsg1, "Z Readback outside Motor Limits");
# line 1102 "../ml_monoCtl.st"
					seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1103 "../ml_monoCtl.st"
					opAlert = 1;
				}
			}
# line 1106 "../ml_monoCtl.st"
			if (yMotRdbk == 0)
			{
# line 1107 "../ml_monoCtl.st"
				sprintf(seqMsg1, "Y Readback of 0 not reasonable");
# line 1108 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1109 "../ml_monoCtl.st"
				opAlert = 1;
			}
# line 1111 "../ml_monoCtl.st"
			if (thetaMotRdbk == 0)
			{
# line 1112 "../ml_monoCtl.st"
				sprintf(seqMsg1, "Theta Readback of 0 not reasonable");
# line 1113 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1114 "../ml_monoCtl.st"
				opAlert = 1;
			}
# line 1116 "../ml_monoCtl.st"
			if ((thetaMotRdbk < thetaMotLoLim) || (thetaMotRdbk > thetaMotHiLim))
			{
# line 1117 "../ml_monoCtl.st"
				sprintf(seqMsg1, "Theta Readback outside Motor Limits");
# line 1118 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1119 "../ml_monoCtl.st"
				opAlert = 1;
			}
# line 1122 "../ml_monoCtl.st"
			if (theta2MotRdbk == 0)
			{
# line 1123 "../ml_monoCtl.st"
				sprintf(seqMsg1, "Theta2 Readback of 0 not reasonable");
# line 1124 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1125 "../ml_monoCtl.st"
				opAlert = 1;
			}
# line 1127 "../ml_monoCtl.st"
			if ((theta2MotRdbk < theta2MotLoLim) || (theta2MotRdbk > theta2MotHiLim))
			{
# line 1128 "../ml_monoCtl.st"
				sprintf(seqMsg1, "Theta2 Readback outside Motor Limits");
# line 1129 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1130 "../ml_monoCtl.st"
				opAlert = 1;
			}
# line 1133 "../ml_monoCtl.st"
			if (opAlert)
			{
# line 1134 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1135 "../ml_monoCtl.st"
				autoMode = 0;
# line 1136 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 6/*autoMode*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1137 "../ml_monoCtl.st"
				sprintf(seqMsg2, "Set to Manual Mode");
# line 1138 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	}
}

/****** Code for state "chkMotorLimitsExit" in state set "ml_monoCtl" ******/

/* Event function for state "chkMotorLimitsExit" in state set "ml_monoCtl" */
static seqBool seqg_event_ml_monoCtl_0_chkMotorLimitsExit(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 1144 "../ml_monoCtl.st"
	if (!opAlert)
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 1151 "../ml_monoCtl.st"
	if (opAlert && seq_delay(seqg_env, 2.))
	{
		*seqg_pnst = 15;
		*seqg_ptrn = 1;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "chkMotorLimitsExit" in state set "ml_monoCtl" */
static void seqg_action_ml_monoCtl_0_chkMotorLimitsExit(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 1145 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:chkMotorLimitsExit: OK\n");
# line 1146 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1147 "../ml_monoCtl.st"
			sprintf(seqMsg1, "All motors within limits");
# line 1148 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 1:
		{
# line 1152 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:chkMotorLimitsExit: opAlert\n");
# line 1153 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1154 "../ml_monoCtl.st"
			sprintf(seqMsg2, "Modify Motor Positions/Limits");
# line 1155 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "stop_ml_mono" in state set "ml_monoCtl" ******/

/* Event function for state "stop_ml_mono" in state set "ml_monoCtl" */
static seqBool seqg_event_ml_monoCtl_0_stop_ml_mono(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 18;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "stop_ml_mono" in state set "ml_monoCtl" */
static void seqg_action_ml_monoCtl_0_stop_ml_mono(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 1161 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:stop_ml_mono\n");
# line 1162 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 39/*thetaMotStop*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1163 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 40/*theta2MotStop*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1164 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 41/*zStop*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "stopped_ml_monoWait" in state set "ml_monoCtl" ******/

/* Event function for state "stopped_ml_monoWait" in state set "ml_monoCtl" */
static seqBool seqg_event_ml_monoCtl_0_stopped_ml_monoWait(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 1169 "../ml_monoCtl.st"
	if (seq_delay(seqg_env, 1.))
	{
		*seqg_pnst = 13;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "stopped_ml_monoWait" in state set "ml_monoCtl" */
static void seqg_action_ml_monoCtl_0_stopped_ml_monoWait(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 1170 "../ml_monoCtl.st"
			if (ml_monoCtlDebug)
				printf("ml_monoCtl:stopped_ml_monoWait\n");
		}
		return;
	}
}

/****** Code for state "init" in state set "updatePsuedo" ******/

/* Event function for state "init" in state set "updatePsuedo" */
static seqBool seqg_event_updatePsuedo_1_init(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "init" in state set "updatePsuedo" */
static void seqg_action_updatePsuedo_1_init(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
		}
		return;
	}
}

/****** Code for state "update" in state set "updatePsuedo" ******/

/* Event function for state "update" in state set "updatePsuedo" */
static seqBool seqg_event_updatePsuedo_1_update(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 1189 "../ml_monoCtl.st"
	if (seq_efTestAndClear(seqg_env, thetaMotRdbkPseudo_mon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 1194 "../ml_monoCtl.st"
	if (seq_efTestAndClear(seqg_env, theta2MotRdbkPseudo_mon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 1199 "../ml_monoCtl.st"
	if (seq_efTestAndClear(seqg_env, zMotRdbk_mon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 2;
		return TRUE;
	}
# line 1204 "../ml_monoCtl.st"
	if (seq_efTestAndClear(seqg_env, yMotRdbk_mon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 3;
		return TRUE;
	}
# line 1209 "../ml_monoCtl.st"
	if (seq_efTestAndClear(seqg_env, thetaMotVel_mon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 4;
		return TRUE;
	}
# line 1214 "../ml_monoCtl.st"
	if (seq_efTestAndClear(seqg_env, theta2MotVel_mon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 5;
		return TRUE;
	}
# line 1219 "../ml_monoCtl.st"
	if (seq_efTestAndClear(seqg_env, zMotVel_mon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 6;
		return TRUE;
	}
# line 1224 "../ml_monoCtl.st"
	if (seq_efTestAndClear(seqg_env, thetaMotCmdMon_mon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 7;
		return TRUE;
	}
# line 1229 "../ml_monoCtl.st"
	if (seq_efTestAndClear(seqg_env, theta2MotCmdMon_mon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 8;
		return TRUE;
	}
# line 1234 "../ml_monoCtl.st"
	if (seq_efTestAndClear(seqg_env, zMotCmdMon_mon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 9;
		return TRUE;
	}
# line 1239 "../ml_monoCtl.st"
	if (seq_efTestAndClear(seqg_env, thetaDmov_mon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 10;
		return TRUE;
	}
# line 1244 "../ml_monoCtl.st"
	if (seq_efTestAndClear(seqg_env, theta2Dmov_mon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 11;
		return TRUE;
	}
# line 1249 "../ml_monoCtl.st"
	if (seq_efTestAndClear(seqg_env, zDmov_mon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 12;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "update" in state set "updatePsuedo" */
static void seqg_action_updatePsuedo_1_update(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 1190 "../ml_monoCtl.st"
			thetaMotRdbkEcho = thetaMotRdbk;
# line 1191 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 30/*thetaMotRdbkEcho*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 1:
		{
# line 1195 "../ml_monoCtl.st"
			theta2MotRdbkEcho = theta2MotRdbk;
# line 1196 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 31/*theta2MotRdbkEcho*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 2:
		{
# line 1200 "../ml_monoCtl.st"
			zMotRdbkEcho = zMotRdbk;
# line 1201 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 32/*zMotRdbkEcho*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 3:
		{
# line 1205 "../ml_monoCtl.st"
			yOffset = yMotRdbk;
# line 1206 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 86/*yOffset*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 4:
		{
# line 1210 "../ml_monoCtl.st"
			thetaMotVelEcho = thSpeed;
# line 1211 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 33/*thetaMotVelEcho*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 5:
		{
# line 1215 "../ml_monoCtl.st"
			theta2MotVelEcho = th2Speed;
# line 1216 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 34/*theta2MotVelEcho*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 6:
		{
# line 1220 "../ml_monoCtl.st"
			zMotVelEcho = zSpeed;
# line 1221 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 35/*zMotVelEcho*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 7:
		{
# line 1225 "../ml_monoCtl.st"
			thetaMotCmdEcho = thetaMotCmdMon;
# line 1226 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 27/*thetaMotCmdEcho*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 8:
		{
# line 1230 "../ml_monoCtl.st"
			theta2MotCmdEcho = theta2MotCmdMon;
# line 1231 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 28/*theta2MotCmdEcho*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 9:
		{
# line 1235 "../ml_monoCtl.st"
			zMotCmdEcho = zMotCmdMon;
# line 1236 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 29/*zMotCmdEcho*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 10:
		{
# line 1240 "../ml_monoCtl.st"
			thetaDmovEcho = thetaDmov;
# line 1241 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 36/*thetaDmovEcho*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 11:
		{
# line 1245 "../ml_monoCtl.st"
			theta2DmovEcho = theta2Dmov;
# line 1246 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 37/*theta2DmovEcho*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 12:
		{
# line 1250 "../ml_monoCtl.st"
			zDmovEcho = zDmov;
# line 1251 "../ml_monoCtl.st"
			seq_pvPutTmo(seqg_env, 38/*zDmovEcho*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "init" in state set "updateSet" ******/

/* Event function for state "init" in state set "updateSet" */
static seqBool seqg_event_updateSet_2_init(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "init" in state set "updateSet" */
static void seqg_action_updateSet_2_init(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
		}
		return;
	}
}

/****** Code for state "update" in state set "updateSet" ******/

/* Event function for state "update" in state set "updateSet" */
static seqBool seqg_event_updateSet_2_update(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 1269 "../ml_monoCtl.st"
	if (seq_efTestAndClear(seqg_env, useSetMode_mon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 1284 "../ml_monoCtl.st"
	if (seq_efTestAndClear(seqg_env, thetaMotSet_mon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 1291 "../ml_monoCtl.st"
	if (seq_efTestAndClear(seqg_env, theta2MotSet_mon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 2;
		return TRUE;
	}
# line 1298 "../ml_monoCtl.st"
	if (seq_efTestAndClear(seqg_env, zMotSet_mon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 3;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "update" in state set "updateSet" */
static void seqg_action_updateSet_2_update(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 1270 "../ml_monoCtl.st"
			if (thetaMotSet != useSetMode)
			{
# line 1271 "../ml_monoCtl.st"
				thetaMotSet = useSetMode;
# line 1272 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 74/*thetaMotSet*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 1274 "../ml_monoCtl.st"
			if (theta2MotSet != useSetMode)
			{
# line 1275 "../ml_monoCtl.st"
				theta2MotSet = useSetMode;
# line 1276 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 75/*theta2MotSet*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 1278 "../ml_monoCtl.st"
			if (zMotSet != useSetMode)
			{
# line 1279 "../ml_monoCtl.st"
				zMotSet = useSetMode;
# line 1280 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 76/*zMotSet*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	case 1:
		{
# line 1285 "../ml_monoCtl.st"
			if (useSetMode != thetaMotSet)
			{
# line 1286 "../ml_monoCtl.st"
				useSetMode = thetaMotSet;
# line 1287 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 73/*useSetMode*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	case 2:
		{
# line 1292 "../ml_monoCtl.st"
			if (useSetMode != theta2MotSet)
			{
# line 1293 "../ml_monoCtl.st"
				useSetMode = theta2MotSet;
# line 1294 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 73/*useSetMode*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	case 3:
		{
# line 1299 "../ml_monoCtl.st"
			if (useSetMode != zMotSet)
			{
# line 1300 "../ml_monoCtl.st"
				useSetMode = zMotSet;
# line 1301 "../ml_monoCtl.st"
				seq_pvPutTmo(seqg_env, 73/*useSetMode*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	}
}

#undef seqg_var

/************************ Tables ************************/

/* Channel table */
static seqChan seqg_chans[] = {
	/* chName, offset, varName, varType, count, eventNum, efId, monitored, queueSize, queueIndex */
	{"{P}ml_monoCtlDebug", (size_t)&ml_monoCtlDebug, "ml_monoCtlDebug", P_SHORT, 1, 30, 0, 1, 0, 0},
	{"{P}ml_monoSeqMsg1", (size_t)&seqMsg1, "seqMsg1", P_STRING, 1, 31, 0, 0, 0, 0},
	{"{P}ml_monoSeqMsg2", (size_t)&seqMsg2, "seqMsg2", P_STRING, 1, 32, 0, 0, 0, 0},
	{"{P}ml_monoAlert", (size_t)&opAlert, "opAlert", P_SHORT, 1, 33, 0, 0, 0, 0},
	{"{P}ml_monoOperAck", (size_t)&opAck, "opAck", P_SHORT, 1, 34, 0, 1, 0, 0},
	{"{P}ml_monoPut", (size_t)&putVals, "putVals", P_SHORT, 1, 35, 0, 1, 0, 0},
	{"{P}ml_monoMode", (size_t)&autoMode, "autoMode", P_SHORT, 1, 36, 0, 1, 0, 0},
	{"{P}ml_monoMode2", (size_t)&ccMode, "ccMode", P_SHORT, 1, 37, 0, 1, 0, 0},
	{"{P}ml_monoMoving", (size_t)&ml_monoMoving, "ml_monoMoving", P_SHORT, 1, 38, 0, 1, 0, 0},
	{"{P}ml_monoOrder", (size_t)&Order, "Order", P_DOUBLE, 1, 39, 1, 1, 0, 0},
	{"{P}ml_monoD", (size_t)&D, "D", P_DOUBLE, 1, 40, 2, 1, 0, 0},
	{"{P}ml_monoE", (size_t)&E, "E", P_DOUBLE, 1, 41, 3, 1, 0, 0},
	{"{P}ml_monoE.DRVH", (size_t)&EHi, "EHi", P_DOUBLE, 1, 42, 0, 0, 0, 0},
	{"{P}ml_monoE.DRVL", (size_t)&ELo, "ELo", P_DOUBLE, 1, 43, 0, 0, 0, 0},
	{"{P}ml_monoERdbk", (size_t)&ERdbk, "ERdbk", P_DOUBLE, 1, 44, 0, 0, 0, 0},
	{"{P}ml_monoLambda", (size_t)&lambda, "lambda", P_DOUBLE, 1, 45, 4, 1, 0, 0},
	{"{P}ml_monoLambda.DRVH", (size_t)&lambdaHi, "lambdaHi", P_DOUBLE, 1, 46, 0, 0, 0, 0},
	{"{P}ml_monoLambda.DRVL", (size_t)&lambdaLo, "lambdaLo", P_DOUBLE, 1, 47, 0, 0, 0, 0},
	{"{P}ml_monoLambdaRdbk", (size_t)&lambdaRdbk, "lambdaRdbk", P_DOUBLE, 1, 48, 0, 0, 0, 0},
	{"{P}ml_monoTheta", (size_t)&theta, "theta", P_DOUBLE, 1, 49, 5, 1, 0, 0},
	{"{P}ml_monoTheta.DRVH", (size_t)&thetaHi, "thetaHi", P_DOUBLE, 1, 50, 0, 0, 0, 0},
	{"{P}ml_monoTheta.DRVL", (size_t)&thetaLo, "thetaLo", P_DOUBLE, 1, 51, 0, 0, 0, 0},
	{"{P}ml_monoThetaRdbk", (size_t)&thetaRdbk, "thetaRdbk", P_DOUBLE, 1, 52, 0, 0, 0, 0},
	{"{P}ml_monoThetaPv", (size_t)&thetaMotName, "thetaMotName", P_STRING, 1, 53, 0, 0, 0, 0},
	{"{P}ml_monoTheta2Pv", (size_t)&theta2MotName, "theta2MotName", P_STRING, 1, 54, 0, 0, 0, 0},
	{"{P}ml_monoZPv", (size_t)&zMotName, "zMotName", P_STRING, 1, 55, 0, 0, 0, 0},
	{"{P}ml_monoYPv", (size_t)&yMotName, "yMotName", P_STRING, 1, 56, 0, 0, 0, 0},
	{"{P}ml_monoThetaCmd", (size_t)&thetaMotCmdEcho, "thetaMotCmdEcho", P_DOUBLE, 1, 57, 0, 0, 0, 0},
	{"{P}ml_monoTheta2Cmd", (size_t)&theta2MotCmdEcho, "theta2MotCmdEcho", P_DOUBLE, 1, 58, 0, 0, 0, 0},
	{"{P}ml_monoZCmd", (size_t)&zMotCmdEcho, "zMotCmdEcho", P_DOUBLE, 1, 59, 0, 0, 0, 0},
	{"{P}ml_monoThetaRdbkEcho", (size_t)&thetaMotRdbkEcho, "thetaMotRdbkEcho", P_DOUBLE, 1, 60, 0, 0, 0, 0},
	{"{P}ml_monoTheta2RdbkEcho", (size_t)&theta2MotRdbkEcho, "theta2MotRdbkEcho", P_DOUBLE, 1, 61, 0, 0, 0, 0},
	{"{P}ml_monoZRdbk", (size_t)&zMotRdbkEcho, "zMotRdbkEcho", P_DOUBLE, 1, 62, 0, 0, 0, 0},
	{"{P}ml_monoThetaVel", (size_t)&thetaMotVelEcho, "thetaMotVelEcho", P_DOUBLE, 1, 63, 0, 0, 0, 0},
	{"{P}ml_monoTheta2Vel", (size_t)&theta2MotVelEcho, "theta2MotVelEcho", P_DOUBLE, 1, 64, 0, 0, 0, 0},
	{"{P}ml_monoZVel", (size_t)&zMotVelEcho, "zMotVelEcho", P_DOUBLE, 1, 65, 0, 0, 0, 0},
	{"{P}ml_monoThetaDmov", (size_t)&thetaDmovEcho, "thetaDmovEcho", P_SHORT, 1, 66, 0, 0, 0, 0},
	{"{P}ml_monoTheta2Dmov", (size_t)&theta2DmovEcho, "theta2DmovEcho", P_SHORT, 1, 67, 0, 0, 0, 0},
	{"{P}ml_monoZDmov", (size_t)&zDmovEcho, "zDmovEcho", P_SHORT, 1, 68, 0, 0, 0, 0},
	{"{P}{M_THETA}.STOP", (size_t)&thetaMotStop, "thetaMotStop", P_SHORT, 1, 69, 0, 0, 0, 0},
	{"{P}{M_THETA2}.STOP", (size_t)&theta2MotStop, "theta2MotStop", P_SHORT, 1, 70, 0, 0, 0, 0},
	{"{P}{M_Z}.STOP", (size_t)&zStop, "zStop", P_SHORT, 1, 71, 0, 0, 0, 0},
	{"{P}{M_THETA}.DMOV", (size_t)&thetaDmov, "thetaDmov", P_SHORT, 1, 72, 6, 1, 0, 0},
	{"{P}{M_THETA2}.DMOV", (size_t)&theta2Dmov, "theta2Dmov", P_SHORT, 1, 73, 7, 1, 0, 0},
	{"{P}{M_Z}.DMOV", (size_t)&zDmov, "zDmov", P_SHORT, 1, 74, 8, 1, 0, 0},
	{"{P}{M_THETA}.HLS", (size_t)&thetaHls, "thetaHls", P_SHORT, 1, 75, 0, 1, 0, 0},
	{"{P}{M_THETA}.LLS", (size_t)&thetaLls, "thetaLls", P_SHORT, 1, 76, 0, 1, 0, 0},
	{"{P}{M_THETA2}.HLS", (size_t)&theta2Hls, "theta2Hls", P_SHORT, 1, 77, 0, 1, 0, 0},
	{"{P}{M_THETA2}.LLS", (size_t)&theta2Lls, "theta2Lls", P_SHORT, 1, 78, 0, 1, 0, 0},
	{"{P}{M_Z}.HLS", (size_t)&zHls, "zHls", P_SHORT, 1, 79, 0, 1, 0, 0},
	{"{P}{M_Z}.LLS", (size_t)&zLls, "zLls", P_SHORT, 1, 80, 0, 1, 0, 0},
	{"{P}ml_monoThetaSet", (size_t)&thetaMotDesired, "thetaMotDesired", P_DOUBLE, 1, 81, 0, 1, 0, 0},
	{"{P}ml_monoTheta2Set", (size_t)&theta2MotDesired, "theta2MotDesired", P_DOUBLE, 1, 82, 0, 1, 0, 0},
	{"{P}ml_monoZSet", (size_t)&zMotDesired, "zMotDesired", P_DOUBLE, 1, 83, 0, 1, 0, 0},
	{"{P}{M_THETA}.HLM", (size_t)&thetaMotHiLim, "thetaMotHiLim", P_DOUBLE, 1, 84, 9, 1, 0, 0},
	{"{P}{M_THETA}.LLM", (size_t)&thetaMotLoLim, "thetaMotLoLim", P_DOUBLE, 1, 85, 10, 1, 0, 0},
	{"{P}{M_THETA2}.HLM", (size_t)&theta2MotHiLim, "theta2MotHiLim", P_DOUBLE, 1, 86, 11, 1, 0, 0},
	{"{P}{M_THETA2}.LLM", (size_t)&theta2MotLoLim, "theta2MotLoLim", P_DOUBLE, 1, 87, 12, 1, 0, 0},
	{"{P}{M_Z}.HLM", (size_t)&zMotHiLim, "zMotHiLim", P_DOUBLE, 1, 88, 0, 1, 0, 0},
	{"{P}{M_Z}.LLM", (size_t)&zMotLoLim, "zMotLoLim", P_DOUBLE, 1, 89, 0, 1, 0, 0},
	{"{P}{M_THETA}", (size_t)&thetaMotCmd, "thetaMotCmd", P_DOUBLE, 1, 90, 0, 0, 0, 0},
	{"{P}{M_THETA2}", (size_t)&theta2MotCmd, "theta2MotCmd", P_DOUBLE, 1, 91, 0, 0, 0, 0},
	{"{P}{M_Z}", (size_t)&zMotCmd, "zMotCmd", P_DOUBLE, 1, 92, 0, 0, 0, 0},
	{"{P}{M_THETA}", (size_t)&thetaMotCmdMon, "thetaMotCmdMon", P_DOUBLE, 1, 93, 13, 1, 0, 0},
	{"{P}{M_THETA2}", (size_t)&theta2MotCmdMon, "theta2MotCmdMon", P_DOUBLE, 1, 94, 14, 1, 0, 0},
	{"{P}{M_Z}", (size_t)&zMotCmdMon, "zMotCmdMon", P_DOUBLE, 1, 95, 15, 1, 0, 0},
	{"{P}{M_THETA}.VELO", (size_t)&thSpeed, "thSpeed", P_DOUBLE, 1, 96, 16, 1, 0, 0},
	{"{P}{M_THETA2}.VELO", (size_t)&th2Speed, "th2Speed", P_DOUBLE, 1, 97, 17, 1, 0, 0},
	{"{P}{M_Z}.VELO", (size_t)&zSpeed, "zSpeed", P_DOUBLE, 1, 98, 18, 1, 0, 0},
	{"{P}{M_THETA}.RBV", (size_t)&thetaMotRdbk, "thetaMotRdbk", P_DOUBLE, 1, 99, 19, 1, 0, 0},
	{"{P}{M_THETA2}.RBV", (size_t)&theta2MotRdbk, "theta2MotRdbk", P_DOUBLE, 1, 100, 21, 1, 0, 0},
	{"{P}{M_Z}.RBV", (size_t)&zMotRdbk, "zMotRdbk", P_DOUBLE, 1, 101, 23, 1, 0, 0},
	{"{P}{M_Y}.RBV", (size_t)&yMotRdbk, "yMotRdbk", P_DOUBLE, 1, 102, 24, 1, 0, 0},
	{"{P}ml_monoUseSet", (size_t)&useSetMode, "useSetMode", P_SHORT, 1, 103, 25, 1, 0, 0},
	{"{P}{M_THETA}.SET", (size_t)&thetaMotSet, "thetaMotSet", P_SHORT, 1, 104, 26, 1, 0, 0},
	{"{P}{M_THETA2}.SET", (size_t)&theta2MotSet, "theta2MotSet", P_SHORT, 1, 105, 27, 1, 0, 0},
	{"{P}{M_Z}.SET", (size_t)&zMotSet, "zMotSet", P_SHORT, 1, 106, 28, 1, 0, 0},
	{"{P}ml_monoETweak", (size_t)&ETweakVal, "ETweakVal", P_DOUBLE, 1, 107, 0, 1, 0, 0},
	{"{P}ml_monoEInc", (size_t)&ETweakInc, "ETweakInc", P_SHORT, 1, 108, 0, 1, 0, 0},
	{"{P}ml_monoEDec", (size_t)&ETweakDec, "ETweakDec", P_SHORT, 1, 109, 0, 1, 0, 0},
	{"{P}ml_monoLambdaTweak", (size_t)&LTweakVal, "LTweakVal", P_DOUBLE, 1, 110, 0, 1, 0, 0},
	{"{P}ml_monoLambdaInc", (size_t)&LTweakInc, "LTweakInc", P_SHORT, 1, 111, 0, 1, 0, 0},
	{"{P}ml_monoLambdaDec", (size_t)&LTweakDec, "LTweakDec", P_SHORT, 1, 112, 0, 1, 0, 0},
	{"{P}ml_monoThetaTweak", (size_t)&thTweakVal, "thTweakVal", P_DOUBLE, 1, 113, 0, 1, 0, 0},
	{"{P}ml_monoThetaInc", (size_t)&thTweakInc, "thTweakInc", P_SHORT, 1, 114, 0, 1, 0, 0},
	{"{P}ml_monoThetaDec", (size_t)&thTweakDec, "thTweakDec", P_SHORT, 1, 115, 0, 1, 0, 0},
	{"{P}ml_mono_yOffset", (size_t)&yOffset, "yOffset", P_DOUBLE, 1, 116, 29, 1, 0, 0},
	{"{P}ml_mono_yOffset.DRVH", (size_t)&yOffsetHi, "yOffsetHi", P_DOUBLE, 1, 117, 0, 0, 0, 0},
	{"{P}ml_mono_yOffset.DRVL", (size_t)&yOffsetLo, "yOffsetLo", P_DOUBLE, 1, 118, 0, 0, 0, 0},
};

/* Event masks for state set "ml_monoCtl" */
static const seqMask seqg_mask_ml_monoCtl_0_init[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_ml_monoCtl_0_initSequence[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_ml_monoCtl_0_waitForCmndEnter[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_ml_monoCtl_0_waitForCmnd[] = {
	0x20281e3e,
	0x0000000c,
	0x00000000,
	0x000db000,
};
static const seqMask seqg_mask_ml_monoCtl_0_tweak[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x000db000,
};
static const seqMask seqg_mask_ml_monoCtl_0_dInputChanged[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_ml_monoCtl_0_thetaLimits[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_ml_monoCtl_0_eChanged[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_ml_monoCtl_0_lChanged[] = {
	0x00000000,
	0x00002000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_ml_monoCtl_0_thChanged[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_ml_monoCtl_0_calcMovements[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_ml_monoCtl_0_move_ml_mono[] = {
	0x00000000,
	0x00000018,
	0x00000000,
	0x00000080,
};
static const seqMask seqg_mask_ml_monoCtl_0_checkDone[] = {
	0x00000000,
	0x00000000,
	0x00000700,
	0x00000000,
};
static const seqMask seqg_mask_ml_monoCtl_0_updateRdbk[] = {
	0x00000000,
	0x00000020,
	0x0001ff00,
	0x00000018,
};
static const seqMask seqg_mask_ml_monoCtl_0_thetaMotStopped[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_ml_monoCtl_0_chkMotorLimits[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_ml_monoCtl_0_chkMotorLimitsExit[] = {
	0x00000000,
	0x00000002,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_ml_monoCtl_0_stop_ml_mono[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_ml_monoCtl_0_stopped_ml_monoWait[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};

/* State table for state set "ml_monoCtl" */
static seqState seqg_states_ml_monoCtl[] = {
	{
	/* state name */        "init",
	/* action function */   seqg_action_ml_monoCtl_0_init,
	/* event function */    seqg_event_ml_monoCtl_0_init,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ml_monoCtl_0_init,
	/* state options */     (0)
	},
	{
	/* state name */        "initSequence",
	/* action function */   seqg_action_ml_monoCtl_0_initSequence,
	/* event function */    seqg_event_ml_monoCtl_0_initSequence,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ml_monoCtl_0_initSequence,
	/* state options */     (0)
	},
	{
	/* state name */        "waitForCmndEnter",
	/* action function */   seqg_action_ml_monoCtl_0_waitForCmndEnter,
	/* event function */    seqg_event_ml_monoCtl_0_waitForCmndEnter,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ml_monoCtl_0_waitForCmndEnter,
	/* state options */     (0)
	},
	{
	/* state name */        "waitForCmnd",
	/* action function */   seqg_action_ml_monoCtl_0_waitForCmnd,
	/* event function */    seqg_event_ml_monoCtl_0_waitForCmnd,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ml_monoCtl_0_waitForCmnd,
	/* state options */     (0)
	},
	{
	/* state name */        "tweak",
	/* action function */   seqg_action_ml_monoCtl_0_tweak,
	/* event function */    seqg_event_ml_monoCtl_0_tweak,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ml_monoCtl_0_tweak,
	/* state options */     (0)
	},
	{
	/* state name */        "dInputChanged",
	/* action function */   seqg_action_ml_monoCtl_0_dInputChanged,
	/* event function */    seqg_event_ml_monoCtl_0_dInputChanged,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ml_monoCtl_0_dInputChanged,
	/* state options */     (0)
	},
	{
	/* state name */        "thetaLimits",
	/* action function */   seqg_action_ml_monoCtl_0_thetaLimits,
	/* event function */    seqg_event_ml_monoCtl_0_thetaLimits,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ml_monoCtl_0_thetaLimits,
	/* state options */     (0)
	},
	{
	/* state name */        "eChanged",
	/* action function */   seqg_action_ml_monoCtl_0_eChanged,
	/* event function */    seqg_event_ml_monoCtl_0_eChanged,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ml_monoCtl_0_eChanged,
	/* state options */     (0)
	},
	{
	/* state name */        "lChanged",
	/* action function */   seqg_action_ml_monoCtl_0_lChanged,
	/* event function */    seqg_event_ml_monoCtl_0_lChanged,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ml_monoCtl_0_lChanged,
	/* state options */     (0)
	},
	{
	/* state name */        "thChanged",
	/* action function */   seqg_action_ml_monoCtl_0_thChanged,
	/* event function */    seqg_event_ml_monoCtl_0_thChanged,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ml_monoCtl_0_thChanged,
	/* state options */     (0)
	},
	{
	/* state name */        "calcMovements",
	/* action function */   seqg_action_ml_monoCtl_0_calcMovements,
	/* event function */    seqg_event_ml_monoCtl_0_calcMovements,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ml_monoCtl_0_calcMovements,
	/* state options */     (0)
	},
	{
	/* state name */        "move_ml_mono",
	/* action function */   seqg_action_ml_monoCtl_0_move_ml_mono,
	/* event function */    seqg_event_ml_monoCtl_0_move_ml_mono,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ml_monoCtl_0_move_ml_mono,
	/* state options */     (0)
	},
	{
	/* state name */        "checkDone",
	/* action function */   seqg_action_ml_monoCtl_0_checkDone,
	/* event function */    seqg_event_ml_monoCtl_0_checkDone,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ml_monoCtl_0_checkDone,
	/* state options */     (0)
	},
	{
	/* state name */        "updateRdbk",
	/* action function */   seqg_action_ml_monoCtl_0_updateRdbk,
	/* event function */    seqg_event_ml_monoCtl_0_updateRdbk,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ml_monoCtl_0_updateRdbk,
	/* state options */     (0)
	},
	{
	/* state name */        "thetaMotStopped",
	/* action function */   seqg_action_ml_monoCtl_0_thetaMotStopped,
	/* event function */    seqg_event_ml_monoCtl_0_thetaMotStopped,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ml_monoCtl_0_thetaMotStopped,
	/* state options */     (0)
	},
	{
	/* state name */        "chkMotorLimits",
	/* action function */   seqg_action_ml_monoCtl_0_chkMotorLimits,
	/* event function */    seqg_event_ml_monoCtl_0_chkMotorLimits,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ml_monoCtl_0_chkMotorLimits,
	/* state options */     (0)
	},
	{
	/* state name */        "chkMotorLimitsExit",
	/* action function */   seqg_action_ml_monoCtl_0_chkMotorLimitsExit,
	/* event function */    seqg_event_ml_monoCtl_0_chkMotorLimitsExit,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ml_monoCtl_0_chkMotorLimitsExit,
	/* state options */     (0)
	},
	{
	/* state name */        "stop_ml_mono",
	/* action function */   seqg_action_ml_monoCtl_0_stop_ml_mono,
	/* event function */    seqg_event_ml_monoCtl_0_stop_ml_mono,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ml_monoCtl_0_stop_ml_mono,
	/* state options */     (0)
	},
	{
	/* state name */        "stopped_ml_monoWait",
	/* action function */   seqg_action_ml_monoCtl_0_stopped_ml_monoWait,
	/* event function */    seqg_event_ml_monoCtl_0_stopped_ml_monoWait,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ml_monoCtl_0_stopped_ml_monoWait,
	/* state options */     (0)
	},
};

/* Event masks for state set "updatePsuedo" */
static const seqMask seqg_mask_updatePsuedo_1_init[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_updatePsuedo_1_update[] = {
	0x01d7e1c0,
	0x00000000,
	0x00000000,
	0x00000000,
};

/* State table for state set "updatePsuedo" */
static seqState seqg_states_updatePsuedo[] = {
	{
	/* state name */        "init",
	/* action function */   seqg_action_updatePsuedo_1_init,
	/* event function */    seqg_event_updatePsuedo_1_init,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_updatePsuedo_1_init,
	/* state options */     (0)
	},
	{
	/* state name */        "update",
	/* action function */   seqg_action_updatePsuedo_1_update,
	/* event function */    seqg_event_updatePsuedo_1_update,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_updatePsuedo_1_update,
	/* state options */     (0)
	},
};

/* Event masks for state set "updateSet" */
static const seqMask seqg_mask_updateSet_2_init[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_updateSet_2_update[] = {
	0x1e000000,
	0x00000000,
	0x00000000,
	0x00000000,
};

/* State table for state set "updateSet" */
static seqState seqg_states_updateSet[] = {
	{
	/* state name */        "init",
	/* action function */   seqg_action_updateSet_2_init,
	/* event function */    seqg_event_updateSet_2_init,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_updateSet_2_init,
	/* state options */     (0)
	},
	{
	/* state name */        "update",
	/* action function */   seqg_action_updateSet_2_update,
	/* event function */    seqg_event_updateSet_2_update,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_updateSet_2_update,
	/* state options */     (0)
	},
};

/* State set table */
static seqSS seqg_statesets[] = {
	{
	/* state set name */    "ml_monoCtl",
	/* states */            seqg_states_ml_monoCtl,
	/* number of states */  19
	},

	{
	/* state set name */    "updatePsuedo",
	/* states */            seqg_states_updatePsuedo,
	/* number of states */  2
	},

	{
	/* state set name */    "updateSet",
	/* states */            seqg_states_updateSet,
	/* number of states */  2
	},
};

/* Program table (global) */
seqProgram ml_monoCtl = {
	/* magic number */      2002005,
	/* program name */      "ml_monoCtl",
	/* channels */          seqg_chans,
	/* num. channels */     89,
	/* state sets */        seqg_statesets,
	/* num. state sets */   3,
	/* user var size */     0,
	/* param */             "P=xxx:, M_THETA=m9, M_THETA2=m12, M_Y=m10, M_Z=m11, Y_OFF=35, GEOM=1",
	/* num. event flags */  29,
	/* encoded options */   (0 | OPT_CONN | OPT_NEWEF),
	/* init func */         seqg_init,
	/* entry func */        0,
	/* exit func */         0,
	/* num. queues */       0
};
# line 1311 "../ml_monoCtl.st"



double ml_monoCtl_calc2dSpacing()
{

 double result;

 result = (2*D)/Order;

 opAlert = 0;
 if (Order < 1) opAlert = 1;
 if (opAlert) {
  sprintf(seqMsg1, "Order == %f?", Order);
 } else {
  sprintf(seqMsg1, "New effective d spacing");
 }
 return(result);
}




/* Register sequencer commands and program */
#include "epicsExport.h"
static void ml_monoCtlRegistrar (void) {
    seqRegisterSequencerCommands();
    seqRegisterSequencerProgram (&ml_monoCtl);
}
epicsExportRegistrar(ml_monoCtlRegistrar);
