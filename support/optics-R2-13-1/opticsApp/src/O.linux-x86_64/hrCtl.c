/* C code for program hrCtl, generated by snc from ../hrCtl.st */
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>

#include "seq_snc.h"
# line 71 "../hrCtl.st"
static const EF_ID opMode_mon = 1;
# line 77 "../hrCtl.st"
static const EF_ID Geom_mon = 2;
# line 83 "../hrCtl.st"
static const EF_ID hr_Moving_mon = 3;
# line 92 "../hrCtl.st"
static const EF_ID H1_mon = 4;
# line 98 "../hrCtl.st"
static const EF_ID K1_mon = 5;
# line 104 "../hrCtl.st"
static const EF_ID L1_mon = 6;
# line 110 "../hrCtl.st"
static const EF_ID A1_mon = 7;
# line 120 "../hrCtl.st"
static const EF_ID H2_mon = 8;
# line 126 "../hrCtl.st"
static const EF_ID K2_mon = 9;
# line 132 "../hrCtl.st"
static const EF_ID L2_mon = 10;
# line 138 "../hrCtl.st"
static const EF_ID A2_mon = 11;
# line 148 "../hrCtl.st"
static const EF_ID E_mon = 12;
# line 164 "../hrCtl.st"
static const EF_ID lambda_mon = 13;
# line 180 "../hrCtl.st"
static const EF_ID theta1_mon = 14;
# line 196 "../hrCtl.st"
static const EF_ID phi1_mon = 15;
# line 202 "../hrCtl.st"
static const EF_ID phi1Off_mon = 16;
# line 218 "../hrCtl.st"
static const EF_ID theta2_mon = 17;
# line 236 "../hrCtl.st"
static const EF_ID phi2_mon = 18;
# line 242 "../hrCtl.st"
static const EF_ID phi2Off_mon = 19;
# line 298 "../hrCtl.st"
static const EF_ID phi1Dmov_mon = 20;
# line 304 "../hrCtl.st"
static const EF_ID phi2Dmov_mon = 21;
# line 316 "../hrCtl.st"
static short hrCtl_LS_TEST = 0;
# line 348 "../hrCtl.st"
static const EF_ID phi1MotHiLim_mon = 22;
# line 354 "../hrCtl.st"
static const EF_ID phi1MotLoLim_mon = 23;
# line 360 "../hrCtl.st"
static const EF_ID phi2MotHiLim_mon = 24;
# line 366 "../hrCtl.st"
static const EF_ID phi2MotLoLim_mon = 25;
# line 380 "../hrCtl.st"
static const EF_ID phi1MotCmdMon_mon = 26;
# line 386 "../hrCtl.st"
static const EF_ID phi2MotCmdMon_mon = 27;
# line 392 "../hrCtl.st"
static const EF_ID phi1MotRdbk_mon = 28;
# line 394 "../hrCtl.st"
static const EF_ID phi1MotRdbkPseudo_mon = 29;
# line 399 "../hrCtl.st"
static const EF_ID phi2MotRdbk_mon = 30;
# line 401 "../hrCtl.st"
static const EF_ID phi2MotRdbkPseudo_mon = 31;
# line 407 "../hrCtl.st"
static const EF_ID worldOff_mon = 32;
# line 426 "../hrCtl.st"
static const EF_ID useSetMode_mon = 33;
# line 487 "../hrCtl.st"
#include <string.h>
# line 488 "../hrCtl.st"
#include <math.h>
# line 490 "../hrCtl.st"
static double hrCtl_calc2dSpacing(struct UserVar *pVar, int xtal, double A, double H, double K, double L);
# line 491 "../hrCtl.st"
static void hrCtl_calcReadback(struct UserVar *pVar);
# line 492 "../hrCtl.st"
static char *hrCtl_pmacP;
# line 493 "../hrCtl.st"
static char *hrCtl_pmacM;

/* Variable declarations */
struct seqg_vars {
# line 43 "../hrCtl.st"
	short hrCtlDebug;
# line 47 "../hrCtl.st"
	string seqMsg1;
# line 50 "../hrCtl.st"
	string seqMsg2;
# line 53 "../hrCtl.st"
	short opAlert;
# line 56 "../hrCtl.st"
	short opAck;
# line 60 "../hrCtl.st"
	short putVals;
# line 64 "../hrCtl.st"
	short autoMode;
# line 68 "../hrCtl.st"
	short opMode;
# line 74 "../hrCtl.st"
	short Geom;
# line 80 "../hrCtl.st"
	short hr_Moving;
# line 86 "../hrCtl.st"
	short hr_Done;
# line 89 "../hrCtl.st"
	double H1;
# line 95 "../hrCtl.st"
	double K1;
# line 101 "../hrCtl.st"
	double L1;
# line 107 "../hrCtl.st"
	double A1;
# line 113 "../hrCtl.st"
	double D1;
# line 117 "../hrCtl.st"
	double H2;
# line 123 "../hrCtl.st"
	double K2;
# line 129 "../hrCtl.st"
	double L2;
# line 135 "../hrCtl.st"
	double A2;
# line 141 "../hrCtl.st"
	double D2;
# line 145 "../hrCtl.st"
	double E;
# line 151 "../hrCtl.st"
	double EHi;
# line 154 "../hrCtl.st"
	double ELo;
# line 157 "../hrCtl.st"
	double ERdbk;
# line 160 "../hrCtl.st"
	double lambda;
# line 161 "../hrCtl.st"
	double lambdaNom;
# line 167 "../hrCtl.st"
	double lambdaHi;
# line 170 "../hrCtl.st"
	double lambdaLo;
# line 173 "../hrCtl.st"
	double lambdaRdbk;
# line 177 "../hrCtl.st"
	double theta1;
# line 183 "../hrCtl.st"
	double theta1Hi;
# line 186 "../hrCtl.st"
	double theta1Lo;
# line 189 "../hrCtl.st"
	double theta1Rdbk;
# line 193 "../hrCtl.st"
	double phi1;
# line 199 "../hrCtl.st"
	double phi1Off;
# line 205 "../hrCtl.st"
	double phi1Hi;
# line 208 "../hrCtl.st"
	double phi1Lo;
# line 211 "../hrCtl.st"
	double phi1Rdbk;
# line 215 "../hrCtl.st"
	double theta2;
# line 221 "../hrCtl.st"
	double theta2Nom;
# line 223 "../hrCtl.st"
	double theta2Hi;
# line 226 "../hrCtl.st"
	double theta2Lo;
# line 229 "../hrCtl.st"
	double theta2Rdbk;
# line 233 "../hrCtl.st"
	double phi2;
# line 239 "../hrCtl.st"
	double phi2Off;
# line 245 "../hrCtl.st"
	double phi2Hi;
# line 248 "../hrCtl.st"
	double phi2Lo;
# line 251 "../hrCtl.st"
	double phi2Rdbk;
# line 259 "../hrCtl.st"
	string phi1MotName;
# line 262 "../hrCtl.st"
	string phi2MotName;
# line 265 "../hrCtl.st"
	double phi1MotCmdEcho;
# line 268 "../hrCtl.st"
	double phi2MotCmdEcho;
# line 271 "../hrCtl.st"
	double phi1MotRdbkEcho;
# line 274 "../hrCtl.st"
	double phi2MotRdbkEcho;
# line 277 "../hrCtl.st"
	short phi1DmovEcho;
# line 280 "../hrCtl.st"
	short phi2DmovEcho;
# line 289 "../hrCtl.st"
	short phi1MotStop;
# line 292 "../hrCtl.st"
	short phi2MotStop;
# line 295 "../hrCtl.st"
	short phi1Dmov;
# line 301 "../hrCtl.st"
	short phi2Dmov;
# line 308 "../hrCtl.st"
	short phi1Hls;
# line 309 "../hrCtl.st"
	short phi1Lls;
# line 311 "../hrCtl.st"
	short phi2Hls;
# line 312 "../hrCtl.st"
	short phi2Lls;
# line 337 "../hrCtl.st"
	double phi1MotDesired;
# line 341 "../hrCtl.st"
	double phi2MotDesired;
# line 345 "../hrCtl.st"
	double phi1MotHiLim;
# line 351 "../hrCtl.st"
	double phi1MotLoLim;
# line 357 "../hrCtl.st"
	double phi2MotHiLim;
# line 363 "../hrCtl.st"
	double phi2MotLoLim;
# line 369 "../hrCtl.st"
	double phi1MotCmd;
# line 371 "../hrCtl.st"
	int phi1PutComplete;
# line 373 "../hrCtl.st"
	double phi2MotCmd;
# line 375 "../hrCtl.st"
	int phi2PutComplete;
# line 377 "../hrCtl.st"
	double phi1MotCmdMon;
# line 383 "../hrCtl.st"
	double phi2MotCmdMon;
# line 389 "../hrCtl.st"
	double phi1MotRdbk;
# line 396 "../hrCtl.st"
	double phi2MotRdbk;
# line 404 "../hrCtl.st"
	double worldOff;
# line 410 "../hrCtl.st"
	double worldTweakVal;
# line 414 "../hrCtl.st"
	short worldTweakInc;
# line 418 "../hrCtl.st"
	short worldTweakDec;
# line 423 "../hrCtl.st"
	short useSetMode;
# line 430 "../hrCtl.st"
	double ETweakVal;
# line 434 "../hrCtl.st"
	short ETweakInc;
# line 438 "../hrCtl.st"
	short ETweakDec;
# line 442 "../hrCtl.st"
	double LTweakVal;
# line 446 "../hrCtl.st"
	short LTweakInc;
# line 450 "../hrCtl.st"
	short LTweakDec;
# line 454 "../hrCtl.st"
	double th1TweakVal;
# line 458 "../hrCtl.st"
	short th1TweakInc;
# line 462 "../hrCtl.st"
	short th1TweakDec;
# line 466 "../hrCtl.st"
	double th2TweakVal;
# line 470 "../hrCtl.st"
	short th2TweakInc;
# line 474 "../hrCtl.st"
	short th2TweakDec;
# line 479 "../hrCtl.st"
	double thetaMin;
# line 482 "../hrCtl.st"
	double thetaMax;
# line 495 "../hrCtl.st"
	short toggle;
# line 496 "../hrCtl.st"
	short causedMove;
# line 497 "../hrCtl.st"
	short initSeq;
# line 498 "../hrCtl.st"
	short initSeqDone;
# line 499 "../hrCtl.st"
	double hc;
# line 500 "../hrCtl.st"
	double PI;
# line 501 "../hrCtl.st"
	double R2D;
# line 502 "../hrCtl.st"
	double uR2D;
# line 503 "../hrCtl.st"
	double D2R;
# line 504 "../hrCtl.st"
	double D2uR;
# line 505 "../hrCtl.st"
	double temp;
};


/* Function declarations */

#define seqg_var (*(struct seqg_vars *const *)seqg_env)

/* Program init func */
static void seqg_init(PROG_ID seqg_env)
{
}

/****** Code for state "init" in state set "hr_Ctl" ******/

/* Entry function for state "init" in state set "hr_Ctl" */
static void seqg_entry_hr_Ctl_0_init(SS_ID seqg_env)
{
# line 511 "../hrCtl.st"
	if (seqg_var->hrCtlDebug)
		printf("hrCtl:init: entry\n");
}

/* Event function for state "init" in state set "hr_Ctl" */
static seqBool seqg_event_hr_Ctl_0_init(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "init" in state set "hr_Ctl" */
static void seqg_action_hr_Ctl_0_init(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 514 "../hrCtl.st"
			seqg_var->initSeq = 0;
		}
		return;
	}
}

/****** Code for state "initSequence" in state set "hr_Ctl" ******/

/* Entry function for state "initSequence" in state set "hr_Ctl" */
static void seqg_entry_hr_Ctl_0_initSequence(SS_ID seqg_env)
{
# line 520 "../hrCtl.st"
	if (seqg_var->hrCtlDebug)
		printf("hrCtl:initSequence: entry\n");
}

/* Event function for state "initSequence" in state set "hr_Ctl" */
static seqBool seqg_event_hr_Ctl_0_initSequence(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 522 "../hrCtl.st"
	if (seqg_var->initSeq == 0)
	{
		*seqg_pnst = 7;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 561 "../hrCtl.st"
	if (seqg_var->initSeq == 1)
	{
		*seqg_pnst = 17;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 565 "../hrCtl.st"
	if (seqg_var->initSeq == 2)
	{
		*seqg_pnst = 14;
		*seqg_ptrn = 2;
		return TRUE;
	}
# line 569 "../hrCtl.st"
	if (seqg_var->initSeq == 3)
	{
		*seqg_pnst = 11;
		*seqg_ptrn = 3;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "initSequence" in state set "hr_Ctl" */
static void seqg_action_hr_Ctl_0_initSequence(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 523 "../hrCtl.st"
			seqg_var->hc = 12.3984244;
# line 524 "../hrCtl.st"
			seqg_var->PI = 4 * atan(1.0);
# line 525 "../hrCtl.st"
			seqg_var->R2D = 180 / seqg_var->PI;
# line 526 "../hrCtl.st"
			seqg_var->uR2D = seqg_var->R2D / 1000000;
# line 527 "../hrCtl.st"
			seqg_var->D2R = seqg_var->PI / 180;
# line 528 "../hrCtl.st"
			seqg_var->D2uR = 1000000 * seqg_var->PI / 180;
# line 529 "../hrCtl.st"
			seqg_var->phi1MotStop = 1;
# line 530 "../hrCtl.st"
			seqg_var->phi2MotStop = 1;
# line 531 "../hrCtl.st"
			seqg_var->phi1PutComplete = 1;
# line 532 "../hrCtl.st"
			seqg_var->phi2PutComplete = 1;
# line 533 "../hrCtl.st"
			seqg_var->putVals = 0;
# line 534 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 5/*putVals*/, DEFAULT, DEFAULT_TIMEOUT);
# line 535 "../hrCtl.st"
			seqg_var->autoMode = 0;
# line 536 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 6/*autoMode*/, DEFAULT, DEFAULT_TIMEOUT);
# line 537 "../hrCtl.st"
			seqg_var->opAck = 0;
# line 538 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 4/*opAck*/, DEFAULT, DEFAULT_TIMEOUT);
			
    hrCtl_pmacP = seq_macValueGet(ssId,"P");
    hrCtl_pmacM = seq_macValueGet(ssId,"M_PHI1");
    if (hrCtl_pmacP == 0 || hrCtl_pmacM == 0) {
     sprintf(pVar->phi1MotName,"??????");
    } else {
     strcpy(pVar->phi1MotName, hrCtl_pmacP);
     strcat(pVar->phi1MotName, hrCtl_pmacM);
    }
    hrCtl_pmacM = seq_macValueGet(ssId,"M_PHI2");
    if (hrCtl_pmacP == 0 || hrCtl_pmacM == 0) {
     sprintf(pVar->phi2MotName,"??????");
    } else {
     strcpy(pVar->phi2MotName, hrCtl_pmacP);
     strcat(pVar->phi2MotName, hrCtl_pmacM);
    }
   
# line 556 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 46/*phi1MotName*/, DEFAULT, DEFAULT_TIMEOUT);
# line 557 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 47/*phi2MotName*/, DEFAULT, DEFAULT_TIMEOUT);
# line 558 "../hrCtl.st"
			seqg_var->initSeq = 1;
		}
		return;
	case 1:
		{
# line 562 "../hrCtl.st"
			seqg_var->initSeq = 2;
		}
		return;
	case 2:
		{
# line 566 "../hrCtl.st"
			seqg_var->initSeq = 3;
		}
		return;
	case 3:
		{
# line 570 "../hrCtl.st"
			sprintf(seqg_var->seqMsg1, "HR Control Ready");
# line 571 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
			if (hrCtl_LS_TEST) {
# line 573 "../hrCtl.st"
			sprintf(seqg_var->seqMsg2, "LIMIT SWITCH TEST VERSION !!!!");
# line 574 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
# line 575 "../hrCtl.st"
			seqg_var->opAlert = 1;
# line 576 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
			} else {
# line 578 "../hrCtl.st"
			sprintf(seqg_var->seqMsg2, " ");
# line 579 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 581 "../hrCtl.st"
			seqg_var->initSeqDone = 1;
# line 582 "../hrCtl.st"
			seqg_var->phi1 = seqg_var->phi1MotRdbk * seqg_var->uR2D + (seqg_var->phi1Off + seqg_var->worldOff * seqg_var->uR2D);
# line 583 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 32/*phi1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 584 "../hrCtl.st"
			seqg_var->theta1 = seqg_var->phi1;
# line 585 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 28/*theta1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 586 "../hrCtl.st"
			if (seqg_var->Geom == 0)
			{
# line 587 "../hrCtl.st"
				seqg_var->phi2 = seqg_var->phi2MotRdbk * seqg_var->uR2D + seqg_var->phi2Off + seqg_var->worldOff * seqg_var->uR2D;
# line 588 "../hrCtl.st"
				seqg_var->theta2 = seqg_var->phi2 - seqg_var->phi1 - seqg_var->theta1;
			}
			else
			{
# line 590 "../hrCtl.st"
				seqg_var->phi2 = seqg_var->phi2MotRdbk * seqg_var->uR2D + seqg_var->phi2Off - seqg_var->worldOff * seqg_var->uR2D;
# line 591 "../hrCtl.st"
				seqg_var->theta2 = seqg_var->phi2;
			}
# line 593 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:initSequence: opMode=%d, Geom=%d, phi2=%f\n", pVar->opMode, pVar->Geom, pVar->phi2);
# line 594 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 41/*phi2*/, DEFAULT, DEFAULT_TIMEOUT);
# line 595 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 37/*theta2*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "waitForCmndEnter" in state set "hr_Ctl" ******/

/* Entry function for state "waitForCmndEnter" in state set "hr_Ctl" */
static void seqg_entry_hr_Ctl_0_waitForCmndEnter(SS_ID seqg_env)
{
# line 601 "../hrCtl.st"
	if (seqg_var->hrCtlDebug)
		printf("hrCtl:waitForCmndEnter: entry\n");
}

/* Event function for state "waitForCmndEnter" in state set "hr_Ctl" */
static seqBool seqg_event_hr_Ctl_0_waitForCmndEnter(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 603 "../hrCtl.st"
	if (seqg_var->initSeqDone && seq_delay(seqg_env, .1))
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 689 "../hrCtl.st"
	if (!seqg_var->initSeqDone)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 1;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "waitForCmndEnter" in state set "hr_Ctl" */
static void seqg_action_hr_Ctl_0_waitForCmndEnter(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 604 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:waitForCmdEnter: initSeqDone\n");
# line 605 "../hrCtl.st"
			seq_efClear(seqg_env, H1_mon);
# line 606 "../hrCtl.st"
			seq_efClear(seqg_env, K1_mon);
# line 607 "../hrCtl.st"
			seq_efClear(seqg_env, L1_mon);
# line 608 "../hrCtl.st"
			seq_efClear(seqg_env, A1_mon);
# line 609 "../hrCtl.st"
			seq_efClear(seqg_env, H2_mon);
# line 610 "../hrCtl.st"
			seq_efClear(seqg_env, K2_mon);
# line 611 "../hrCtl.st"
			seq_efClear(seqg_env, L2_mon);
# line 612 "../hrCtl.st"
			seq_efClear(seqg_env, A2_mon);
# line 613 "../hrCtl.st"
			seq_efClear(seqg_env, E_mon);
# line 614 "../hrCtl.st"
			seq_efClear(seqg_env, lambda_mon);
# line 615 "../hrCtl.st"
			seq_efClear(seqg_env, theta1_mon);
# line 616 "../hrCtl.st"
			seq_efClear(seqg_env, theta2_mon);
# line 617 "../hrCtl.st"
			seq_efClear(seqg_env, phi1Off_mon);
# line 618 "../hrCtl.st"
			seq_efClear(seqg_env, phi2Off_mon);
# line 619 "../hrCtl.st"
			seq_efClear(seqg_env, worldOff_mon);
# line 620 "../hrCtl.st"
			seq_efClear(seqg_env, useSetMode_mon);
# line 621 "../hrCtl.st"
			seq_efClear(seqg_env, opMode_mon);
# line 622 "../hrCtl.st"
			seq_efClear(seqg_env, Geom_mon);
# line 624 "../hrCtl.st"
			seqg_var->phi1MotRdbkEcho = seqg_var->phi1MotRdbk;
# line 625 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 50/*phi1MotRdbkEcho*/, DEFAULT, DEFAULT_TIMEOUT);
# line 626 "../hrCtl.st"
			seqg_var->phi2MotRdbkEcho = seqg_var->phi2MotRdbk;
# line 627 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 51/*phi2MotRdbkEcho*/, DEFAULT, DEFAULT_TIMEOUT);
# line 629 "../hrCtl.st"
			seqg_var->phi1MotCmdEcho = seqg_var->phi1MotCmdMon;
# line 630 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 48/*phi1MotCmdEcho*/, DEFAULT, DEFAULT_TIMEOUT);
# line 631 "../hrCtl.st"
			seqg_var->phi1DmovEcho = seqg_var->phi1Dmov;
# line 632 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 52/*phi1DmovEcho*/, DEFAULT, DEFAULT_TIMEOUT);
# line 634 "../hrCtl.st"
			seqg_var->phi2MotCmdEcho = seqg_var->phi2MotCmdMon;
# line 635 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 49/*phi2MotCmdEcho*/, DEFAULT, DEFAULT_TIMEOUT);
# line 636 "../hrCtl.st"
			seqg_var->phi2DmovEcho = seqg_var->phi2Dmov;
# line 637 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 53/*phi2DmovEcho*/, DEFAULT, DEFAULT_TIMEOUT);
# line 639 "../hrCtl.st"
			if (seqg_var->autoMode && 0)
			{
# line 641 "../hrCtl.st"
				seqg_var->phi1 = seqg_var->phi1MotCmdMon * seqg_var->uR2D + (seqg_var->phi1Off + seqg_var->worldOff * seqg_var->uR2D);
# line 642 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 32/*phi1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 643 "../hrCtl.st"
				seqg_var->theta1 = seqg_var->phi1;
# line 645 "../hrCtl.st"
				if (seqg_var->Geom == 0)
				{
# line 646 "../hrCtl.st"
					seqg_var->phi2 = seqg_var->phi2MotCmdMon * seqg_var->uR2D + seqg_var->phi2Off + seqg_var->worldOff * seqg_var->uR2D;
				}
				else
				{
# line 648 "../hrCtl.st"
					seqg_var->phi2 = seqg_var->phi2MotCmdMon * seqg_var->uR2D + seqg_var->phi2Off - seqg_var->worldOff * seqg_var->uR2D;
				}
# line 650 "../hrCtl.st"
				if (seqg_var->hrCtlDebug)
					printf("hrCtl:waitForCmdEnter: Geom=%d, phi2=%f\n", pVar->Geom, pVar->phi2);
# line 651 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 41/*phi2*/, DEFAULT, DEFAULT_TIMEOUT);
# line 653 "../hrCtl.st"
				if ((seqg_var->opMode == 0) || (seqg_var->opMode == 1))
				{
# line 654 "../hrCtl.st"
					seqg_var->lambda = seqg_var->D1 * sin(seqg_var->theta1 * seqg_var->D2R);
				}
				else
				{
# line 656 "../hrCtl.st"
					seqg_var->theta2Nom = asin(seqg_var->D1 * sin(seqg_var->theta1 * seqg_var->D2R) / seqg_var->D2) * seqg_var->R2D;
# line 660 "../hrCtl.st"
					seqg_var->lambda = seqg_var->D1 * sin(seqg_var->theta1 * seqg_var->D2R) + seqg_var->D2R * (seqg_var->phi2 - seqg_var->phi1 - seqg_var->theta1 - seqg_var->theta2Nom) / (1 / (seqg_var->D1 * cos(seqg_var->theta1 * seqg_var->D2R)) + 1 / (seqg_var->D2 * cos(seqg_var->theta2Nom * seqg_var->D2R)));
				}
# line 662 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 24/*lambda*/, DEFAULT, DEFAULT_TIMEOUT);
# line 663 "../hrCtl.st"
				seqg_var->theta1 = asin(seqg_var->lambda / seqg_var->D1) * seqg_var->R2D;
# line 664 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 28/*theta1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 665 "../hrCtl.st"
				seqg_var->theta2 = asin(seqg_var->lambda / seqg_var->D2) * seqg_var->R2D;
# line 666 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 37/*theta2*/, DEFAULT, DEFAULT_TIMEOUT);
# line 667 "../hrCtl.st"
				seqg_var->E = seqg_var->hc / seqg_var->lambda;
# line 668 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 20/*E*/, DEFAULT, DEFAULT_TIMEOUT);
				hrCtl_calcReadback(pVar);
# line 672 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 36/*phi1Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 673 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 31/*theta1Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 674 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 45/*phi2Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 675 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 40/*theta2Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 676 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 27/*lambdaRdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 677 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 23/*ERdbk*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 679 "../hrCtl.st"
			seqg_var->opAck = 0;
# line 680 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 4/*opAck*/, DEFAULT, DEFAULT_TIMEOUT);
# line 681 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:waitForCmndEnter: Moving=%d; Done=%d\n", pVar->hr_Moving, pVar->hr_Done);
# line 682 "../hrCtl.st"
			if (seqg_var->hr_Moving && seqg_var->hr_Done)
			{
# line 683 "../hrCtl.st"
				if (seqg_var->hrCtlDebug)
					printf("hrCtl:waitForCmndEnter: asserting 'done'.\n");
# line 684 "../hrCtl.st"
				seqg_var->hr_Moving = 0;
# line 684 "../hrCtl.st"
				seqg_var->hr_Done = 0;
# line 685 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 9/*hr_Moving*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	case 1:
		{
		}
		return;
	}
}

/****** Code for state "waitForCmnd" in state set "hr_Ctl" ******/

/* Entry function for state "waitForCmnd" in state set "hr_Ctl" */
static void seqg_entry_hr_Ctl_0_waitForCmnd(SS_ID seqg_env)
{
# line 695 "../hrCtl.st"
	if (seqg_var->hrCtlDebug)
		printf("hrCtl:waitForCmnd: entry\n");
}

/* Event function for state "waitForCmnd" in state set "hr_Ctl" */
static seqBool seqg_event_hr_Ctl_0_waitForCmnd(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 698 "../hrCtl.st"
	if (seq_efTestAndClear(seqg_env, phi1MotHiLim_mon) || seq_efTestAndClear(seqg_env, phi1MotLoLim_mon) || seq_efTestAndClear(seqg_env, phi2MotHiLim_mon) || seq_efTestAndClear(seqg_env, phi2MotLoLim_mon))
	{
		*seqg_pnst = 5;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 707 "../hrCtl.st"
	if (seq_efTestAndClear(seqg_env, H1_mon) || seq_efTestAndClear(seqg_env, K1_mon) || seq_efTestAndClear(seqg_env, L1_mon) || seq_efTestAndClear(seqg_env, A1_mon) || seq_efTestAndClear(seqg_env, H2_mon) || seq_efTestAndClear(seqg_env, K2_mon) || seq_efTestAndClear(seqg_env, L2_mon) || seq_efTestAndClear(seqg_env, A2_mon))
	{
		*seqg_pnst = 7;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 714 "../hrCtl.st"
	if (seq_efTestAndClear(seqg_env, phi1MotRdbkPseudo_mon))
	{
		*seqg_pnst = 14;
		*seqg_ptrn = 2;
		return TRUE;
	}
# line 719 "../hrCtl.st"
	if (seq_efTestAndClear(seqg_env, phi2MotRdbkPseudo_mon))
	{
		*seqg_pnst = 14;
		*seqg_ptrn = 3;
		return TRUE;
	}
# line 724 "../hrCtl.st"
	if (seq_efTest(seqg_env, E_mon))
	{
		*seqg_pnst = 9;
		*seqg_ptrn = 4;
		return TRUE;
	}
# line 729 "../hrCtl.st"
	if (seq_efTest(seqg_env, lambda_mon))
	{
		*seqg_pnst = 10;
		*seqg_ptrn = 5;
		return TRUE;
	}
# line 734 "../hrCtl.st"
	if (seq_efTest(seqg_env, theta1_mon) || seq_efTest(seqg_env, theta2_mon))
	{
		*seqg_pnst = 11;
		*seqg_ptrn = 6;
		return TRUE;
	}
# line 740 "../hrCtl.st"
	if (seq_efTest(seqg_env, worldOff_mon))
	{
		*seqg_pnst = 12;
		*seqg_ptrn = 7;
		return TRUE;
	}
# line 745 "../hrCtl.st"
	if (seq_efTest(seqg_env, phi1Off_mon) || seq_efTest(seqg_env, phi2Off_mon))
	{
		*seqg_pnst = 5;
		*seqg_ptrn = 8;
		return TRUE;
	}
# line 761 "../hrCtl.st"
	if (seqg_var->putVals && seq_delay(seqg_env, .1))
	{
		*seqg_pnst = 12;
		*seqg_ptrn = 9;
		return TRUE;
	}
# line 765 "../hrCtl.st"
	if (seq_efTest(seqg_env, useSetMode_mon) && seqg_var->useSetMode)
	{
		*seqg_pnst = 9;
		*seqg_ptrn = 10;
		return TRUE;
	}
# line 781 "../hrCtl.st"
	if (seq_efTest(seqg_env, useSetMode_mon) && !seqg_var->useSetMode)
	{
		*seqg_pnst = 5;
		*seqg_ptrn = 11;
		return TRUE;
	}
# line 785 "../hrCtl.st"
	if (seq_efTestAndClear(seqg_env, opMode_mon))
	{
		*seqg_pnst = 12;
		*seqg_ptrn = 12;
		return TRUE;
	}
# line 793 "../hrCtl.st"
	if (seq_efTestAndClear(seqg_env, Geom_mon))
	{
		*seqg_pnst = 12;
		*seqg_ptrn = 13;
		return TRUE;
	}
# line 807 "../hrCtl.st"
	if (seqg_var->ETweakInc || seqg_var->ETweakDec || seqg_var->LTweakInc || seqg_var->LTweakDec || seqg_var->th1TweakInc || seqg_var->th1TweakDec || seqg_var->th2TweakInc || seqg_var->th2TweakDec || seqg_var->worldTweakInc || seqg_var->worldTweakDec)
	{
		*seqg_pnst = 8;
		*seqg_ptrn = 14;
		return TRUE;
	}
# line 810 "../hrCtl.st"
	if (seqg_var->opAck)
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 15;
		return TRUE;
	}
# line 819 "../hrCtl.st"
	if (seq_efTest(seqg_env, hr_Moving_mon))
	{
		*seqg_pnst = 4;
		*seqg_ptrn = 16;
		return TRUE;
	}
# line 823 "../hrCtl.st"
	if ((!seqg_var->phi1Dmov || !seqg_var->phi2Dmov) && seq_delay(seqg_env, .1))
	{
		*seqg_pnst = 14;
		*seqg_ptrn = 17;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "waitForCmnd" in state set "hr_Ctl" */
static void seqg_action_hr_Ctl_0_waitForCmnd(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 699 "../hrCtl.st"
			sprintf(seqg_var->seqMsg1, "Motor Soft Limit Changed");
# line 700 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 701 "../hrCtl.st"
			sprintf(seqg_var->seqMsg2, " ");
# line 702 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 1:
		{
# line 708 "../hrCtl.st"
			sprintf(seqg_var->seqMsg1, "Lattice Spacing Changed");
# line 709 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 710 "../hrCtl.st"
			sprintf(seqg_var->seqMsg2, " ");
# line 711 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 2:
		{
# line 715 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:waitForCmd: phi1MotRdbkPseudo_mon\n");
# line 716 "../hrCtl.st"
			seq_efSet(seqg_env, phi1MotRdbkPseudo_mon);
		}
		return;
	case 3:
		{
# line 720 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:waitForCmd: phi2MotRdbkPseudo_mon\n");
# line 721 "../hrCtl.st"
			seq_efSet(seqg_env, phi2MotRdbkPseudo_mon);
		}
		return;
	case 4:
		{
# line 725 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:waitForCmd: E_mon\n");
# line 726 "../hrCtl.st"
			seq_efClear(seqg_env, E_mon);
		}
		return;
	case 5:
		{
# line 730 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:waitForCmd: lambda_mon\n");
# line 731 "../hrCtl.st"
			seq_efClear(seqg_env, lambda_mon);
		}
		return;
	case 6:
		{
# line 735 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:waitForCmd: theta*_mon\n");
# line 736 "../hrCtl.st"
			seq_efClear(seqg_env, theta1_mon);
# line 737 "../hrCtl.st"
			seq_efClear(seqg_env, theta2_mon);
		}
		return;
	case 7:
		{
# line 741 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:waitForCmd: worldOff_mon\n");
# line 742 "../hrCtl.st"
			seq_efClear(seqg_env, worldOff_mon);
		}
		return;
	case 8:
		{
# line 746 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:waitForCmd: phi*Off_mon\n");
# line 747 "../hrCtl.st"
			seq_efClear(seqg_env, phi1Off_mon);
# line 748 "../hrCtl.st"
			seq_efClear(seqg_env, phi2Off_mon);
			hrCtl_calcReadback(pVar);
# line 751 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 36/*phi1Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 752 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 31/*theta1Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 753 "../hrCtl.st"
			if (seqg_var->opMode != 0)
			{
# line 754 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 45/*phi2Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 755 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 40/*theta2Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 757 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 27/*lambdaRdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 758 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 23/*ERdbk*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 9:
		{
# line 762 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:waitForCmnd:putVals\n");
		}
		return;
	case 10:
		{
# line 766 "../hrCtl.st"
			seq_efClear(seqg_env, useSetMode_mon);
# line 767 "../hrCtl.st"
			seqg_var->EHi = 0;
# line 767 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 21/*EHi*/, DEFAULT, DEFAULT_TIMEOUT);
# line 768 "../hrCtl.st"
			seqg_var->ELo = 0;
# line 768 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 22/*ELo*/, DEFAULT, DEFAULT_TIMEOUT);
# line 769 "../hrCtl.st"
			seqg_var->lambdaHi = 0;
# line 769 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 25/*lambdaHi*/, DEFAULT, DEFAULT_TIMEOUT);
# line 770 "../hrCtl.st"
			seqg_var->lambdaLo = 0;
# line 770 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 26/*lambdaLo*/, DEFAULT, DEFAULT_TIMEOUT);
# line 771 "../hrCtl.st"
			seqg_var->theta1Hi = 0;
# line 771 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 29/*theta1Hi*/, DEFAULT, DEFAULT_TIMEOUT);
# line 772 "../hrCtl.st"
			seqg_var->theta1Lo = 0;
# line 772 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 30/*theta1Lo*/, DEFAULT, DEFAULT_TIMEOUT);
# line 773 "../hrCtl.st"
			seqg_var->phi1Hi = 0;
# line 773 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 34/*phi1Hi*/, DEFAULT, DEFAULT_TIMEOUT);
# line 774 "../hrCtl.st"
			seqg_var->phi1Lo = 0;
# line 774 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 35/*phi1Lo*/, DEFAULT, DEFAULT_TIMEOUT);
# line 775 "../hrCtl.st"
			seqg_var->theta2Hi = 0;
# line 775 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 38/*theta2Hi*/, DEFAULT, DEFAULT_TIMEOUT);
# line 776 "../hrCtl.st"
			seqg_var->theta2Lo = 0;
# line 776 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 39/*theta2Lo*/, DEFAULT, DEFAULT_TIMEOUT);
# line 777 "../hrCtl.st"
			seqg_var->phi2Hi = 0;
# line 777 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 43/*phi2Hi*/, DEFAULT, DEFAULT_TIMEOUT);
# line 778 "../hrCtl.st"
			seqg_var->phi2Lo = 0;
# line 778 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 44/*phi2Lo*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 11:
		{
# line 782 "../hrCtl.st"
			seq_efClear(seqg_env, useSetMode_mon);
		}
		return;
	case 12:
		{
# line 786 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:waitForCmnd: opMode event.\n");
# line 787 "../hrCtl.st"
			seqg_var->autoMode = 0;
# line 788 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 6/*autoMode*/, DEFAULT, DEFAULT_TIMEOUT);
# line 789 "../hrCtl.st"
			sprintf(seqg_var->seqMsg2, "Set to Manual Mode");
# line 790 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 13:
		{
# line 794 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:waitForCmnd: Geom event.\n");
# line 795 "../hrCtl.st"
			seqg_var->autoMode = 0;
# line 796 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 6/*autoMode*/, DEFAULT, DEFAULT_TIMEOUT);
# line 797 "../hrCtl.st"
			sprintf(seqg_var->seqMsg1, "New geometry.  Switch Phi 2 motor dir.");
# line 798 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 799 "../hrCtl.st"
			sprintf(seqg_var->seqMsg2, "and recalibrate monochromator.");
# line 800 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
# line 801 "../hrCtl.st"
			seqg_var->opAlert = 1;
# line 802 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 14:
		{
		}
		return;
	case 15:
		{
# line 811 "../hrCtl.st"
			seqg_var->opAlert = 0;
# line 812 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
# line 813 "../hrCtl.st"
			sprintf(seqg_var->seqMsg1, " ");
# line 814 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 815 "../hrCtl.st"
			sprintf(seqg_var->seqMsg2, " ");
# line 816 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 16:
		{
# line 820 "../hrCtl.st"
			seq_efClear(seqg_env, hr_Moving_mon);
		}
		return;
	case 17:
		{
		}
		return;
	}
}

/****** Code for state "checkAutoMode" in state set "hr_Ctl" ******/

/* Entry function for state "checkAutoMode" in state set "hr_Ctl" */
static void seqg_entry_hr_Ctl_0_checkAutoMode(SS_ID seqg_env)
{
# line 829 "../hrCtl.st"
	if (seqg_var->hrCtlDebug)
		printf("hrCtl:checkAutoMode: entry\n");
}

/* Event function for state "checkAutoMode" in state set "hr_Ctl" */
static seqBool seqg_event_hr_Ctl_0_checkAutoMode(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 831 "../hrCtl.st"
	if (seqg_var->autoMode)
	{
		*seqg_pnst = 6;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 833 "../hrCtl.st"
	if (1)
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 1;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "checkAutoMode" in state set "hr_Ctl" */
static void seqg_action_hr_Ctl_0_checkAutoMode(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
		}
		return;
	case 1:
		{
		}
		return;
	}
}

/****** Code for state "phiLimits" in state set "hr_Ctl" ******/

/* Entry function for state "phiLimits" in state set "hr_Ctl" */
static void seqg_entry_hr_Ctl_0_phiLimits(SS_ID seqg_env)
{
# line 839 "../hrCtl.st"
	if (seqg_var->hrCtlDebug)
		printf("hrCtl:phiLimits: entry\n");
}

/* Event function for state "phiLimits" in state set "hr_Ctl" */
static seqBool seqg_event_hr_Ctl_0_phiLimits(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 6;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "phiLimits" in state set "hr_Ctl" */
static void seqg_action_hr_Ctl_0_phiLimits(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 842 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:phiLimits\n");
# line 843 "../hrCtl.st"
			if (!seqg_var->useSetMode)
			{
# line 845 "../hrCtl.st"
				seqg_var->phi1Hi = seqg_var->phi1MotHiLim * seqg_var->uR2D + (seqg_var->phi1Off + seqg_var->worldOff * seqg_var->uR2D);
# line 846 "../hrCtl.st"
				seqg_var->theta1Hi = seqg_var->phi1Hi;
# line 847 "../hrCtl.st"
				seqg_var->phi1Lo = seqg_var->phi1MotLoLim * seqg_var->uR2D + (seqg_var->phi1Off + seqg_var->worldOff * seqg_var->uR2D);
# line 848 "../hrCtl.st"
				seqg_var->theta1Lo = seqg_var->phi1Lo;
# line 849 "../hrCtl.st"
				if (seqg_var->theta1Hi > seqg_var->thetaMax)
				{
# line 850 "../hrCtl.st"
					seqg_var->theta1Hi = seqg_var->thetaMax;
# line 851 "../hrCtl.st"
					sprintf(seqg_var->seqMsg2, "Theta1HiLim clipped at %.3f", seqg_var->thetaMax);
# line 852 "../hrCtl.st"
					seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
				}
# line 854 "../hrCtl.st"
				if (seqg_var->theta1Lo < seqg_var->thetaMin)
				{
# line 855 "../hrCtl.st"
					seqg_var->theta1Lo = seqg_var->thetaMin;
# line 856 "../hrCtl.st"
					sprintf(seqg_var->seqMsg2, "Theta1LoLim clipped at %.3f", seqg_var->thetaMin);
# line 857 "../hrCtl.st"
					seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
				}
# line 859 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 29/*theta1Hi*/, DEFAULT, DEFAULT_TIMEOUT);
# line 860 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 30/*theta1Lo*/, DEFAULT, DEFAULT_TIMEOUT);
# line 863 "../hrCtl.st"
				if (seqg_var->Geom == 0)
				{
# line 865 "../hrCtl.st"
					seqg_var->phi2Hi = seqg_var->phi2MotHiLim * seqg_var->uR2D + seqg_var->phi2Off + seqg_var->worldOff * seqg_var->uR2D;
# line 866 "../hrCtl.st"
					seqg_var->phi2Lo = seqg_var->phi2MotLoLim * seqg_var->uR2D + seqg_var->phi2Off + seqg_var->worldOff * seqg_var->uR2D;
# line 867 "../hrCtl.st"
					seqg_var->theta2Hi = seqg_var->phi2Hi - seqg_var->phi1Lo - seqg_var->theta1Lo;
# line 868 "../hrCtl.st"
					seqg_var->theta2Lo = seqg_var->phi2Lo - seqg_var->phi1Hi - seqg_var->theta1Hi;
				}
				else
				{
# line 871 "../hrCtl.st"
					seqg_var->phi2Hi = seqg_var->phi2MotHiLim * seqg_var->uR2D + seqg_var->phi2Off - seqg_var->worldOff * seqg_var->uR2D;
# line 872 "../hrCtl.st"
					seqg_var->phi2Lo = seqg_var->phi2MotLoLim * seqg_var->uR2D + seqg_var->phi2Off - seqg_var->worldOff * seqg_var->uR2D;
# line 873 "../hrCtl.st"
					seqg_var->theta2Hi = seqg_var->phi2Hi;
# line 874 "../hrCtl.st"
					seqg_var->theta2Lo = seqg_var->phi2Lo;
				}
# line 876 "../hrCtl.st"
				if (seqg_var->theta2Hi > seqg_var->thetaMax)
				{
# line 877 "../hrCtl.st"
					seqg_var->theta2Hi = seqg_var->thetaMax;
# line 878 "../hrCtl.st"
					sprintf(seqg_var->seqMsg2, "Theta2HiLim clipped at %.3f", seqg_var->thetaMax);
# line 879 "../hrCtl.st"
					seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
				}
# line 881 "../hrCtl.st"
				if (seqg_var->theta2Lo < seqg_var->thetaMin)
				{
# line 882 "../hrCtl.st"
					seqg_var->theta2Lo = seqg_var->thetaMin;
# line 883 "../hrCtl.st"
					sprintf(seqg_var->seqMsg2, "Theta2LoLim clipped at %.3f", seqg_var->thetaMin);
# line 884 "../hrCtl.st"
					seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
				}
# line 886 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 38/*theta2Hi*/, DEFAULT, DEFAULT_TIMEOUT);
# line 887 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 39/*theta2Lo*/, DEFAULT, DEFAULT_TIMEOUT);
# line 890 "../hrCtl.st"
				seqg_var->lambdaHi = ((seqg_var->D1 * sin(seqg_var->theta1Hi * seqg_var->D2R)) < (seqg_var->D2 * sin(seqg_var->theta2Hi * seqg_var->D2R)) ? (seqg_var->D1 * sin(seqg_var->theta1Hi * seqg_var->D2R)) : (seqg_var->D2 * sin(seqg_var->theta2Hi * seqg_var->D2R)));
# line 891 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 25/*lambdaHi*/, DEFAULT, DEFAULT_TIMEOUT);
# line 892 "../hrCtl.st"
				seqg_var->lambdaLo = ((seqg_var->D1 * sin(seqg_var->theta1Lo * seqg_var->D2R)) > (seqg_var->D2 * sin(seqg_var->theta2Lo * seqg_var->D2R)) ? (seqg_var->D1 * sin(seqg_var->theta1Lo * seqg_var->D2R)) : (seqg_var->D2 * sin(seqg_var->theta2Lo * seqg_var->D2R)));
# line 893 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 26/*lambdaLo*/, DEFAULT, DEFAULT_TIMEOUT);
# line 894 "../hrCtl.st"
				seqg_var->EHi = seqg_var->hc / seqg_var->lambdaLo;
# line 895 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 21/*EHi*/, DEFAULT, DEFAULT_TIMEOUT);
# line 896 "../hrCtl.st"
				seqg_var->ELo = seqg_var->hc / seqg_var->lambdaHi;
# line 897 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 22/*ELo*/, DEFAULT, DEFAULT_TIMEOUT);
			}
			else
			{
# line 900 "../hrCtl.st"
				seqg_var->EHi = 0;
# line 900 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 21/*EHi*/, DEFAULT, DEFAULT_TIMEOUT);
# line 901 "../hrCtl.st"
				seqg_var->ELo = 0;
# line 901 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 22/*ELo*/, DEFAULT, DEFAULT_TIMEOUT);
# line 902 "../hrCtl.st"
				seqg_var->lambdaHi = 0;
# line 902 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 25/*lambdaHi*/, DEFAULT, DEFAULT_TIMEOUT);
# line 903 "../hrCtl.st"
				seqg_var->lambdaLo = 0;
# line 903 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 26/*lambdaLo*/, DEFAULT, DEFAULT_TIMEOUT);
# line 904 "../hrCtl.st"
				seqg_var->theta1Hi = 0;
# line 904 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 29/*theta1Hi*/, DEFAULT, DEFAULT_TIMEOUT);
# line 905 "../hrCtl.st"
				seqg_var->theta1Lo = 0;
# line 905 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 30/*theta1Lo*/, DEFAULT, DEFAULT_TIMEOUT);
# line 906 "../hrCtl.st"
				seqg_var->phi1Hi = 0;
# line 906 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 34/*phi1Hi*/, DEFAULT, DEFAULT_TIMEOUT);
# line 907 "../hrCtl.st"
				seqg_var->phi1Lo = 0;
# line 907 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 35/*phi1Lo*/, DEFAULT, DEFAULT_TIMEOUT);
# line 908 "../hrCtl.st"
				seqg_var->theta2Hi = 0;
# line 908 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 38/*theta2Hi*/, DEFAULT, DEFAULT_TIMEOUT);
# line 909 "../hrCtl.st"
				seqg_var->theta2Lo = 0;
# line 909 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 39/*theta2Lo*/, DEFAULT, DEFAULT_TIMEOUT);
# line 910 "../hrCtl.st"
				seqg_var->phi2Hi = 0;
# line 910 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 43/*phi2Hi*/, DEFAULT, DEFAULT_TIMEOUT);
# line 911 "../hrCtl.st"
				seqg_var->phi2Lo = 0;
# line 911 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 44/*phi2Lo*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	}
}

/****** Code for state "checkDone" in state set "hr_Ctl" ******/

/* Entry function for state "checkDone" in state set "hr_Ctl" */
static void seqg_entry_hr_Ctl_0_checkDone(SS_ID seqg_env)
{
# line 918 "../hrCtl.st"
	if (seqg_var->hrCtlDebug)
		printf("hrCtl:checkDone: entry\n");
# line 919 "../hrCtl.st"
	if (!seqg_var->phi1PutComplete)
# line 919 "../hrCtl.st"
		seqg_var->phi1PutComplete = seq_pvPutComplete(seqg_env, 68/*phi1MotCmd*/, 1, FALSE, NULL);
# line 920 "../hrCtl.st"
	if (!seqg_var->phi2PutComplete)
# line 920 "../hrCtl.st"
		seqg_var->phi2PutComplete = seq_pvPutComplete(seqg_env, 69/*phi2MotCmd*/, 1, FALSE, NULL);
}

/* Event function for state "checkDone" in state set "hr_Ctl" */
static seqBool seqg_event_hr_Ctl_0_checkDone(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 923 "../hrCtl.st"
	if (seqg_var->phi1PutComplete && seqg_var->phi2PutComplete)
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 928 "../hrCtl.st"
	if (1)
	{
		*seqg_pnst = 14;
		*seqg_ptrn = 1;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "checkDone" in state set "hr_Ctl" */
static void seqg_action_hr_Ctl_0_checkDone(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 924 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:checkDone: done\n");
# line 925 "../hrCtl.st"
			seqg_var->hr_Done = 1;
		}
		return;
	case 1:
		{
# line 929 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:checkDone: not done\n");
		}
		return;
	}
}

/****** Code for state "dInputChanged" in state set "hr_Ctl" ******/

/* Entry function for state "dInputChanged" in state set "hr_Ctl" */
static void seqg_entry_hr_Ctl_0_dInputChanged(SS_ID seqg_env)
{
# line 935 "../hrCtl.st"
	if (seqg_var->hrCtlDebug)
		printf("hrCtl:dInputChanged: entry\n");
}

/* Event function for state "dInputChanged" in state set "hr_Ctl" */
static seqBool seqg_event_hr_Ctl_0_dInputChanged(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 11;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "dInputChanged" in state set "hr_Ctl" */
static void seqg_action_hr_Ctl_0_dInputChanged(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 938 "../hrCtl.st"
			seqg_var->autoMode = 0;
# line 939 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 6/*autoMode*/, DEFAULT, DEFAULT_TIMEOUT);
# line 940 "../hrCtl.st"
			sprintf(seqg_var->seqMsg2, "Set to Manual Mode");
# line 941 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
			pVar->D1 = hrCtl_calc2dSpacing(pVar, 1, pVar->A1, pVar->H1, pVar->K1, pVar->L1);
# line 943 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 14/*D1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 944 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
			pVar->D2 = hrCtl_calc2dSpacing(pVar, 2, pVar->A2, pVar->H2, pVar->K2, pVar->L2);
# line 946 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 19/*D2*/, DEFAULT, DEFAULT_TIMEOUT);
# line 947 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 949 "../hrCtl.st"
			if (seqg_var->useSetMode)
			{
# line 950 "../hrCtl.st"
				seqg_var->lambdaHi = seqg_var->D1 * sin(seqg_var->theta1Hi * seqg_var->D2R);
# line 951 "../hrCtl.st"
				seqg_var->lambdaLo = seqg_var->D1 * sin(seqg_var->theta1Lo * seqg_var->D2R);
# line 952 "../hrCtl.st"
				seqg_var->EHi = seqg_var->hc / seqg_var->lambdaLo;
# line 953 "../hrCtl.st"
				seqg_var->ELo = seqg_var->hc / seqg_var->lambdaHi;
			}
			else
			{
# line 955 "../hrCtl.st"
				seqg_var->lambdaHi = 0;
# line 956 "../hrCtl.st"
				seqg_var->lambdaLo = 0;
# line 957 "../hrCtl.st"
				seqg_var->EHi = 0;
# line 958 "../hrCtl.st"
				seqg_var->ELo = 0;
			}
# line 960 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 26/*lambdaLo*/, DEFAULT, DEFAULT_TIMEOUT);
# line 961 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 25/*lambdaHi*/, DEFAULT, DEFAULT_TIMEOUT);
# line 962 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 21/*EHi*/, DEFAULT, DEFAULT_TIMEOUT);
# line 963 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 22/*ELo*/, DEFAULT, DEFAULT_TIMEOUT);
# line 964 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "tweak" in state set "hr_Ctl" ******/

/* Entry function for state "tweak" in state set "hr_Ctl" */
static void seqg_entry_hr_Ctl_0_tweak(SS_ID seqg_env)
{
# line 970 "../hrCtl.st"
	if (seqg_var->hrCtlDebug)
		printf("hrCtl:tweak: entry\n");
}

/* Event function for state "tweak" in state set "hr_Ctl" */
static seqBool seqg_event_hr_Ctl_0_tweak(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 972 "../hrCtl.st"
	if (seqg_var->ETweakInc || seqg_var->ETweakDec)
	{
		*seqg_pnst = 9;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 997 "../hrCtl.st"
	if (seqg_var->LTweakInc || seqg_var->LTweakDec)
	{
		*seqg_pnst = 10;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 1022 "../hrCtl.st"
	if (seqg_var->th1TweakInc || seqg_var->th1TweakDec)
	{
		*seqg_pnst = 11;
		*seqg_ptrn = 2;
		return TRUE;
	}
# line 1046 "../hrCtl.st"
	if (seqg_var->th2TweakInc || seqg_var->th2TweakDec)
	{
		*seqg_pnst = 11;
		*seqg_ptrn = 3;
		return TRUE;
	}
# line 1070 "../hrCtl.st"
	if (seqg_var->worldTweakInc || seqg_var->worldTweakDec)
	{
		*seqg_pnst = 12;
		*seqg_ptrn = 4;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "tweak" in state set "hr_Ctl" */
static void seqg_action_hr_Ctl_0_tweak(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 974 "../hrCtl.st"
			if (seqg_var->ETweakInc)
			{
# line 975 "../hrCtl.st"
				seqg_var->temp = seqg_var->E + seqg_var->ETweakVal / 1000000;
			}
			else
			{
# line 977 "../hrCtl.st"
				seqg_var->temp = seqg_var->E - seqg_var->ETweakVal / 1000000;
			}
# line 979 "../hrCtl.st"
			if (seqg_var->useSetMode || ((seqg_var->temp >= seqg_var->ELo) && (seqg_var->temp <= seqg_var->EHi)))
			{
# line 980 "../hrCtl.st"
				seqg_var->E = seqg_var->temp;
# line 981 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 20/*E*/, DEFAULT, DEFAULT_TIMEOUT);
# line 982 "../hrCtl.st"
				sprintf(seqg_var->seqMsg1, "Tweaked E");
# line 983 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
			}
			else
			{
# line 985 "../hrCtl.st"
				sprintf(seqg_var->seqMsg1, "Exceeds Limit");
# line 986 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 987 "../hrCtl.st"
				seqg_var->opAlert = 1;
# line 988 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 990 "../hrCtl.st"
			if (seqg_var->ETweakInc)
			{
# line 991 "../hrCtl.st"
				seqg_var->ETweakInc = 0;
# line 991 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 80/*ETweakInc*/, DEFAULT, DEFAULT_TIMEOUT);
			}
			else
			{
# line 993 "../hrCtl.st"
				seqg_var->ETweakDec = 0;
# line 993 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 81/*ETweakDec*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	case 1:
		{
# line 999 "../hrCtl.st"
			if (seqg_var->LTweakInc)
			{
# line 1000 "../hrCtl.st"
				seqg_var->temp = seqg_var->lambda + seqg_var->LTweakVal / 100000;
			}
			else
			{
# line 1002 "../hrCtl.st"
				seqg_var->temp = seqg_var->lambda - seqg_var->LTweakVal / 100000;
			}
# line 1004 "../hrCtl.st"
			if (seqg_var->useSetMode || ((seqg_var->temp >= seqg_var->lambdaLo) && (seqg_var->temp <= seqg_var->lambdaHi)))
			{
# line 1005 "../hrCtl.st"
				seqg_var->lambda = seqg_var->temp;
# line 1006 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 24/*lambda*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1007 "../hrCtl.st"
				sprintf(seqg_var->seqMsg1, "Tweaked Lambda");
# line 1008 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
			}
			else
			{
# line 1010 "../hrCtl.st"
				sprintf(seqg_var->seqMsg1, "Exceeds Limit");
# line 1011 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1012 "../hrCtl.st"
				seqg_var->opAlert = 1;
# line 1013 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 1015 "../hrCtl.st"
			if (seqg_var->LTweakInc)
			{
# line 1016 "../hrCtl.st"
				seqg_var->LTweakInc = 0;
# line 1016 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 83/*LTweakInc*/, DEFAULT, DEFAULT_TIMEOUT);
			}
			else
			{
# line 1018 "../hrCtl.st"
				seqg_var->LTweakDec = 0;
# line 1018 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 84/*LTweakDec*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	case 2:
		{
# line 1023 "../hrCtl.st"
			if (seqg_var->th1TweakInc)
			{
# line 1024 "../hrCtl.st"
				seqg_var->temp = seqg_var->theta1 + seqg_var->th1TweakVal;
			}
			else
			{
# line 1026 "../hrCtl.st"
				seqg_var->temp = seqg_var->theta1 - seqg_var->th1TweakVal;
			}
# line 1028 "../hrCtl.st"
			if (seqg_var->useSetMode || ((seqg_var->temp >= seqg_var->theta1Lo) && (seqg_var->temp <= seqg_var->theta1Hi)))
			{
# line 1029 "../hrCtl.st"
				seqg_var->theta1 = seqg_var->temp;
# line 1030 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 28/*theta1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1031 "../hrCtl.st"
				sprintf(seqg_var->seqMsg1, "Tweaked Theta 1");
# line 1032 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
			}
			else
			{
# line 1034 "../hrCtl.st"
				sprintf(seqg_var->seqMsg1, "Exceeds Limit");
# line 1035 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1036 "../hrCtl.st"
				seqg_var->opAlert = 1;
# line 1037 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 1039 "../hrCtl.st"
			if (seqg_var->th1TweakInc)
			{
# line 1040 "../hrCtl.st"
				seqg_var->th1TweakInc = 0;
# line 1040 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 86/*th1TweakInc*/, DEFAULT, DEFAULT_TIMEOUT);
			}
			else
			{
# line 1042 "../hrCtl.st"
				seqg_var->th1TweakDec = 0;
# line 1042 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 87/*th1TweakDec*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	case 3:
		{
# line 1047 "../hrCtl.st"
			if (seqg_var->th2TweakInc)
			{
# line 1048 "../hrCtl.st"
				seqg_var->temp = seqg_var->theta2 + seqg_var->th2TweakVal;
			}
			else
			{
# line 1050 "../hrCtl.st"
				seqg_var->temp = seqg_var->theta2 - seqg_var->th2TweakVal;
			}
# line 1052 "../hrCtl.st"
			if (seqg_var->useSetMode || ((seqg_var->temp >= seqg_var->theta2Lo) && (seqg_var->temp <= seqg_var->theta2Hi)))
			{
# line 1053 "../hrCtl.st"
				seqg_var->theta2 = seqg_var->temp;
# line 1054 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 37/*theta2*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1055 "../hrCtl.st"
				sprintf(seqg_var->seqMsg1, "Tweaked Theta 2");
# line 1056 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
			}
			else
			{
# line 1058 "../hrCtl.st"
				sprintf(seqg_var->seqMsg1, "Exceeds Limit");
# line 1059 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1060 "../hrCtl.st"
				seqg_var->opAlert = 1;
# line 1061 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 1063 "../hrCtl.st"
			if (seqg_var->th2TweakInc)
			{
# line 1064 "../hrCtl.st"
				seqg_var->th2TweakInc = 0;
# line 1064 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 89/*th2TweakInc*/, DEFAULT, DEFAULT_TIMEOUT);
			}
			else
			{
# line 1066 "../hrCtl.st"
				seqg_var->th2TweakDec = 0;
# line 1066 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 90/*th2TweakDec*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	case 4:
		{
# line 1071 "../hrCtl.st"
			if (seqg_var->worldTweakInc)
			{
# line 1072 "../hrCtl.st"
				seqg_var->worldOff = seqg_var->worldOff + seqg_var->worldTweakVal;
			}
			else
			{
# line 1074 "../hrCtl.st"
				seqg_var->worldOff = seqg_var->worldOff - seqg_var->worldTweakVal;
			}
# line 1076 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 74/*worldOff*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1077 "../hrCtl.st"
			sprintf(seqg_var->seqMsg1, "Tweaked world");
# line 1078 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1079 "../hrCtl.st"
			if (seqg_var->worldTweakInc)
			{
# line 1080 "../hrCtl.st"
				seqg_var->worldTweakInc = 0;
# line 1080 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 76/*worldTweakInc*/, DEFAULT, DEFAULT_TIMEOUT);
			}
			else
			{
# line 1082 "../hrCtl.st"
				seqg_var->worldTweakDec = 0;
# line 1082 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 77/*worldTweakDec*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	}
}

/****** Code for state "eChanged" in state set "hr_Ctl" ******/

/* Entry function for state "eChanged" in state set "hr_Ctl" */
static void seqg_entry_hr_Ctl_0_eChanged(SS_ID seqg_env)
{
# line 1090 "../hrCtl.st"
	if (seqg_var->hrCtlDebug)
		printf("hrCtl:eChanged: entry\n");
}

/* Event function for state "eChanged" in state set "hr_Ctl" */
static seqBool seqg_event_hr_Ctl_0_eChanged(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 10;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "eChanged" in state set "hr_Ctl" */
static void seqg_action_hr_Ctl_0_eChanged(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 1093 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:eChanged\n");
# line 1094 "../hrCtl.st"
			seqg_var->lambda = seqg_var->hc / seqg_var->E;
# line 1095 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 24/*lambda*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "lChanged" in state set "hr_Ctl" ******/

/* Entry function for state "lChanged" in state set "hr_Ctl" */
static void seqg_entry_hr_Ctl_0_lChanged(SS_ID seqg_env)
{
# line 1101 "../hrCtl.st"
	if (seqg_var->hrCtlDebug)
		printf("hrCtl:lChanged: entry\n");
}

/* Event function for state "lChanged" in state set "hr_Ctl" */
static seqBool seqg_event_hr_Ctl_0_lChanged(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 1103 "../hrCtl.st"
	if (seqg_var->lambda > seqg_var->D1)
	{
		*seqg_pnst = 11;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 1111 "../hrCtl.st"
	if ((seqg_var->lambda > seqg_var->D2) && (seqg_var->opMode != 0))
	{
		*seqg_pnst = 11;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 1119 "../hrCtl.st"
	if (seqg_var->opMode == 0)
	{
		*seqg_pnst = 11;
		*seqg_ptrn = 2;
		return TRUE;
	}
# line 1126 "../hrCtl.st"
	if (seqg_var->opMode == 1)
	{
		*seqg_pnst = 11;
		*seqg_ptrn = 3;
		return TRUE;
	}
# line 1135 "../hrCtl.st"
	if (seqg_var->opMode == 2)
	{
		*seqg_pnst = 11;
		*seqg_ptrn = 4;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "lChanged" in state set "hr_Ctl" */
static void seqg_action_hr_Ctl_0_lChanged(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 1105 "../hrCtl.st"
			sprintf(seqg_var->seqMsg1, "Wavelength > 2d spacing of crystal 1.");
# line 1106 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1107 "../hrCtl.st"
			seqg_var->opAlert = 1;
# line 1108 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 1:
		{
# line 1113 "../hrCtl.st"
			sprintf(seqg_var->seqMsg1, "Wavelength > 2d spacing of crystal 2.");
# line 1114 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1115 "../hrCtl.st"
			seqg_var->opAlert = 1;
# line 1116 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 2:
		{
# line 1120 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:lChanged, opMode 0\n");
# line 1122 "../hrCtl.st"
			seqg_var->theta1 = asin(seqg_var->lambda / seqg_var->D1) * seqg_var->R2D;
# line 1123 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 28/*theta1*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 3:
		{
# line 1127 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:lChanged, opMode 1\n");
# line 1129 "../hrCtl.st"
			seqg_var->theta1 = asin(seqg_var->lambda / seqg_var->D1) * seqg_var->R2D;
# line 1130 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 28/*theta1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1131 "../hrCtl.st"
			seqg_var->theta2 = asin(seqg_var->lambda / seqg_var->D2) * seqg_var->R2D;
# line 1132 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 37/*theta2*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 4:
		{
# line 1136 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:lChanged, opMode 1\n");
# line 1142 "../hrCtl.st"
			seqg_var->theta2 = asin(seqg_var->lambda / seqg_var->D2) * seqg_var->R2D;
# line 1143 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 37/*theta2*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "thChanged" in state set "hr_Ctl" ******/

/* Entry function for state "thChanged" in state set "hr_Ctl" */
static void seqg_entry_hr_Ctl_0_thChanged(SS_ID seqg_env)
{
# line 1149 "../hrCtl.st"
	if (seqg_var->hrCtlDebug)
		printf("hrCtl:thChanged: entry\n");
}

/* Event function for state "thChanged" in state set "hr_Ctl" */
static seqBool seqg_event_hr_Ctl_0_thChanged(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 12;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "thChanged" in state set "hr_Ctl" */
static void seqg_action_hr_Ctl_0_thChanged(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 1152 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:thChanged\n");
# line 1153 "../hrCtl.st"
			if (!seqg_var->useSetMode && ((seqg_var->theta1 <= seqg_var->theta1Lo) || (seqg_var->theta1 >= seqg_var->theta1Hi)))
			{
# line 1154 "../hrCtl.st"
				sprintf(seqg_var->seqMsg1, "Theta 1 constrained to LIMIT");
# line 1155 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1156 "../hrCtl.st"
				seqg_var->opAlert = 1;
# line 1157 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1158 "../hrCtl.st"
				seqg_var->autoMode = 0;
# line 1159 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 6/*autoMode*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1160 "../hrCtl.st"
				sprintf(seqg_var->seqMsg2, "Set to Manual Mode");
# line 1161 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 1164 "../hrCtl.st"
			if (!seqg_var->useSetMode && (seqg_var->opMode != 0) && ((seqg_var->theta2 <= seqg_var->theta2Lo) || (seqg_var->theta2 >= seqg_var->theta2Hi)))
			{
# line 1165 "../hrCtl.st"
				sprintf(seqg_var->seqMsg1, "Theta 2 constrained to LIMIT");
# line 1166 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1167 "../hrCtl.st"
				seqg_var->opAlert = 1;
# line 1168 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1169 "../hrCtl.st"
				seqg_var->autoMode = 0;
# line 1170 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 6/*autoMode*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1171 "../hrCtl.st"
				sprintf(seqg_var->seqMsg2, "Set to Manual Mode");
# line 1172 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 1175 "../hrCtl.st"
			if ((seqg_var->opMode == 0) || (seqg_var->opMode == 1))
			{
# line 1176 "../hrCtl.st"
				seqg_var->lambda = seqg_var->D1 * sin(seqg_var->theta1 * seqg_var->D2R);
# line 1177 "../hrCtl.st"
				seqg_var->phi1 = seqg_var->theta1;
# line 1178 "../hrCtl.st"
				if (seqg_var->opMode == 1)
				{
# line 1179 "../hrCtl.st"
					if (seqg_var->Geom == 0)
					{
# line 1180 "../hrCtl.st"
						seqg_var->phi2 = seqg_var->phi1 + seqg_var->theta1 + seqg_var->theta2;
					}
					else
					{
# line 1182 "../hrCtl.st"
						seqg_var->phi2 = seqg_var->theta2;
					}
# line 1184 "../hrCtl.st"
					if (seqg_var->hrCtlDebug)
						printf("hrCtl:thChanged: opMode=%d, Geom=%d, theta2=%f\n", pVar->opMode, pVar->Geom, pVar->theta2);
				}
			}
			else
			{
# line 1187 "../hrCtl.st"
				seqg_var->lambdaNom = seqg_var->D1 * sin(seqg_var->theta1 * seqg_var->D2R);
# line 1188 "../hrCtl.st"
				seqg_var->theta2Nom = asin(seqg_var->lambdaNom / seqg_var->D2) * seqg_var->R2D;
# line 1189 "../hrCtl.st"
				seqg_var->lambda = seqg_var->D2 * sin(seqg_var->theta2 * seqg_var->D2R);
# line 1190 "../hrCtl.st"
				seqg_var->phi1 = seqg_var->theta1;
# line 1191 "../hrCtl.st"
				if (seqg_var->Geom == 0)
				{
# line 1193 "../hrCtl.st"
					seqg_var->phi2 = (seqg_var->phi1 + seqg_var->theta1 + seqg_var->theta2Nom) + seqg_var->R2D * (seqg_var->lambda - seqg_var->lambdaNom) * (1 / (seqg_var->D1 * cos(seqg_var->theta1 * seqg_var->D2R)) + 1 / (seqg_var->D2 * cos(seqg_var->theta2Nom * seqg_var->D2R)));
				}
				else
				{
# line 1196 "../hrCtl.st"
					seqg_var->phi2 = seqg_var->theta2Nom + seqg_var->R2D * (seqg_var->lambda - seqg_var->lambdaNom) * (1 / (seqg_var->D1 * cos(seqg_var->theta1 * seqg_var->D2R)) + 1 / (seqg_var->D2 * cos(seqg_var->theta2Nom * seqg_var->D2R)));
				}
			}
# line 1199 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 32/*phi1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1200 "../hrCtl.st"
			if (seqg_var->opMode != 0)
			{
# line 1201 "../hrCtl.st"
				if (seqg_var->hrCtlDebug)
					printf("hrCtl:thChanged: opMode=%d, Geom=%d, phi2=%f\n", pVar->opMode, pVar->Geom, pVar->phi2);
# line 1202 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 41/*phi2*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 1204 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 24/*lambda*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1206 "../hrCtl.st"
			seqg_var->E = seqg_var->hc / seqg_var->lambda;
# line 1207 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 20/*E*/, DEFAULT, DEFAULT_TIMEOUT);
			hrCtl_calcReadback(pVar);
# line 1214 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 36/*phi1Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1215 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 31/*theta1Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1216 "../hrCtl.st"
			if (seqg_var->opMode != 0)
			{
# line 1217 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 45/*phi2Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1218 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 40/*theta2Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 1220 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 27/*lambdaRdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1221 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 23/*ERdbk*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "calcMovements" in state set "hr_Ctl" ******/

/* Entry function for state "calcMovements" in state set "hr_Ctl" */
static void seqg_entry_hr_Ctl_0_calcMovements(SS_ID seqg_env)
{
# line 1227 "../hrCtl.st"
	if (seqg_var->hrCtlDebug)
		printf("hrCtl:calcMovements: entry\n");
}

/* Event function for state "calcMovements" in state set "hr_Ctl" */
static seqBool seqg_event_hr_Ctl_0_calcMovements(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 1229 "../hrCtl.st"
	if (seqg_var->useSetMode == 0)
	{
		*seqg_pnst = 13;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 1244 "../hrCtl.st"
	if (seqg_var->useSetMode == 1)
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 1;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "calcMovements" in state set "hr_Ctl" */
static void seqg_action_hr_Ctl_0_calcMovements(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 1230 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:calcMovements, USE\n");
# line 1232 "../hrCtl.st"
			seqg_var->phi1MotDesired = (seqg_var->phi1 - seqg_var->phi1Off - seqg_var->worldOff * seqg_var->uR2D) * seqg_var->D2uR;
# line 1233 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 62/*phi1MotDesired*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1234 "../hrCtl.st"
			if (seqg_var->opMode != 0)
			{
# line 1235 "../hrCtl.st"
				if (seqg_var->Geom == 0)
				{
# line 1236 "../hrCtl.st"
					seqg_var->phi2MotDesired = (seqg_var->phi2 - seqg_var->phi2Off - seqg_var->worldOff * seqg_var->uR2D) * seqg_var->D2uR;
				}
				else
				{
# line 1238 "../hrCtl.st"
					seqg_var->phi2MotDesired = (seqg_var->phi2 - seqg_var->phi2Off + seqg_var->worldOff * seqg_var->uR2D) * seqg_var->D2uR;
				}
# line 1240 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 63/*phi2MotDesired*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	case 1:
		{
# line 1245 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:calcMovements, SET\n");
# line 1248 "../hrCtl.st"
			seqg_var->phi1Off = seqg_var->phi1 - seqg_var->phi1MotRdbk / seqg_var->D2uR;
# line 1249 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 33/*phi1Off*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1250 "../hrCtl.st"
			if (seqg_var->opMode != 0)
			{
# line 1258 "../hrCtl.st"
				seqg_var->phi2Off = seqg_var->phi2 - seqg_var->phi2MotRdbk / seqg_var->D2uR;
# line 1259 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 42/*phi2Off*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 1262 "../hrCtl.st"
			seqg_var->phi1MotDesired = (seqg_var->phi1 - seqg_var->phi1Off - seqg_var->worldOff * seqg_var->uR2D) * seqg_var->D2uR;
# line 1263 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 62/*phi1MotDesired*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1264 "../hrCtl.st"
			if (seqg_var->opMode != 0)
			{
# line 1265 "../hrCtl.st"
				if (seqg_var->Geom == 0)
				{
# line 1266 "../hrCtl.st"
					seqg_var->phi2MotDesired = (seqg_var->phi2 - seqg_var->phi2Off - seqg_var->worldOff * seqg_var->uR2D) * seqg_var->D2uR;
				}
				else
				{
# line 1268 "../hrCtl.st"
					seqg_var->phi2MotDesired = (seqg_var->phi2 - seqg_var->phi2Off + seqg_var->worldOff * seqg_var->uR2D) * seqg_var->D2uR;
				}
# line 1270 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 63/*phi2MotDesired*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 1272 "../hrCtl.st"
			seqg_var->putVals = 0;
# line 1273 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 5/*putVals*/, DEFAULT, DEFAULT_TIMEOUT);
			hrCtl_calcReadback(pVar);
# line 1277 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 36/*phi1Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1278 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 31/*theta1Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1279 "../hrCtl.st"
			if (seqg_var->opMode != 0)
			{
# line 1280 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 45/*phi2Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1281 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 40/*theta2Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 1283 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 27/*lambdaRdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1284 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 23/*ERdbk*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "moveHR" in state set "hr_Ctl" ******/

/* Entry function for state "moveHR" in state set "hr_Ctl" */
static void seqg_entry_hr_Ctl_0_moveHR(SS_ID seqg_env)
{
# line 1290 "../hrCtl.st"
	if (seqg_var->hrCtlDebug)
		printf("hrCtl:moveHR entry\n");
}

/* Event function for state "moveHR" in state set "hr_Ctl" */
static seqBool seqg_event_hr_Ctl_0_moveHR(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 1292 "../hrCtl.st"
	if (seqg_var->autoMode || seqg_var->putVals)
	{
		*seqg_pnst = 14;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 1310 "../hrCtl.st"
	if (1)
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 1;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "moveHR" in state set "hr_Ctl" */
static void seqg_action_hr_Ctl_0_moveHR(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 1293 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:moveHR: putting to motors\n");
# line 1294 "../hrCtl.st"
			seqg_var->phi1MotCmd = seqg_var->phi1MotDesired;
# line 1295 "../hrCtl.st"
			if (seqg_var->opMode == 0)
			{
# line 1296 "../hrCtl.st"
				seqg_var->phi1PutComplete = 0;
# line 1297 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 68/*phi1MotCmd*/, ASYNC, DEFAULT_TIMEOUT);
			}
			else
# line 1298 "../hrCtl.st"
				if ((seqg_var->opMode == 1) || (seqg_var->opMode == 2))
				{
# line 1299 "../hrCtl.st"
					seqg_var->phi2MotCmd = seqg_var->phi2MotDesired;
# line 1300 "../hrCtl.st"
					seqg_var->phi1PutComplete = 0;
# line 1301 "../hrCtl.st"
					seqg_var->phi2PutComplete = 0;
# line 1302 "../hrCtl.st"
					seq_pvPutTmo(seqg_env, 69/*phi2MotCmd*/, ASYNC, DEFAULT_TIMEOUT);
# line 1303 "../hrCtl.st"
					seq_pvPutTmo(seqg_env, 68/*phi1MotCmd*/, ASYNC, DEFAULT_TIMEOUT);
				}
# line 1305 "../hrCtl.st"
			seqg_var->putVals = 0;
# line 1306 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 5/*putVals*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1307 "../hrCtl.st"
			seqg_var->causedMove = 1;
		}
		return;
	case 1:
		{
# line 1311 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:moveHR: NOT putting to motors\n");
		}
		return;
	}
}

/****** Code for state "updateRdbk" in state set "hr_Ctl" ******/

/* Entry function for state "updateRdbk" in state set "hr_Ctl" */
static void seqg_entry_hr_Ctl_0_updateRdbk(SS_ID seqg_env)
{
# line 1317 "../hrCtl.st"
	if (seqg_var->hrCtlDebug)
		printf("hrCtl:updateRdbk: entry\n");
# line 1318 "../hrCtl.st"
	if (!seqg_var->phi1PutComplete)
# line 1318 "../hrCtl.st"
		seqg_var->phi1PutComplete = seq_pvPutComplete(seqg_env, 68/*phi1MotCmd*/, 1, FALSE, NULL);
# line 1319 "../hrCtl.st"
	if (!seqg_var->phi2PutComplete)
# line 1319 "../hrCtl.st"
		seqg_var->phi2PutComplete = seq_pvPutComplete(seqg_env, 69/*phi2MotCmd*/, 1, FALSE, NULL);
}

/* Event function for state "updateRdbk" in state set "hr_Ctl" */
static seqBool seqg_event_hr_Ctl_0_updateRdbk(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 1321 "../hrCtl.st"
	if (seqg_var->phi1Hls || seqg_var->phi1Lls || seqg_var->phi2Hls || seqg_var->phi2Lls)
	{
		*seqg_pnst = 19;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 1338 "../hrCtl.st"
	if (!seqg_var->phi1Dmov || !seqg_var->phi2Dmov)
	{
		*seqg_pnst = 15;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 1355 "../hrCtl.st"
	if (seqg_var->phi1PutComplete && seqg_var->phi2PutComplete)
	{
		*seqg_pnst = 16;
		*seqg_ptrn = 2;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "updateRdbk" in state set "hr_Ctl" */
static void seqg_action_hr_Ctl_0_updateRdbk(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 1322 "../hrCtl.st"
			if (seqg_var->phi1Hls || seqg_var->phi1Lls)
			{
# line 1323 "../hrCtl.st"
				sprintf(seqg_var->seqMsg1, "Theta 1 motor hit a limit switch !");
# line 1324 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 1326 "../hrCtl.st"
			if ((seqg_var->opMode != 0) && (seqg_var->phi2Hls || seqg_var->phi2Lls))
			{
# line 1327 "../hrCtl.st"
				sprintf(seqg_var->seqMsg1, "Theta 2 motor hit a limit switch !");
# line 1328 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 1330 "../hrCtl.st"
			seqg_var->opAlert = 1;
# line 1331 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1332 "../hrCtl.st"
			seqg_var->autoMode = 0;
# line 1333 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 6/*autoMode*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1334 "../hrCtl.st"
			sprintf(seqg_var->seqMsg2, "Setting to Manual Mode");
# line 1335 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 1:
		{
# line 1339 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:updateRdbk: a motor is moving\n");
# line 1340 "../hrCtl.st"
			seqg_var->hr_Moving = 1;
# line 1341 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 9/*hr_Moving*/, DEFAULT, DEFAULT_TIMEOUT);
			hrCtl_calcReadback(pVar);
# line 1345 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 36/*phi1Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1346 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 31/*theta1Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1347 "../hrCtl.st"
			if (seqg_var->opMode != 0)
			{
# line 1348 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 45/*phi2Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1349 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 40/*theta2Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 1351 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 27/*lambdaRdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1352 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 23/*ERdbk*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 2:
		{
# line 1356 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:updateRdbk: motors stopped\n");
			hrCtl_calcReadback(pVar);
# line 1359 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 36/*phi1Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1360 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 31/*theta1Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1361 "../hrCtl.st"
			if (seqg_var->opMode != 0)
			{
# line 1362 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 45/*phi2Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1363 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 40/*theta2Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 1365 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 27/*lambdaRdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1366 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 23/*ERdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1367 "../hrCtl.st"
			seqg_var->hr_Done = 1;
		}
		return;
	}
}

/****** Code for state "updateRdbkAfterDelay" in state set "hr_Ctl" ******/

/* Event function for state "updateRdbkAfterDelay" in state set "hr_Ctl" */
static seqBool seqg_event_hr_Ctl_0_updateRdbkAfterDelay(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 1372 "../hrCtl.st"
	if (seq_delay(seqg_env, .1))
	{
		*seqg_pnst = 14;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "updateRdbkAfterDelay" in state set "hr_Ctl" */
static void seqg_action_hr_Ctl_0_updateRdbkAfterDelay(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
		}
		return;
	}
}

/****** Code for state "motorsStopped" in state set "hr_Ctl" ******/

/* Entry function for state "motorsStopped" in state set "hr_Ctl" */
static void seqg_entry_hr_Ctl_0_motorsStopped(SS_ID seqg_env)
{
# line 1378 "../hrCtl.st"
	if (seqg_var->hrCtlDebug)
		printf("hrCtl:motorsStopped: entry\n");
}

/* Event function for state "motorsStopped" in state set "hr_Ctl" */
static seqBool seqg_event_hr_Ctl_0_motorsStopped(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 1380 "../hrCtl.st"
	if (seqg_var->causedMove)
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 1385 "../hrCtl.st"
	if (!seqg_var->causedMove)
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 1;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "motorsStopped" in state set "hr_Ctl" */
static void seqg_action_hr_Ctl_0_motorsStopped(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 1381 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:motorsStopped (we started them)\n");
# line 1382 "../hrCtl.st"
			seqg_var->causedMove = 0;
		}
		return;
	case 1:
		{
# line 1386 "../hrCtl.st"
			if (seqg_var->hrCtlDebug)
				printf("hrCtl:motorsStopped (we didn't start them)\n");
# line 1388 "../hrCtl.st"
			if (seqg_var->initSeqDone)
			{
# line 1389 "../hrCtl.st"
				seqg_var->opAlert = 1;
# line 1390 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1391 "../hrCtl.st"
				sprintf(seqg_var->seqMsg1, "Somebody moved one of my motors.");
# line 1392 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1393 "../hrCtl.st"
				seqg_var->autoMode = 0;
# line 1394 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 6/*autoMode*/, DEFAULT, DEFAULT_TIMEOUT);
			}
			hrCtl_calcReadback(pVar);
# line 1398 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 36/*phi1Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1399 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 31/*theta1Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1400 "../hrCtl.st"
			if (seqg_var->opMode != 0)
			{
# line 1401 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 45/*phi2Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1402 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 40/*theta2Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 1404 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 27/*lambdaRdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1405 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 23/*ERdbk*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "chkMotorLimits" in state set "hr_Ctl" ******/

/* Entry function for state "chkMotorLimits" in state set "hr_Ctl" */
static void seqg_entry_hr_Ctl_0_chkMotorLimits(SS_ID seqg_env)
{
# line 1411 "../hrCtl.st"
	if (seqg_var->hrCtlDebug)
		printf("hrCtl:chkMotorLimits: entry\n");
}

/* Event function for state "chkMotorLimits" in state set "hr_Ctl" */
static seqBool seqg_event_hr_Ctl_0_chkMotorLimits(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 18;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "chkMotorLimits" in state set "hr_Ctl" */
static void seqg_action_hr_Ctl_0_chkMotorLimits(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 1414 "../hrCtl.st"
			seqg_var->opAlert = 0;
			hrCtl_calcReadback(pVar);
# line 1417 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 36/*phi1Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1418 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 31/*theta1Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1419 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 45/*phi2Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1420 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 40/*theta2Rdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1421 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 27/*lambdaRdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1422 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 23/*ERdbk*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1424 "../hrCtl.st"
			if ((seqg_var->phi1MotRdbk < seqg_var->phi1MotLoLim) || (seqg_var->phi1MotRdbk > seqg_var->phi1MotHiLim))
			{
# line 1425 "../hrCtl.st"
				sprintf(seqg_var->seqMsg1, "Theta 1 motor is outside its limits");
# line 1426 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1427 "../hrCtl.st"
				seqg_var->opAlert = 1;
			}
# line 1429 "../hrCtl.st"
			if ((seqg_var->opMode != 0) && ((seqg_var->phi2MotRdbk < seqg_var->phi2MotLoLim) || (seqg_var->phi2MotRdbk > seqg_var->phi2MotHiLim)))
			{
# line 1431 "../hrCtl.st"
				sprintf(seqg_var->seqMsg1, "Theta 2 motor is outside its limits");
# line 1432 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1433 "../hrCtl.st"
				seqg_var->opAlert = 1;
			}
# line 1435 "../hrCtl.st"
			if (seqg_var->opAlert)
			{
# line 1436 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1437 "../hrCtl.st"
				seqg_var->autoMode = 0;
# line 1438 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 6/*autoMode*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1439 "../hrCtl.st"
				sprintf(seqg_var->seqMsg2, "Set to manual mode");
# line 1440 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	}
}

/****** Code for state "chkMotorLimitsExit" in state set "hr_Ctl" ******/

/* Entry function for state "chkMotorLimitsExit" in state set "hr_Ctl" */
static void seqg_entry_hr_Ctl_0_chkMotorLimitsExit(SS_ID seqg_env)
{
# line 1447 "../hrCtl.st"
	if (seqg_var->hrCtlDebug)
		printf("hrCtl:chkMotorLimitsExit: entry\n");
}

/* Event function for state "chkMotorLimitsExit" in state set "hr_Ctl" */
static seqBool seqg_event_hr_Ctl_0_chkMotorLimitsExit(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 1449 "../hrCtl.st"
	if (!seqg_var->opAlert)
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 1455 "../hrCtl.st"
	if (seqg_var->opAlert && seq_delay(seqg_env, 2.0))
	{
		*seqg_pnst = 17;
		*seqg_ptrn = 1;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "chkMotorLimitsExit" in state set "hr_Ctl" */
static void seqg_action_hr_Ctl_0_chkMotorLimitsExit(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 1450 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1451 "../hrCtl.st"
			sprintf(seqg_var->seqMsg1, "All motors within limits");
# line 1452 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 1/*seqMsg1*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 1:
		{
# line 1456 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 3/*opAlert*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1457 "../hrCtl.st"
			sprintf(seqg_var->seqMsg2, "Modify motor positions and/or limits");
# line 1458 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 2/*seqMsg2*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "stopHR" in state set "hr_Ctl" ******/

/* Entry function for state "stopHR" in state set "hr_Ctl" */
static void seqg_entry_hr_Ctl_0_stopHR(SS_ID seqg_env)
{
# line 1464 "../hrCtl.st"
	if (seqg_var->hrCtlDebug)
		printf("hrCtl:stopHR: entry\n");
}

/* Event function for state "stopHR" in state set "hr_Ctl" */
static seqBool seqg_event_hr_Ctl_0_stopHR(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 20;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "stopHR" in state set "hr_Ctl" */
static void seqg_action_hr_Ctl_0_stopHR(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 1467 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 54/*phi1MotStop*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1468 "../hrCtl.st"
			if (seqg_var->opMode != 0)
# line 1468 "../hrCtl.st"
				seq_pvPutTmo(seqg_env, 55/*phi2MotStop*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "stoppedHRWait" in state set "hr_Ctl" ******/

/* Entry function for state "stoppedHRWait" in state set "hr_Ctl" */
static void seqg_entry_hr_Ctl_0_stoppedHRWait(SS_ID seqg_env)
{
# line 1474 "../hrCtl.st"
	if (seqg_var->hrCtlDebug)
		printf("hrCtl:stoppedHRWait: entry\n");
}

/* Event function for state "stoppedHRWait" in state set "hr_Ctl" */
static seqBool seqg_event_hr_Ctl_0_stoppedHRWait(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 1476 "../hrCtl.st"
	if (seq_delay(seqg_env, 1.0))
	{
		*seqg_pnst = 14;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "stoppedHRWait" in state set "hr_Ctl" */
static void seqg_action_hr_Ctl_0_stoppedHRWait(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
		}
		return;
	}
}

/****** Code for state "init" in state set "updatePsuedo" ******/

/* Entry function for state "init" in state set "updatePsuedo" */
static void seqg_entry_updatePsuedo_1_init(SS_ID seqg_env)
{
# line 1491 "../hrCtl.st"
	if (seqg_var->hrCtlDebug)
		printf("hrCtl:updatePsuedo:init: entry\n");
}

/* Event function for state "init" in state set "updatePsuedo" */
static seqBool seqg_event_updatePsuedo_1_init(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "init" in state set "updatePsuedo" */
static void seqg_action_updatePsuedo_1_init(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
		}
		return;
	}
}

/****** Code for state "update" in state set "updatePsuedo" ******/

/* Entry function for state "update" in state set "updatePsuedo" */
static void seqg_entry_updatePsuedo_1_update(SS_ID seqg_env)
{
# line 1499 "../hrCtl.st"
	if (seqg_var->hrCtlDebug)
		printf("hrCtl:updatePsuedo:update: entry\n");
}

/* Event function for state "update" in state set "updatePsuedo" */
static seqBool seqg_event_updatePsuedo_1_update(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 1501 "../hrCtl.st"
	if (seq_efTestAndClear(seqg_env, phi1MotRdbkPseudo_mon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 1506 "../hrCtl.st"
	if (seq_efTestAndClear(seqg_env, phi2MotRdbkPseudo_mon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 1511 "../hrCtl.st"
	if (seq_efTest(seqg_env, phi1MotCmdMon_mon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 2;
		return TRUE;
	}
# line 1517 "../hrCtl.st"
	if (seq_efTest(seqg_env, phi2MotCmdMon_mon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 3;
		return TRUE;
	}
# line 1523 "../hrCtl.st"
	if (seq_efTest(seqg_env, phi1Dmov_mon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 4;
		return TRUE;
	}
# line 1529 "../hrCtl.st"
	if (seq_efTest(seqg_env, phi2Dmov_mon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 5;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "update" in state set "updatePsuedo" */
static void seqg_action_updatePsuedo_1_update(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 1502 "../hrCtl.st"
			seqg_var->phi1MotRdbkEcho = seqg_var->phi1MotRdbk;
# line 1503 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 50/*phi1MotRdbkEcho*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 1:
		{
# line 1507 "../hrCtl.st"
			seqg_var->phi2MotRdbkEcho = seqg_var->phi2MotRdbk;
# line 1508 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 51/*phi2MotRdbkEcho*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 2:
		{
# line 1512 "../hrCtl.st"
			seqg_var->phi1MotCmdEcho = seqg_var->phi1MotCmdMon;
# line 1513 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 48/*phi1MotCmdEcho*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1514 "../hrCtl.st"
			seq_efClear(seqg_env, phi1MotCmdMon_mon);
		}
		return;
	case 3:
		{
# line 1518 "../hrCtl.st"
			seqg_var->phi2MotCmdEcho = seqg_var->phi2MotCmdMon;
# line 1519 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 49/*phi2MotCmdEcho*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1520 "../hrCtl.st"
			seq_efClear(seqg_env, phi2MotCmdMon_mon);
		}
		return;
	case 4:
		{
# line 1524 "../hrCtl.st"
			seqg_var->phi1DmovEcho = seqg_var->phi1Dmov;
# line 1525 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 52/*phi1DmovEcho*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1526 "../hrCtl.st"
			seq_efClear(seqg_env, phi1Dmov_mon);
		}
		return;
	case 5:
		{
# line 1530 "../hrCtl.st"
			seqg_var->phi2DmovEcho = seqg_var->phi2Dmov;
# line 1531 "../hrCtl.st"
			seq_pvPutTmo(seqg_env, 53/*phi2DmovEcho*/, DEFAULT, DEFAULT_TIMEOUT);
# line 1532 "../hrCtl.st"
			seq_efClear(seqg_env, phi2Dmov_mon);
		}
		return;
	}
}

#undef seqg_var

/************************ Tables ************************/

/* Channel table */
static seqChan seqg_chans[] = {
	/* chName, offset, varName, varType, count, eventNum, efId, monitored, queueSize, queueIndex */
	{"{P}HR{N}CtlDebug", offsetof(struct seqg_vars, hrCtlDebug), "hrCtlDebug", P_SHORT, 1, 34, 0, 1, 0, 0},
	{"{P}HR{N}_SeqMsg1SI", offsetof(struct seqg_vars, seqMsg1), "seqMsg1", P_STRING, 1, 35, 0, 0, 0, 0},
	{"{P}HR{N}_SeqMsg2SI", offsetof(struct seqg_vars, seqMsg2), "seqMsg2", P_STRING, 1, 36, 0, 0, 0, 0},
	{"{P}HR{N}_AlertBO", offsetof(struct seqg_vars, opAlert), "opAlert", P_SHORT, 1, 37, 0, 0, 0, 0},
	{"{P}HR{N}_OperAckBO", offsetof(struct seqg_vars, opAck), "opAck", P_SHORT, 1, 38, 0, 1, 0, 0},
	{"{P}HR{N}_PutBO", offsetof(struct seqg_vars, putVals), "putVals", P_SHORT, 1, 39, 0, 1, 0, 0},
	{"{P}HR{N}_ModeBO", offsetof(struct seqg_vars, autoMode), "autoMode", P_SHORT, 1, 40, 0, 1, 0, 0},
	{"{P}HR{N}_Mode2MO", offsetof(struct seqg_vars, opMode), "opMode", P_SHORT, 1, 41, 1, 1, 0, 0},
	{"{P}HR{N}_GeomMO", offsetof(struct seqg_vars, Geom), "Geom", P_SHORT, 1, 42, 2, 1, 0, 0},
	{"{P}HR{N}_Moving", offsetof(struct seqg_vars, hr_Moving), "hr_Moving", P_SHORT, 1, 43, 3, 1, 0, 0},
	{"{P}HR{N}_H1AO", offsetof(struct seqg_vars, H1), "H1", P_DOUBLE, 1, 44, 4, 1, 0, 0},
	{"{P}HR{N}_K1AO", offsetof(struct seqg_vars, K1), "K1", P_DOUBLE, 1, 45, 5, 1, 0, 0},
	{"{P}HR{N}_L1AO", offsetof(struct seqg_vars, L1), "L1", P_DOUBLE, 1, 46, 6, 1, 0, 0},
	{"{P}HR{N}_A1AO", offsetof(struct seqg_vars, A1), "A1", P_DOUBLE, 1, 47, 7, 1, 0, 0},
	{"{P}HR{N}_2d1AO", offsetof(struct seqg_vars, D1), "D1", P_DOUBLE, 1, 48, 0, 0, 0, 0},
	{"{P}HR{N}_H2AO", offsetof(struct seqg_vars, H2), "H2", P_DOUBLE, 1, 49, 8, 1, 0, 0},
	{"{P}HR{N}_K2AO", offsetof(struct seqg_vars, K2), "K2", P_DOUBLE, 1, 50, 9, 1, 0, 0},
	{"{P}HR{N}_L2AO", offsetof(struct seqg_vars, L2), "L2", P_DOUBLE, 1, 51, 10, 1, 0, 0},
	{"{P}HR{N}_A2AO", offsetof(struct seqg_vars, A2), "A2", P_DOUBLE, 1, 52, 11, 1, 0, 0},
	{"{P}HR{N}_2d2AO", offsetof(struct seqg_vars, D2), "D2", P_DOUBLE, 1, 53, 0, 0, 0, 0},
	{"{P}HR{N}_EAO", offsetof(struct seqg_vars, E), "E", P_DOUBLE, 1, 54, 12, 1, 0, 0},
	{"{P}HR{N}_EAO.DRVH", offsetof(struct seqg_vars, EHi), "EHi", P_DOUBLE, 1, 55, 0, 0, 0, 0},
	{"{P}HR{N}_EAO.DRVL", offsetof(struct seqg_vars, ELo), "ELo", P_DOUBLE, 1, 56, 0, 0, 0, 0},
	{"{P}HR{N}_ERdbkAO", offsetof(struct seqg_vars, ERdbk), "ERdbk", P_DOUBLE, 1, 57, 0, 0, 0, 0},
	{"{P}HR{N}_LambdaAO", offsetof(struct seqg_vars, lambda), "lambda", P_DOUBLE, 1, 58, 13, 1, 0, 0},
	{"{P}HR{N}_LambdaAO.DRVH", offsetof(struct seqg_vars, lambdaHi), "lambdaHi", P_DOUBLE, 1, 59, 0, 0, 0, 0},
	{"{P}HR{N}_LambdaAO.DRVL", offsetof(struct seqg_vars, lambdaLo), "lambdaLo", P_DOUBLE, 1, 60, 0, 0, 0, 0},
	{"{P}HR{N}_LambdaRdbkAO", offsetof(struct seqg_vars, lambdaRdbk), "lambdaRdbk", P_DOUBLE, 1, 61, 0, 0, 0, 0},
	{"{P}HR{N}_Theta1AO", offsetof(struct seqg_vars, theta1), "theta1", P_DOUBLE, 1, 62, 14, 1, 0, 0},
	{"{P}HR{N}_Theta1AO.DRVH", offsetof(struct seqg_vars, theta1Hi), "theta1Hi", P_DOUBLE, 1, 63, 0, 0, 0, 0},
	{"{P}HR{N}_Theta1AO.DRVL", offsetof(struct seqg_vars, theta1Lo), "theta1Lo", P_DOUBLE, 1, 64, 0, 0, 0, 0},
	{"{P}HR{N}_Theta1RdbkAO", offsetof(struct seqg_vars, theta1Rdbk), "theta1Rdbk", P_DOUBLE, 1, 65, 0, 0, 0, 0},
	{"{P}HR{N}_phi1AO", offsetof(struct seqg_vars, phi1), "phi1", P_DOUBLE, 1, 66, 15, 1, 0, 0},
	{"{P}HR{N}_phi1OffAO", offsetof(struct seqg_vars, phi1Off), "phi1Off", P_DOUBLE, 1, 67, 16, 1, 0, 0},
	{"{P}HR{N}_phi1AO.DRVH", offsetof(struct seqg_vars, phi1Hi), "phi1Hi", P_DOUBLE, 1, 68, 0, 0, 0, 0},
	{"{P}HR{N}_phi1AO.DRVL", offsetof(struct seqg_vars, phi1Lo), "phi1Lo", P_DOUBLE, 1, 69, 0, 0, 0, 0},
	{"{P}HR{N}_phi1RdbkAO", offsetof(struct seqg_vars, phi1Rdbk), "phi1Rdbk", P_DOUBLE, 1, 70, 0, 0, 0, 0},
	{"{P}HR{N}_Theta2AO", offsetof(struct seqg_vars, theta2), "theta2", P_DOUBLE, 1, 71, 17, 1, 0, 0},
	{"{P}HR{N}_Theta2AO.DRVH", offsetof(struct seqg_vars, theta2Hi), "theta2Hi", P_DOUBLE, 1, 72, 0, 0, 0, 0},
	{"{P}HR{N}_Theta2AO.DRVL", offsetof(struct seqg_vars, theta2Lo), "theta2Lo", P_DOUBLE, 1, 73, 0, 0, 0, 0},
	{"{P}HR{N}_Theta2RdbkAO", offsetof(struct seqg_vars, theta2Rdbk), "theta2Rdbk", P_DOUBLE, 1, 74, 0, 0, 0, 0},
	{"{P}HR{N}_phi2AO", offsetof(struct seqg_vars, phi2), "phi2", P_DOUBLE, 1, 75, 18, 1, 0, 0},
	{"{P}HR{N}_phi2OffAO", offsetof(struct seqg_vars, phi2Off), "phi2Off", P_DOUBLE, 1, 76, 19, 1, 0, 0},
	{"{P}HR{N}_phi2AO.DRVH", offsetof(struct seqg_vars, phi2Hi), "phi2Hi", P_DOUBLE, 1, 77, 0, 0, 0, 0},
	{"{P}HR{N}_phi2AO.DRVL", offsetof(struct seqg_vars, phi2Lo), "phi2Lo", P_DOUBLE, 1, 78, 0, 0, 0, 0},
	{"{P}HR{N}_phi2RdbkAO", offsetof(struct seqg_vars, phi2Rdbk), "phi2Rdbk", P_DOUBLE, 1, 79, 0, 0, 0, 0},
	{"{P}HR{N}_phi1PvSI", offsetof(struct seqg_vars, phi1MotName), "phi1MotName", P_STRING, 1, 80, 0, 0, 0, 0},
	{"{P}HR{N}_phi2PvSI", offsetof(struct seqg_vars, phi2MotName), "phi2MotName", P_STRING, 1, 81, 0, 0, 0, 0},
	{"{P}HR{N}_phi1CmdAO", offsetof(struct seqg_vars, phi1MotCmdEcho), "phi1MotCmdEcho", P_DOUBLE, 1, 82, 0, 0, 0, 0},
	{"{P}HR{N}_phi2CmdAO", offsetof(struct seqg_vars, phi2MotCmdEcho), "phi2MotCmdEcho", P_DOUBLE, 1, 83, 0, 0, 0, 0},
	{"{P}HR{N}_phi1RdbkAI", offsetof(struct seqg_vars, phi1MotRdbkEcho), "phi1MotRdbkEcho", P_DOUBLE, 1, 84, 0, 0, 0, 0},
	{"{P}HR{N}_phi2RdbkAI", offsetof(struct seqg_vars, phi2MotRdbkEcho), "phi2MotRdbkEcho", P_DOUBLE, 1, 85, 0, 0, 0, 0},
	{"{P}HR{N}_phi1DmovBI", offsetof(struct seqg_vars, phi1DmovEcho), "phi1DmovEcho", P_SHORT, 1, 86, 0, 0, 0, 0},
	{"{P}HR{N}_phi2DmovBI", offsetof(struct seqg_vars, phi2DmovEcho), "phi2DmovEcho", P_SHORT, 1, 87, 0, 0, 0, 0},
	{"{P}{M_PHI1}.STOP", offsetof(struct seqg_vars, phi1MotStop), "phi1MotStop", P_SHORT, 1, 88, 0, 0, 0, 0},
	{"{P}{M_PHI2}.STOP", offsetof(struct seqg_vars, phi2MotStop), "phi2MotStop", P_SHORT, 1, 89, 0, 0, 0, 0},
	{"{P}{M_PHI1}.DMOV", offsetof(struct seqg_vars, phi1Dmov), "phi1Dmov", P_SHORT, 1, 90, 20, 1, 0, 0},
	{"{P}{M_PHI2}.DMOV", offsetof(struct seqg_vars, phi2Dmov), "phi2Dmov", P_SHORT, 1, 91, 21, 1, 0, 0},
	{"{P}{M_PHI1}.HLS", offsetof(struct seqg_vars, phi1Hls), "phi1Hls", P_SHORT, 1, 92, 0, 1, 0, 0},
	{"{P}{M_PHI1}.LLS", offsetof(struct seqg_vars, phi1Lls), "phi1Lls", P_SHORT, 1, 93, 0, 1, 0, 0},
	{"{P}{M_PHI2}.HLS", offsetof(struct seqg_vars, phi2Hls), "phi2Hls", P_SHORT, 1, 94, 0, 1, 0, 0},
	{"{P}{M_PHI2}.LLS", offsetof(struct seqg_vars, phi2Lls), "phi2Lls", P_SHORT, 1, 95, 0, 1, 0, 0},
	{"{P}HR{N}_phi1SetAO", offsetof(struct seqg_vars, phi1MotDesired), "phi1MotDesired", P_DOUBLE, 1, 96, 0, 1, 0, 0},
	{"{P}HR{N}_phi2SetAO", offsetof(struct seqg_vars, phi2MotDesired), "phi2MotDesired", P_DOUBLE, 1, 97, 0, 1, 0, 0},
	{"{P}{M_PHI1}.HLM", offsetof(struct seqg_vars, phi1MotHiLim), "phi1MotHiLim", P_DOUBLE, 1, 98, 22, 1, 0, 0},
	{"{P}{M_PHI1}.LLM", offsetof(struct seqg_vars, phi1MotLoLim), "phi1MotLoLim", P_DOUBLE, 1, 99, 23, 1, 0, 0},
	{"{P}{M_PHI2}.HLM", offsetof(struct seqg_vars, phi2MotHiLim), "phi2MotHiLim", P_DOUBLE, 1, 100, 24, 1, 0, 0},
	{"{P}{M_PHI2}.LLM", offsetof(struct seqg_vars, phi2MotLoLim), "phi2MotLoLim", P_DOUBLE, 1, 101, 25, 1, 0, 0},
	{"{P}{M_PHI1}", offsetof(struct seqg_vars, phi1MotCmd), "phi1MotCmd", P_DOUBLE, 1, 102, 0, 0, 0, 0},
	{"{P}{M_PHI2}", offsetof(struct seqg_vars, phi2MotCmd), "phi2MotCmd", P_DOUBLE, 1, 103, 0, 0, 0, 0},
	{"{P}{M_PHI1}", offsetof(struct seqg_vars, phi1MotCmdMon), "phi1MotCmdMon", P_DOUBLE, 1, 104, 26, 1, 0, 0},
	{"{P}{M_PHI2}", offsetof(struct seqg_vars, phi2MotCmdMon), "phi2MotCmdMon", P_DOUBLE, 1, 105, 27, 1, 0, 0},
	{"{P}{M_PHI1}.RBV", offsetof(struct seqg_vars, phi1MotRdbk), "phi1MotRdbk", P_DOUBLE, 1, 106, 28, 1, 0, 0},
	{"{P}{M_PHI2}.RBV", offsetof(struct seqg_vars, phi2MotRdbk), "phi2MotRdbk", P_DOUBLE, 1, 107, 30, 1, 0, 0},
	{"{P}HR{N}_worldOffAO", offsetof(struct seqg_vars, worldOff), "worldOff", P_DOUBLE, 1, 108, 32, 1, 0, 0},
	{"{P}HR{N}_worldTweakAI", offsetof(struct seqg_vars, worldTweakVal), "worldTweakVal", P_DOUBLE, 1, 109, 0, 1, 0, 0},
	{"{P}HR{N}_worldIncBO", offsetof(struct seqg_vars, worldTweakInc), "worldTweakInc", P_SHORT, 1, 110, 0, 1, 0, 0},
	{"{P}HR{N}_worldDecBO", offsetof(struct seqg_vars, worldTweakDec), "worldTweakDec", P_SHORT, 1, 111, 0, 1, 0, 0},
	{"{P}HR{N}_UseSetBO", offsetof(struct seqg_vars, useSetMode), "useSetMode", P_SHORT, 1, 112, 33, 1, 0, 0},
	{"{P}HR{N}_ETweakAI", offsetof(struct seqg_vars, ETweakVal), "ETweakVal", P_DOUBLE, 1, 113, 0, 1, 0, 0},
	{"{P}HR{N}_EIncBO", offsetof(struct seqg_vars, ETweakInc), "ETweakInc", P_SHORT, 1, 114, 0, 1, 0, 0},
	{"{P}HR{N}_EDecBO", offsetof(struct seqg_vars, ETweakDec), "ETweakDec", P_SHORT, 1, 115, 0, 1, 0, 0},
	{"{P}HR{N}_LambdaTweakAI", offsetof(struct seqg_vars, LTweakVal), "LTweakVal", P_DOUBLE, 1, 116, 0, 1, 0, 0},
	{"{P}HR{N}_LambdaIncBO", offsetof(struct seqg_vars, LTweakInc), "LTweakInc", P_SHORT, 1, 117, 0, 1, 0, 0},
	{"{P}HR{N}_LambdaDecBO", offsetof(struct seqg_vars, LTweakDec), "LTweakDec", P_SHORT, 1, 118, 0, 1, 0, 0},
	{"{P}HR{N}_Theta1TweakAI", offsetof(struct seqg_vars, th1TweakVal), "th1TweakVal", P_DOUBLE, 1, 119, 0, 1, 0, 0},
	{"{P}HR{N}_Theta1IncBO", offsetof(struct seqg_vars, th1TweakInc), "th1TweakInc", P_SHORT, 1, 120, 0, 1, 0, 0},
	{"{P}HR{N}_Theta1DecBO", offsetof(struct seqg_vars, th1TweakDec), "th1TweakDec", P_SHORT, 1, 121, 0, 1, 0, 0},
	{"{P}HR{N}_Theta2TweakAI", offsetof(struct seqg_vars, th2TweakVal), "th2TweakVal", P_DOUBLE, 1, 122, 0, 1, 0, 0},
	{"{P}HR{N}_Theta2IncBO", offsetof(struct seqg_vars, th2TweakInc), "th2TweakInc", P_SHORT, 1, 123, 0, 1, 0, 0},
	{"{P}HR{N}_Theta2DecBO", offsetof(struct seqg_vars, th2TweakDec), "th2TweakDec", P_SHORT, 1, 124, 0, 1, 0, 0},
	{"{P}HR{N}_thetaMin", offsetof(struct seqg_vars, thetaMin), "thetaMin", P_DOUBLE, 1, 125, 0, 1, 0, 0},
	{"{P}HR{N}_thetaMax", offsetof(struct seqg_vars, thetaMax), "thetaMax", P_DOUBLE, 1, 126, 0, 1, 0, 0},
};

/* Event masks for state set "hr_Ctl" */
static const seqMask seqg_mask_hr_Ctl_0_init[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_hr_Ctl_0_initSequence[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_hr_Ctl_0_waitForCmndEnter[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_hr_Ctl_0_waitForCmnd[] = {
	0xa3cb7ffe,
	0x000000c3,
	0x0c000000,
	0x1b6dc000,
};
static const seqMask seqg_mask_hr_Ctl_0_checkAutoMode[] = {
	0x00000000,
	0x00000100,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_hr_Ctl_0_phiLimits[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_hr_Ctl_0_checkDone[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_hr_Ctl_0_dInputChanged[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_hr_Ctl_0_tweak[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x1b6cc000,
};
static const seqMask seqg_mask_hr_Ctl_0_eChanged[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_hr_Ctl_0_lChanged[] = {
	0x00000000,
	0x04210200,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_hr_Ctl_0_thChanged[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_hr_Ctl_0_calcMovements[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00010000,
};
static const seqMask seqg_mask_hr_Ctl_0_moveHR[] = {
	0x00000000,
	0x00000180,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_hr_Ctl_0_updateRdbk[] = {
	0x00000000,
	0x00000000,
	0xfc000000,
	0x00000000,
};
static const seqMask seqg_mask_hr_Ctl_0_updateRdbkAfterDelay[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_hr_Ctl_0_motorsStopped[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_hr_Ctl_0_chkMotorLimits[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_hr_Ctl_0_chkMotorLimitsExit[] = {
	0x00000000,
	0x00000020,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_hr_Ctl_0_stopHR[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_hr_Ctl_0_stoppedHRWait[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};

/* State table for state set "hr_Ctl" */
static seqState seqg_states_hr_Ctl[] = {
	{
	/* state name */        "init",
	/* action function */   seqg_action_hr_Ctl_0_init,
	/* event function */    seqg_event_hr_Ctl_0_init,
	/* entry function */    seqg_entry_hr_Ctl_0_init,
	/* exit function */     0,
	/* event mask array */  seqg_mask_hr_Ctl_0_init,
	/* state options */     (0)
	},
	{
	/* state name */        "initSequence",
	/* action function */   seqg_action_hr_Ctl_0_initSequence,
	/* event function */    seqg_event_hr_Ctl_0_initSequence,
	/* entry function */    seqg_entry_hr_Ctl_0_initSequence,
	/* exit function */     0,
	/* event mask array */  seqg_mask_hr_Ctl_0_initSequence,
	/* state options */     (0)
	},
	{
	/* state name */        "waitForCmndEnter",
	/* action function */   seqg_action_hr_Ctl_0_waitForCmndEnter,
	/* event function */    seqg_event_hr_Ctl_0_waitForCmndEnter,
	/* entry function */    seqg_entry_hr_Ctl_0_waitForCmndEnter,
	/* exit function */     0,
	/* event mask array */  seqg_mask_hr_Ctl_0_waitForCmndEnter,
	/* state options */     (0)
	},
	{
	/* state name */        "waitForCmnd",
	/* action function */   seqg_action_hr_Ctl_0_waitForCmnd,
	/* event function */    seqg_event_hr_Ctl_0_waitForCmnd,
	/* entry function */    seqg_entry_hr_Ctl_0_waitForCmnd,
	/* exit function */     0,
	/* event mask array */  seqg_mask_hr_Ctl_0_waitForCmnd,
	/* state options */     (0)
	},
	{
	/* state name */        "checkAutoMode",
	/* action function */   seqg_action_hr_Ctl_0_checkAutoMode,
	/* event function */    seqg_event_hr_Ctl_0_checkAutoMode,
	/* entry function */    seqg_entry_hr_Ctl_0_checkAutoMode,
	/* exit function */     0,
	/* event mask array */  seqg_mask_hr_Ctl_0_checkAutoMode,
	/* state options */     (0)
	},
	{
	/* state name */        "phiLimits",
	/* action function */   seqg_action_hr_Ctl_0_phiLimits,
	/* event function */    seqg_event_hr_Ctl_0_phiLimits,
	/* entry function */    seqg_entry_hr_Ctl_0_phiLimits,
	/* exit function */     0,
	/* event mask array */  seqg_mask_hr_Ctl_0_phiLimits,
	/* state options */     (0)
	},
	{
	/* state name */        "checkDone",
	/* action function */   seqg_action_hr_Ctl_0_checkDone,
	/* event function */    seqg_event_hr_Ctl_0_checkDone,
	/* entry function */    seqg_entry_hr_Ctl_0_checkDone,
	/* exit function */     0,
	/* event mask array */  seqg_mask_hr_Ctl_0_checkDone,
	/* state options */     (0)
	},
	{
	/* state name */        "dInputChanged",
	/* action function */   seqg_action_hr_Ctl_0_dInputChanged,
	/* event function */    seqg_event_hr_Ctl_0_dInputChanged,
	/* entry function */    seqg_entry_hr_Ctl_0_dInputChanged,
	/* exit function */     0,
	/* event mask array */  seqg_mask_hr_Ctl_0_dInputChanged,
	/* state options */     (0)
	},
	{
	/* state name */        "tweak",
	/* action function */   seqg_action_hr_Ctl_0_tweak,
	/* event function */    seqg_event_hr_Ctl_0_tweak,
	/* entry function */    seqg_entry_hr_Ctl_0_tweak,
	/* exit function */     0,
	/* event mask array */  seqg_mask_hr_Ctl_0_tweak,
	/* state options */     (0)
	},
	{
	/* state name */        "eChanged",
	/* action function */   seqg_action_hr_Ctl_0_eChanged,
	/* event function */    seqg_event_hr_Ctl_0_eChanged,
	/* entry function */    seqg_entry_hr_Ctl_0_eChanged,
	/* exit function */     0,
	/* event mask array */  seqg_mask_hr_Ctl_0_eChanged,
	/* state options */     (0)
	},
	{
	/* state name */        "lChanged",
	/* action function */   seqg_action_hr_Ctl_0_lChanged,
	/* event function */    seqg_event_hr_Ctl_0_lChanged,
	/* entry function */    seqg_entry_hr_Ctl_0_lChanged,
	/* exit function */     0,
	/* event mask array */  seqg_mask_hr_Ctl_0_lChanged,
	/* state options */     (0)
	},
	{
	/* state name */        "thChanged",
	/* action function */   seqg_action_hr_Ctl_0_thChanged,
	/* event function */    seqg_event_hr_Ctl_0_thChanged,
	/* entry function */    seqg_entry_hr_Ctl_0_thChanged,
	/* exit function */     0,
	/* event mask array */  seqg_mask_hr_Ctl_0_thChanged,
	/* state options */     (0)
	},
	{
	/* state name */        "calcMovements",
	/* action function */   seqg_action_hr_Ctl_0_calcMovements,
	/* event function */    seqg_event_hr_Ctl_0_calcMovements,
	/* entry function */    seqg_entry_hr_Ctl_0_calcMovements,
	/* exit function */     0,
	/* event mask array */  seqg_mask_hr_Ctl_0_calcMovements,
	/* state options */     (0)
	},
	{
	/* state name */        "moveHR",
	/* action function */   seqg_action_hr_Ctl_0_moveHR,
	/* event function */    seqg_event_hr_Ctl_0_moveHR,
	/* entry function */    seqg_entry_hr_Ctl_0_moveHR,
	/* exit function */     0,
	/* event mask array */  seqg_mask_hr_Ctl_0_moveHR,
	/* state options */     (0)
	},
	{
	/* state name */        "updateRdbk",
	/* action function */   seqg_action_hr_Ctl_0_updateRdbk,
	/* event function */    seqg_event_hr_Ctl_0_updateRdbk,
	/* entry function */    seqg_entry_hr_Ctl_0_updateRdbk,
	/* exit function */     0,
	/* event mask array */  seqg_mask_hr_Ctl_0_updateRdbk,
	/* state options */     (0)
	},
	{
	/* state name */        "updateRdbkAfterDelay",
	/* action function */   seqg_action_hr_Ctl_0_updateRdbkAfterDelay,
	/* event function */    seqg_event_hr_Ctl_0_updateRdbkAfterDelay,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_hr_Ctl_0_updateRdbkAfterDelay,
	/* state options */     (0)
	},
	{
	/* state name */        "motorsStopped",
	/* action function */   seqg_action_hr_Ctl_0_motorsStopped,
	/* event function */    seqg_event_hr_Ctl_0_motorsStopped,
	/* entry function */    seqg_entry_hr_Ctl_0_motorsStopped,
	/* exit function */     0,
	/* event mask array */  seqg_mask_hr_Ctl_0_motorsStopped,
	/* state options */     (0)
	},
	{
	/* state name */        "chkMotorLimits",
	/* action function */   seqg_action_hr_Ctl_0_chkMotorLimits,
	/* event function */    seqg_event_hr_Ctl_0_chkMotorLimits,
	/* entry function */    seqg_entry_hr_Ctl_0_chkMotorLimits,
	/* exit function */     0,
	/* event mask array */  seqg_mask_hr_Ctl_0_chkMotorLimits,
	/* state options */     (0)
	},
	{
	/* state name */        "chkMotorLimitsExit",
	/* action function */   seqg_action_hr_Ctl_0_chkMotorLimitsExit,
	/* event function */    seqg_event_hr_Ctl_0_chkMotorLimitsExit,
	/* entry function */    seqg_entry_hr_Ctl_0_chkMotorLimitsExit,
	/* exit function */     0,
	/* event mask array */  seqg_mask_hr_Ctl_0_chkMotorLimitsExit,
	/* state options */     (0)
	},
	{
	/* state name */        "stopHR",
	/* action function */   seqg_action_hr_Ctl_0_stopHR,
	/* event function */    seqg_event_hr_Ctl_0_stopHR,
	/* entry function */    seqg_entry_hr_Ctl_0_stopHR,
	/* exit function */     0,
	/* event mask array */  seqg_mask_hr_Ctl_0_stopHR,
	/* state options */     (0)
	},
	{
	/* state name */        "stoppedHRWait",
	/* action function */   seqg_action_hr_Ctl_0_stoppedHRWait,
	/* event function */    seqg_event_hr_Ctl_0_stoppedHRWait,
	/* entry function */    seqg_entry_hr_Ctl_0_stoppedHRWait,
	/* exit function */     0,
	/* event mask array */  seqg_mask_hr_Ctl_0_stoppedHRWait,
	/* state options */     (0)
	},
};

/* Event masks for state set "updatePsuedo" */
static const seqMask seqg_mask_updatePsuedo_1_init[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_updatePsuedo_1_update[] = {
	0xac300000,
	0x00000000,
	0x00000000,
	0x00000000,
};

/* State table for state set "updatePsuedo" */
static seqState seqg_states_updatePsuedo[] = {
	{
	/* state name */        "init",
	/* action function */   seqg_action_updatePsuedo_1_init,
	/* event function */    seqg_event_updatePsuedo_1_init,
	/* entry function */    seqg_entry_updatePsuedo_1_init,
	/* exit function */     0,
	/* event mask array */  seqg_mask_updatePsuedo_1_init,
	/* state options */     (0)
	},
	{
	/* state name */        "update",
	/* action function */   seqg_action_updatePsuedo_1_update,
	/* event function */    seqg_event_updatePsuedo_1_update,
	/* entry function */    seqg_entry_updatePsuedo_1_update,
	/* exit function */     0,
	/* event mask array */  seqg_mask_updatePsuedo_1_update,
	/* state options */     (0)
	},
};

/* State set table */
static seqSS seqg_statesets[] = {
	{
	/* state set name */    "hr_Ctl",
	/* states */            seqg_states_hr_Ctl,
	/* number of states */  21
	},

	{
	/* state set name */    "updatePsuedo",
	/* states */            seqg_states_updatePsuedo,
	/* number of states */  2
	},
};

/* Program table (global) */
seqProgram hrCtl = {
	/* magic number */      2002005,
	/* program name */      "hrCtl",
	/* channels */          seqg_chans,
	/* num. channels */     93,
	/* state sets */        seqg_statesets,
	/* num. state sets */   2,
	/* user var size */     sizeof(struct seqg_vars),
	/* param */             "P=xxx:, N=1, M_PHI1=m9, M_PHI2=m10",
	/* num. event flags */  33,
	/* encoded options */   (0 | OPT_CONN | OPT_NEWEF | OPT_REENT),
	/* init func */         seqg_init,
	/* entry func */        0,
	/* exit func */         0,
	/* num. queues */       0
};
# line 1542 "../hrCtl.st"




static double hrCtl_calc2dSpacing(struct UserVar *pVar, int xtal, double A, double H, double K, double L)
{
 double result;
 float avg;
 int nint;

 result = (2*A)/sqrt(H*H + K*K + L*L);


 pVar->opAlert = 0;
 if (((fmod(H,2)) != (fmod(K,2))) || ((fmod(H,2)) != (fmod(L,2))))
  pVar->opAlert = 1;
 avg = (H+K+L)/2.0;
 nint = (int)((avg)>0 ? (avg)+0.5 : (avg)-0.5);
 if ((fabs(avg-nint) <= .25) && (fmod(nint,2)))
  pVar->opAlert = 1;
 if (pVar->opAlert) {
  sprintf(pVar->seqMsg1, "Invalid HKL combination for crystal %1d", xtal);
 }
    return(result);
}

static void hrCtl_calcReadback(struct UserVar *pVar)
{

 pVar->phi1Rdbk = pVar->phi1MotRdbk * pVar->uR2D +
  (pVar->phi1Off + pVar->worldOff*pVar->uR2D);
 pVar->theta1Rdbk = pVar->phi1Rdbk;

 switch (pVar->opMode) {
 case 0:
  pVar->lambdaRdbk = pVar->D1*sin(pVar->theta1Rdbk*pVar->D2R);
  break;

 case 1:
  if (pVar->Geom == 0) {
   pVar->phi2Rdbk = pVar->phi2MotRdbk * pVar->uR2D +
    (pVar->phi2Off + pVar->worldOff*pVar->uR2D);
  } else {
   pVar->phi2Rdbk = pVar->phi2MotRdbk * pVar->uR2D +
    (pVar->phi2Off - pVar->worldOff*pVar->uR2D);
  }
  pVar->lambdaRdbk = pVar->D1*sin(pVar->theta1Rdbk*pVar->D2R);
  break;

 case 2:
  if (pVar->Geom == 0) {
   pVar->phi2Rdbk = pVar->phi2MotRdbk * pVar->uR2D +
    (pVar->phi2Off + pVar->worldOff*pVar->uR2D);
  } else {
   pVar->phi2Rdbk = pVar->phi2MotRdbk * pVar->uR2D +
    (pVar->phi2Off - pVar->worldOff*pVar->uR2D);
  }
  pVar->theta2Nom = asin(pVar->D1*sin(pVar->theta1Rdbk*pVar->D2R)/pVar->D2) * pVar->R2D;
  if (pVar->Geom == 0) {
   pVar->lambdaRdbk = pVar->D1*sin(pVar->theta1Rdbk*pVar->D2R) +
    pVar->D2R * (pVar->phi2Rdbk - pVar->phi1Rdbk - pVar->theta1Rdbk - pVar->theta2Nom) /
    ( 1/(pVar->D1*cos(pVar->theta1Rdbk*pVar->D2R)) + 1/(pVar->D2*cos(pVar->theta2Nom*pVar->D2R)) );
  } else {
   pVar->lambdaRdbk = pVar->D1*sin(pVar->theta1Rdbk*pVar->D2R) +
    pVar->D2R * (pVar->phi2Rdbk - pVar->theta2Nom) /
    ( 1/(pVar->D1*cos(pVar->theta1Rdbk*pVar->D2R)) + 1/(pVar->D2*cos(pVar->theta2Nom*pVar->D2R)) );
  }
  break;
 }
 pVar->theta1Rdbk = asin(pVar->lambdaRdbk/pVar->D1) * pVar->R2D;
 if (pVar->opMode != 0) pVar->theta2Rdbk = asin(pVar->lambdaRdbk/pVar->D2) * pVar->R2D;
 pVar->ERdbk = pVar->hc/pVar->lambdaRdbk;

 return;
}



/* Register sequencer commands and program */
#include "epicsExport.h"
static void hrCtlRegistrar (void) {
    seqRegisterSequencerCommands();
    seqRegisterSequencerProgram (&hrCtl);
}
epicsExportRegistrar(hrCtlRegistrar);
